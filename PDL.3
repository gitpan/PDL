.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PDL 1 "perl 5.003 with" "11/Oct/96" "User Contributed Perl Documentation"
.IX Title "PDL 1"
.UC
.IX Name "=head2 PDL - Perl Data Language extension module"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
.Sh "\s-1PDL\s0 \- Perl Data Language extension module"
.IX Subsection "\s-1PDL\s0 \- Perl Data Language extension module"
Version 1.00 alpha
.PP
\*(L"Why is it that we entertain the belief that for every purpose odd
numbers are the most effectual?\*(R" \- Pliny the Elder.
.PP
\fIKarl Glazebrook, \s-1AAO\s0, 4/10/1996. [kgb@aaoepp.aao.gov.au]\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The perlDL concept is to give standard perl5 the ability to COMPACTLY
store and SPEEDILY manipulate the large N\-dimensional data sets which
are the bread and butter of scientific computing. e.g. \f(CW$a=$b+$c\fR can
add two 2048x2048 images in only a fraction of a second.
.PP
It is hoped to eventually provide tons of useful functionality for
scientific and numeric analysis.
.Sh "Introduction"
.IX Subsection "Introduction"
The fundamental perl data structures are scalar variables, e.g. \f(CW$x\fR,
which can hold numbers or strings, lists or arrays of scalars, e.g. \f(CW@x\fR,
and associative arrays/hashes of scalars, e.g. \f(CW%x\fR.
.PP
perl v5 introduces to perl data structures and objects. A simple
scalar variable \f(CW$x\fR now be a user-defined data type or full blown
object*.
.PP
The fundamental idea behind perlDL is to allow \f(CW$x\fR to hold a whole 1D
spectrum, or a 2D image, a 3D data cube, and so on up to large
N\-dimensional data sets. These can be manipulated all at once, e.g.
\f(CW$a = $b + 2\fR does a vector operation on each value in the
spectrum/image/etc.
.PP
You may well ask: \*(L"Why not just store a spectrum as a simple perl \f(CW@x\fR
style list with each pixel being a list item?\*(R"  The two key answers to
this are \s-1MEMORY\s0 and \s-1SPEED\s0.  Because we know our spectrum consists of
pure numbers we can compactly store them in a single block of memory
corresponding to a C style numeric array. This takes up a \s-1LOT\s0 less
memory than the equivalent perl list. It is then easy to pass this
block of memory to a fast addition routine, or to any other C function
which deals with arrays.  As a result perlDL is very fast --- for example
one can mulitiply a 2048*2048 image in exactly the same time as it
would take in C or \s-1FORTRAN\s0 (0.1 sec on my \s-1SPARC\s0). A further advantage
of this is that for simple operations (e.g. \f(CW$x += 2\fR) one can manipulate
the whole array without caring about its dimensionality.
.PP
I find when using perlDL it is most useful to think of standard perl
\f(CW@x\fR variables as \*(L"lists\*(R" of generic \*(L"things\*(R" and \s-1PDL\s0 variables like
\f(CW$x\fR as \*(L"arrays\*(R" which can be contained in lists or hashes. Quite
often in my perlDL scripts I have \f(CW@x\fR contain a list of spectra, or a
list of images (or even a mix!). Or perhaps one could have a hash
(e.g.  \f(CW%x\fR) of images... the only limit is memory!
.PP
perlDL variables support a range of data types \- arrays can be bytes,
short intgers (signed or unsigned), long integers, floats or
double precision floats.
.PP
* It actually holds a reference (a smart \*(L"pointer") to this 
but that is not relevant for ordinary use of perlDL.
.Sh "Usage"
.IX Subsection "Usage"
perlDL is loaded into your perl script using these commands:
.PP
.Vb 6
\&   use PDL;  # use the standard perlDL modules (Core Examples Io Graphics::PG)
\&   
\&   use PDL::Examples; # use only the Examples module (this will load 
\&                      # internally whatever other modules it needs).
\&   
\&   % perldl  # Invoke interactive shell from system command line.
.Ve
The default is to import all the function names from a module. If you
only want certain names imported just say:
.PP
.Vb 1
\&   use PDL::Io qw(rfits rgrep) # Get only rfits() and rgrep from PDL::Io
.Ve
Also see below on \*(L"Object-Orientation\*(R".
.Sh "To create a new \s-1PDL\s0 variable"
.IX Subsection "To create a new \s-1PDL\s0 variable"
Here are some ways of creating a \s-1PDL\s0 variable:
.PP
.Vb 11
\&   $a = pdl [1..10];             # 1D array
\&   $a = pdl (1,2,3,4);           # Ditto
\&   $b = pdl [[1,2,3],[4,5,6]];   # 2D 3x2 array
\&   $c = pdl $a;                  # Make a new copy
\&   
\&   $d = byte [1..10];            # See "Type conversion"
\&   $e = zeroes(3,2,4);           # 3x2x4 zero-filled array
\&   
\&   $c = rfits $file;             # Read FITS file 
\&   
\&   @x = ( pdl(42), zeroes(3,2,4), rfits($file) ); # Is a LIST of PDL variables!
.Ve
The \f(CWpdl()\fR function is used to initialise a \s-1PDL\s0 variable from a scalar,
list, list reference or another \s-1PDL\s0 variable.
.PP
In addition all \s-1PDL\s0 functions automatically convert normal perl scalars
to \s-1PDL\s0 variables on-the-fly.
.PP
(also see \*(L"Type Conversion\*(R" and \*(L"Input/Output\*(R" sections below)
.Sh "Arithmetic"
.IX Subsection "Arithmetic"
.PP
.Vb 12
\& $a = $b + 2; $a++; $a = $b / $c; # Etc.
\& 
\& $c=sqrt($a); $d = log10($b+100); # Etc
\& 
\& $e = $a>42; # Vector condtional (like MATLAB) - 
\&             # note I think this is much nicer than IDLs WHERE(), e.g.:
\& 
\& $e = 42*($a>42) + $a*($a<=42); # Cap top
\& 
\& $a = $a / ( max($a) - min($a) );
\& 
\& print $a; # $a in string context prints it in a N-dimensional format
.Ve
(and other perl operators/functions)
.Sh "Matrix functions"
.IX Subsection "Matrix functions"
\f(CW'x'\fR is hijacked as the matrix multiplication operator. e.g. 
\f(CW$c = $a x $b\fR;
.PP
perlDL is row-major not column major so this is actually
\f(CWc(i,j) = sum_k a(k,j) b(i,k)\fR \- but when matrices are printed the
results will look right. Just remember the indices are reversed.
e.g.:
.PP
.Vb 6
\&      $a = [                   $b = [
\&            [ 1  2  3  0]            [1 1]
\&            [ 1 -1  2  7]            [0 2]
\&            [ 1  0  0  1]            [0 2]
\&           ]                         [1 1]
\&                                    ]
.Ve
.Vb 5
\&      gives $c = [
\&                  [ 1 11]
\&                  [ 8 10]
\&                  [ 2  2]
\&                 ]
.Ve
Note: \fItranspose()\fR does what it says and is a convenient way
to turn row vectors into column vectors. It is bound to
the unary operator \f(CW'~'\fR for convenience.
.Sh "How to write a simple function"
.IX Subsection "How to write a simple function"
.PP
.Vb 5
\&   sub dotproduct { 
\&       my ($a,$b) = @_;
\&       return sum($a*$b) ;
\&   }
\&   1;
.Ve
If put in file dotproduct.pdl would be autoloaded (see below).
 
.Sh "Type Conversion"
.IX Subsection "Type Conversion"
Default for \fIpdl()\fR is double. Conversions are:
.PP
.Vb 3
\&   $a = float($b); 
\&   $c = long($d);   # "long" is 4 byte int
\&   $d = byte($a);
.Ve
Also \fIdouble()\fR, \fIshort()\fR, \fIushort()\fR.
.PP
These routines also automatically convert perl lists to
allow the convenient shorthand:
.PP
.Vb 2
\&   $a = byte [[1..10],[1..10]];  # Create 2D byte array
\&   $a = float [1..1000];         # Create 1D float array
.Ve
etc.
.PP
Rules for automatic conversion during arithmetic:
.PP
.Vb 1
\&  If INT = any of byte/short/ushort/int and X is generic op
.Ve
.Vb 1
\&  For VECTOR x SCALAR these rules avoid overpromotion of vector types:
.Ve
.Vb 3
\&  VECTOR INT   X SCALAR INT            Return is same type as VECTOR
\&  VECTOR INT   X SCALAR float/double   Return float
\&  VECTOR float X SCALAR float/double   Return float
.Ve
.Vb 2
\&  For other VECTORxSCALAR and VECTORxVECTOR returns "highest" of
\&  two data types. i.e. VECTOR double x float returns float etc.
.Ve
.Sh "Printing"
.IX Subsection "Printing"
Automatically expands array in N\-dimensional format:
.PP
.Vb 3
\&   print $a;  
\&    
\&   $b = "Answer is = $a ";
.Ve
.Sh "Sections"
.IX Subsection "Sections"
perlDL betrays its perl/C heritage in that arrays are zero-offset.
Thus a 100x100 image has indices \f(CW0..99,0..99\fR.
.PP
Further I adopt the convention that the center of the pixel (0,0)
\s-1IS\s0 at coordinate (0.0,0.0). Thus the above image ranges from
\f(CW-0.5..99.5, -0.5..99.5\fR in real space. All perlDL graphics functions
conform to this defintion and hide away the unit-offsetness
of, for example, the \s-1PGPLOT\s0 \s-1FORTRAN\s0 library.
.PP
Again following the usual convention coordinate (0,0) is displayed
at the bottom left when displaying an image. It appears at the
top right when using \*(L"\f(CWprint $a\fR\*(R" etc.
.PP
.Vb 11
\&   $b  = sec($a,  $x1, $x2, $y1, $y2, $z1, $z2, ... ) # Take subsection
\&   $newimage = ins($bigimage,$smallimage,$x,$y,$z...) # Insert at x,y,z
\&   
\&   $c  = nelem ($a); # Number of pixels
\&   
\&   $val = at($object, $x,$y,$z...)    # Pixel value at position
\&   set($myimage, $x, $y, ... $value)  # Set value in image 
\&   
\&   $b = xvals($a); # Fill array with X-coord values (also yvals(), zvals(),
\&                   # axisvals($x,$axis) and rvals() for radial distance 
\&                   # from centre).
.Ve
(Note: I hope to enable syntax like \f(CW$$a{'0..200,3..200'}\fR using
\f(CWtie()\fR but I am still thinking about the ramifications of this)
.Sh "Input/Output"
.IX Subsection "Input/Output"
The \s-1PDL::\s0Io module currently implements the following useful I/O
functions:
.PP
.Vb 2
\&   $a  = rfits($file)  # Read a FITS file into a PDL variable
\&                       # (only IEEE float machines as yet)
.Ve
.Vb 6
\&   wfits ($a, $file)  # Write FITS file 
\&   
\&   ([$xaxis],$data) = rdsa($file)   # Read a STARLINK/FIGARO file using
\&                                    # perl DSA module (available seperately)
\&   
\&Read ASCII columns into $x, $y, etc.:
.Ve
.Vb 1
\&   ($x,$y,...) = rcols($file,[[$pattern],[$col1, $col2,] ...)  
.Ve
Read \f(CW$1\fR, \f(CW$2\fR, etc. pattern matches into \f(CW$x\fR, \f(CW$y\fR, etc.
.PP
.Vb 7
\&   ($x,$y,...) = rgrep($file, $pattern)    
\&   
\&e.g.:
\&   
\&   ($x,$y) = rcols $file, '/Mumble/', 2,3;
\&   ($a,$b) = rgrep $file, '/Foo (.*) Bar (.*) Mumble/';
\&   
.Ve
.Sh "Graphics"
.IX Subsection "Graphics"
The philosophy behind perlDL is to make it work with a variety of
existing graphics libraries since no single package will satisfy all
needs and all people and this allows one to work with packages one
already knows and likes.  Obviously there will be some overlaps in
functionality and some lack of consistency and uniformity. This also
saves the author from too much work in time he doesn't have!
.Ip "1." 4
.IX Item "1."
\s-1PGPLOT\s0
.Sp
\s-1PGPLOT\s0 provdes a simple library for line graphics and image display.
.Sp
There is an easy interface to this in the interna;l module
\s-1PDL::\s0Graphics::\s-1PG\s0. (This calls routines in the separately available
\s-1PGPLOT\s0 top-level module.)
.Sp
Current display commands:
.Sp
.Vb 10
\&   imag         -  Display an image (uses pgimag()/pggray() as appropriate)
\&   ctab         -  Load an image colour table
\&   line         -  Plot vector as connected points
\&   points       -  Plot vector as points
\&   errb         -  Plot error bars
\&   cont         -  Display image as contour map
\&   bin          -  Plot vector as histogram ( e.g. bin(hist($data)) )
\&   hi2d         -  Plot image as 2d histogram (not very good IMHO...)
\&   poly         -  Draw a polygon
\&   vect         -  Display 2 images as a vector field
.Ve
Device manipulation commands:
.Sp
.Vb 7
\&   hold         -  Hold current plot window range - allows overlays etc.
\&   release      -  Release back to autoscaling of new plot window for each command
\&   rel          -  short alias for 'release'
\&   env          -  Define a plot window, put on 'hold'
\&   dev          -  Explicitly set a new PGPLOT graphics device
\&   
\&e.g:
.Ve
.Vb 7
\&   perldl> $a = pdl [1..100]
\&   perldl> $b = sqrt($a)
\&   perldl> line $b      
\&   perldl> hold
\&   Graphics on HOLD
\&   perldl> $c = sin($a/10)*2 + 4
\&   perldl> line $c     
.Ve
Notes: \f(CW$transform\fR for image/cont etc. is used in the same way as the
\fI\s-1TR\s0()\fR array in the underlying \s-1PGPLOT\s0 \s-1FORTRAN\s0 routine but is, fortunately,
zero-offset.
.Sp
It is also hoped to use other graphic libraries to enable more sophisticated
plots then is possible with \s-1PGPLOT\s0. Some ideas:
.Ip "2." 4
.IX Item "2."
\s-1IIS\s0
.Sp
Many astronomers like to use SAOimage and Ximtool (or there
derivations/clones). These are useful free widgets for inspection and
visualisation of images. (They are not provided with perlDL but can
easily be obtained from their official sites off the Net.)
.Sp
The \s-1PDL::\s0Graphics::\s-1IIS\s0 package provides allows one to display images
in these ("\s-1IIS\s0\*(R" is the name of an ancient item of image display
hardware whose protocols these tools conform to.)
.Sp
Commands are:
.Sp
.Vb 5
\&   iis         - display image
\&   iiscur      - return a cursor position
\&   iiscirc     - draw circles on image display
\&   saoimage    - start SAOimage 
\&   ximtool     - start Ximtool
.Ve
Variables are:
.Sp
.Vb 2
\&   $stdimage  - frame buffer configuration
\&   $iisframe  - frame buffer number to display in
.Ve
The frame buffer configuration is set by the variable \f(CW$stdimage\fR
(analagous to iraf) whose default is \*(L"imt1024\*(R". System and user
imtoolrc files are parsed so if you know about these you can do
the same tricks as you can in with \s-1IRAF\s0.
.Ip "3. " 4
.IX Item "3. "
Karma
.Sp
To come?
.Sh "Autoloading"
.IX Subsection "Autoloading"
If a \s-1PDL\s0 function, e.g. \f(CWfoo()\fR, is currently undefined a file
\*(L"foo.pdl\*(R" is searched for in the current directory, and any directories
in \f(CW$PDLLIB\fR, \f(CW$PERL5LIB\fR and \f(CW$PERLLIB\fR enviroment variables.  (These are \*(L":\*(R"
seperated lists of directories.)
.PP
If you want to change the path within perldl simply change the lists
\f(CW@PDLLIB\fR and \f(CW@INC\fR.
.PP
Note: \*(L"foo.pdl\*(R" is require'd so it must return a true value (see
\*(L"require\*(R" perl documentation).
.Sh "Call External"
.IX Subsection "Call External"
This provides a simple way to pass the data arrays from pdl
variables to external C routines. It uses perl's built-in
dynamic loader to load compiled C code.
.PP
The syntax is:
.PP
.Vb 1
\&   callext($file,$symbol, @pdl_list) 
.Ve
@pdl_list is a list of pdl variables. Numbers get converted
automatically. The file must be dynamically loadable object code \- how
the C compiler generates this will be different from system to system
so see your man pages.
.PP
The C routine takes args \f(CW(int nargs, pdl *args)\fR. The C type \f(CW"pdl"\fR is a
simple data structure representing the perl pdl variable. It is defined
in file \*(L"pdl.h\*(R" which is included in the perlDL distribution and has no
perl dependencies.  It is trivial to cast the data array (pdl.data) to
(float), (double) etc. and pass to any other C routine.
.PP
This is all demonstrated in the files \*(L"testcallext.*\*(R" in the perlDL
distribution.
.PP
Note: This is only intended as a quick and dirty prototyping interface
for the scientist/hacker. perlDL developers should write a module
along the lines of the example \s-1PDL::\s0Examples.
.Sh "perldl shell"
.IX Subsection "perldl shell"
The perl script \f(CWperldl\fR provides a simple command line \- if the latest
Readlines/ReadKey modules have beeen installed \f(CWperldl\fR detects this
and enables command line recall and editing.
.PP
e.g.:
.PP
.Vb 9
\&   % perldl
\&   ReadLines enabled
\&   perldl> $a = rfits "foo.fits"
\&   BITPIX =  -32  size = 88504 pixels 
\&   Reading  354016 bytes
\&   BSCALE =  &&  BZERO = 
\&   
\&   perldl> imag log($a+400)
\&   Displaying 299 x 296 image from 4.6939525604248 to 9.67116928100586 ...
.Ve
You can also run it from the perl debugger (\f(CWperl -MPDL -d -e 1\fR)
if you want.
.PP
Miscellaneous shell features:
.Ip "1. " 4
.IX Item "1. "
The command \f(CWperldl -oo\fR starts perldl in Object-Oriented mode. It does 
\f(CWuse PDL::OO\fR instead of \f(CWuse PDL\fR.
.Ip "2. " 4
.IX Item "2. "
The shell aliases \f(CWp\fR to be a convenient short form of \f(CWprint\fR, e.g.
.Sp
.Vb 7
\&   perldl> p ones 5,3
\&    
\&   [
\&    [1 1 1 1 1]
\&    [1 1 1 1 1]
\&    [1 1 1 1 1]
\&   ]
.Ve
.Ip "3. " 4
.IX Item "3. "
The files \f(CW~/.perldlrc\fR and \f(CWlocal.perldlrc\fR (in the current
directory) are sourced if found. This allows the user to have global
and local \s-1PDL\s0 code for startup.
.Ip "4. " 4
.IX Item "4. "
Any line starting with the \f(CW#\fR character is treated as a shell
escape. This character is configurable by setting the perl variable
\f(CW$PERLDL_ESCAPE\fR. This could, for example, be set in \f(CW~/.perldlrc\fR.
.Sh "Overload operators"
.IX Subsection "Overload operators"
I have overloaded the following builtin perl operators and
functions in order that they work on \s-1PDL\s0 variables:
.PP
.Vb 2
\&   + - * / > < >= <= << >> & | ^ == != <=> ** % ! ~
\&   sin log abs atan2 sqrt cos exp 
.Ve
[All the unary functions (sin etc.) may be used with \fIinplace()\fR \- see
\*(L"Memory\*(R" below.]
.Sh "Object-Orientation and perlDL"
.IX Subsection "Object-Orientation and perlDL"
[Astronomers can ignore this bit! :\-)]
.PP
pdl variables such as \f(CW$x\fR are implemented via Perl objects. However
I have chosen to use an all-functional approach to perlDL syntax yo
be  more astronomer friendly.
.PP
However you can use perlDL in an \s-1OO\s0 fashion. In fact if you say:
.PP
.Vb 1
\&   use PDL::OO;
.Ve
It will load \s-1PDL\s0 functions as \s-1OO\s0 methods in the \s-1PDL\s0 class. This
means you can say things like:
.PP
.Vb 4
\&   $a = PDL->rfits('m51.fits');
\&   $b = PDL->new([1,2,2,1],[1,2,2,1],[1,2,2,1],[1,2,2,1]);
\&   $smooth = $a->convolve($b);
\&   $smooth->iis;
.Ve
You can start the perldl shell in this mode with \*(L"perldl \-oo\*(R".
.PP
Note: as you can see from the above all functions which create pdl
variables are used with construct syntax in the \s-1OO\s0 mode. Finally you
can even use both forms by simply saying \*(L"use \s-1PDL\s0; use \s-1PDL::OO\s0\*(R".
.PP
You can inherit from \s-1PDL\s0 methods (e.g. to a class Foo)
by simply saying:
.PP
.Vb 2
\&   @Foo::ISA = ('PDL');               # Method path
\&   %Foo::OVERLOAD = %PDL::OVERLOAD;   # Copy overload
.Ve
Then \s-1PDL\s0 methods will work on Foo objects as long as you simply build
on the existing \s-1PDL\s0 data structure (see below) components.
.PP
So it would be possible to provide \s-1USER\s0 written modules to do really
cool stuff for specific application areas, e.g. \s-1PDL::\s0Spectrum might
provide a \f(CW$a\fR which understands X\-axes and error bars and +\-/+ etc.
might be overriden to do the Right Thing (tm). And writing the module
would not be rocket science \- just some cool perl hacking.
.PP
And you would not have to even use method syntax \- if \f(CW$a\fR came out of my
hypothetical \s-1PDL::\s0Spectrum all the standard pdl functions (like \fIhist()\fR
to give a concreate example) would work on it in the standard way
provided they simply built on the existing \s-1PDL\s0 data structure (which
means simply containing a $$a{Data} etc. \s-1PDL::\s0Spectrum could even
export it's own \fIhist()\fR function to override the built-in which might do
something more sophisticated using the X\-axis for example.
.PP
If you were feeling really ambitious you might do \s-1PDL::\s0Ir::Spectrum
which understood about the gaps between the J H and K bands!
.Sh "Memory usage and references"
.IX Subsection "Memory usage and references"
Messing around with really huge data arrays may require some care.
perlDL provides some facilities to let you perform operations on big
arrays without generating extra copies though this does require a bit
more thought are care from the programmer.
.PP
\s-1NOTE\s0: On some most systems it is better to configure perl (during the
build options) to use the system \fImalloc()\fR function rather than perl's
built-in one. This is because perl's one is optimised for speed rather
than consumption of virtual memory \- this can result in a factor of
two improvement in the amount of memory storage you can use.
.Ip "1." 5
.IX Item "1."
Simple arithmetic
.Sp
If \f(CW$a\fR is a big image (e.g. occupying 10MB) and I say:
.Sp
.Vb 1
\&   $a = $a + 1;
.Ve
then the total \fImalloc()\fR'd memory usage grows to 20MB. This is because
the expression \*(L"$a+1\*(R" creates a temporary copy of \f(CW$a\fR to hold the
result, then \f(CW$a\fR is assigned a reference to that. It is obviously done
this way so \*(L"$c=$a+1\*(R" works as expected.
.Sp
Also if one says:
.Sp
.Vb 2
\&   $b = $a;     # $b and $a now point to same data
\&   $a = $a + 1;
.Ve
Then \f(CW$b\fR and \f(CW$a\fR end up being different, as one naively expects,
because a new reference is created and \f(CW$a\fR is assigned to it.
.Sp
However if \f(CW$a\fR was a huge memory hog (e.g. a 3D volume) creating a copy
of it may not be a good thing. One can avoid this memory overhead in
the above example by saying:
.Sp
.Vb 1
\&   $a++;
.Ve
The operations \f(CW++,+=,--,-=\fR, etc. all call a special \*(L"in-place\*(R"
version of the arithmetic subroutine. This means no more memory is
needed \- the downside of this is that if \f(CW$b\fR=$a then \f(CW$b\fR is also
incremented. To force a copy explicitly:
.Sp
.Vb 1
\&   $b = pdl $a; # Real copy
.Ve
.Ip "2." 5
.IX Item "2."
Functions
.Sp
Most functions, e.g. \fIlog()\fR, return a result which is a transformation
of their argument. This makes for good programming practice. However many 
operations can be done \*(L"in-place\*(R" and this may be required when large
arrays are in use and memory is at a premium. For these circumstances
the operator \fIinplace()\fR is provided which prevents the extra copy and
allows the argument to be modified. e.g.:
.Sp
.Vb 2
\&   $x = log($array);          # $array unaffected
\&   log( inplace($bigarray) ); # $bigarray changed in situ
.Ve
.PP
\s-1WARNINGS\s0: 
.Ip "1. The usual caveats about duplicate references apply. " 5
.IX Item "1. The usual caveats about duplicate references apply. "
.Ip "2. Obviously when used with some functions which can not be applied in situ (e.g. convolve()) unexpected effects may occur! I try to indicate inplace() safe functions below." 5
.IX Item "2. Obviously when used with some functions which can not be applied in situ (e.g. convolve()) unexpected effects may occur! I try to indicate inplace() safe functions below."
.Ip "3. Type conversions [e.g. float()] may cause hidden copying." 5
.IX Item "3. Type conversions [e.g. float()] may cause hidden copying."
.Sh "Data Structure Guts"
.IX Subsection "Data Structure Guts"
(For born fiddlers only.)
.PP
The data structure for \f(CW$a\fR is implemented by a hash (associative array)
which \f(CW$a\fR is a (blessed) reference too.
.PP
\s-1PDL\s0 reserves for it's own use:
.PP
.Vb 15
\&   $$a{Data} ; # The DATA (byte list) - can be passed directly to F77/C
\&               # subroutine as long as type matches. e.g. line() does a
\&               # float() and then calls PGPLOT::pgline_r (bypassing packing)
\&   
\&   $$a{Datatype}; # Holds numeric data type, $PDL_F, $PDL_D, etc...
\&   
\&   $$a{Dims} ; # List reference holding dimensions. 
\&               # E.g. @mydims = @{ $$a{Dims} };
\&   
\&   $$a{Hdr}  ; # Optional extra hash reference holding header, e.g.
\&               # $airmass = $$a{Hdr}{'AIRMASS'}; %myhdr = %{ $$a{Hdr} };
\&               # rfits() populates this from the FITS header.
\&   
\&   $$a{Inplace}; # Flag - inplace() sets this. Next time a copy is attempted
\&                 # it does not occur and the flag is unset.
.Ve
Anything else stored in the structure will be copied to new objects
(e.g. by \f(CW$b\fR = \f(CW$a\fR + 1) automatically as long as \s-1PDL\s0 knows how to copy it.
[If it is a reference to another object \s-1PDL\s0 tries the \->copy method.]
.PP
If your perl routine manipulates the data structure guts directly, 
you don't want it to blow up in your face if you pass it a simple
number rather than a \s-1PDL\s0 variable. Simply call the function 
\fItopdl()\fR first to make it safe. e.g.:
.PP
.Vb 1
\&   sub myfiddle { my $pdl = topdl(shift); $$pdl{Data} = ... }
.Ve
\fItopdl()\fR does \s-1NOT\s0 perform a copy if a pdl variable is passed \- it
just falls through \- which is obviosuly the desired behaviour. The
routine is not of course necessary in normal user defined functions
which do not care about internals.
.PP
Finally there is no reason why the data structure should not
contain another \s-1PDL\s0 variable!
.Sh "Complete List of Exported Functions"
.IX Subsection "Complete List of Exported Functions"
Defined in \s-1PDL::\s0Core
 
.PP
.Vb 28
\& byte short ushort long float double convert   - Type Conversions
\& 
\& pdl          - Create/copy a pdl 
\& topdl        - Coerce to pdl if scalar
\& howbig       - Size of pdl datatype in bytes
\& nelem        - Number of elements 
\& dims         - Return list of dimensions, e.g. @mydims = dims($x);
\& list         - Convert pdl to list - e.g. for (list $x) {..}
\& listindices  - Return list of index values (1D) - e.g. for $i 
\&                (listindices $x) {..}
\& log10*       - Take log base 10
\& min max sum  - Min/max/sum of pdl array
\& zeroes/ones  - Create zero/one-filled pdl array
\& sequence     - Create sequence-filled pdl array
\& reshape      - reshape the dimensions of a pdl array
\& sec          - subsection
\& ins* / set   - insertion / setting
\& at           - return pixel value at (x,y,z...)
\& 
\& axisvals* xvals* yvals* zvals* - Fill pdl with axis values
\& 
\& rvals        - Fill pdl with distance from it's center
\& callext      - Call external C routine in dynamically loadable object
\& convolve     - convolve image with kernel (real space)
\& inplace      - Flag for inplace operation
\& hist         - histogram of data 
\& stats        - return mean + standard deviation
\& transpose    - matrix transpose
.Ve
Defined in \s-1PDL::\s0Examples
.PP
This contains examples of how to add C functiions via \s-1XS\s0
including use of the generic preprocessor (.g files are
automatically converted to .c files with code automatically
generated for each datatype).
.PP
.Vb 2
\& fibonacci*    - Compute Fibonacci series (simple 1D example)
\& cc8compt*     - Connected 8-component labelling (2D example)
.Ve
Defined in \s-1PDL::\s0Io
.PP
[See \*(L"Io\*(R" section above]
.PP
Defined in \s-1PDL::\s0Graphics::*
.PP
[See \*(L"Graphics\*(R" section above]
.PP
Footnotes:
.PP
* = indicates \f(CWinplace()\fR safe & useful with this function

.rn }` ''

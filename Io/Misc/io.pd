# REPLACE FOLLOWING BY
#
# use PDL::PP qw/PDL::Experiment PDL::Experiment Experiment/;
# 
# when using not in this package.

pp_add_exported('',"rfits wfits rcols rgrep rdsa");

############################## PM CODE ########################################

pp_addpm(<<'EOD');

use PDL::Types;
use Carp;

sub rfits { # Read a FITS format file and return a PDL

   croak 'Usage: $a = rfits($file)' if $#_!=0;
   my $file = shift; my $pdl  = pdl();
   my($nbytes, $line, $name, $rest, $size, $i, $bscale, $bzero);

   open(FITS, $file) || croak "FITS file $file not found";
   $nbytes = 0; # Number of bytes read so far
   $line = "";

   # ***CROCK*** Need to think about what must be done with the header

   my $foo={};       # Should go in pdl
   $$foo{Hdr} = {};  # Destination of FITS header
   $$foo{Hdr}{"BSCALE"}=1;
   $$foo{Hdr}{"BZERO"}=0;

   while( !eof(FITS)) {
      read(FITS,$line,80);
      croak "file $file is not in FITS-format:\n$line\n"
                  if( $nbytes==0 && ($line !~ /^SIMPLE  = +T/));
      $nbytes += 80;

      $name = (split(' ',substr($line,0,8)))[0]; $rest=substr($line,8);
      $$foo{Hdr}{$name} = "";
      $$foo{Hdr}{$name}=$1 if $rest =~ m|^= +(.*\S) *$| ;
      $$foo{Hdr}{$name}=$1 if $rest =~ m|^= +(.*\S) +/.*$| ;
      $$foo{Hdr}{$name}=$1 if $rest =~ m|^= '(.*)' *$| ;
      $$foo{Hdr}{$name}=$1 if $rest =~ m|^= '(.*)' +/.*$| ;
      last if $name eq "END";
   }


   my @dims; # Store the dimenions 1..N, compute total number of pixels
   $size = 1;  $i=1;
   while(defined( $$foo{Hdr}{"NAXIS$i"} )) {
     $size = $size*$$foo{Hdr}{"NAXIS$i"}; 
     push @dims, $$foo{Hdr}{"NAXIS$i"} ; $i++;
   }
   $pdl->setdims([@dims]);

   $nbytes %= 2880;

   my $dref = $pdl->get_dataref();

   read(FITS,$$dref,2880-$nbytes) if $nbytes!=0;  # Skip to end of card

   $pdl->set_datatype($PDL_B)    if $$foo{Hdr}{"BITPIX"} ==   8;
   $pdl->set_datatype($PDL_S)    if $$foo{Hdr}{"BITPIX"} ==  16;
   $pdl->set_datatype($PDL_L)    if $$foo{Hdr}{"BITPIX"} ==  32;
   $pdl->set_datatype($PDL_F)    if $$foo{Hdr}{"BITPIX"} == -32;
   $pdl->set_datatype($PDL_D)    if $$foo{Hdr}{"BITPIX"} == -64;

   print "BITPIX = ",$$foo{Hdr}{"BITPIX"}," size = $size pixels \n" 
         if $PDL::verbose;

   # Slurp the FITS binary data

   print "Reading ",$size*howbig($pdl->get_datatype) , "bytes\n" if $PDL::verbose;

   read( FITS, $$dref, $size*howbig($pdl->get_datatype) );

   close(FITS);

   if (!isbigendian() ) { # Need to byte swap on little endian machines
      bswap2($pdl) if $pdl->get_datatype == $PDL_S;
      bswap4($pdl) if $pdl->get_datatype == $PDL_L || $pdl->get_datatype == $PDL_F;
      bswap8($pdl) if $pdl->get_datatype == $PDL_D;
   }

   $bscale = $$foo{Hdr}{"BSCALE"}; $bzero = $$foo{Hdr}{"BZERO"};
   print "BSCALE = $bscale &&  BZERO = $bzero\n" if $PDL::verbose;
   $pdl = $pdl*$bscale + $bzero if $bzero ne "" && $bscale ne "" 
                                && $bzero != 0 && $bscale != 1;
   return $pdl;
}

sub wfits { # Write a PDL to a FITS format file 

   croak 'Usage: wfits($pdl,$file)' if $#_!=1;

   my ($pdl,$file) = @_; 
   my ($k, $buff, $off, $ndims, $sz);
   local($nbytes, %hdr);

   open(FITS, ">$file") || croak "Unable to create FITS file $file\n";
   printf FITS "%-80s", "SIMPLE  =                    T ";

   $nbytes = 80; # Number of bytes written so far

   # Write FITS header

   # ***CROCK*** header N/A yet

   #%hdr = %{$$pdl{Hdr}};  # Header copy
   #delete $hdr{SIMPLE}; delete $hdr{END}; 

   %hdr = ();
   $hdr{BITPIX} =   8 if $pdl->get_datatype == $PDL_B;
   $hdr{BITPIX} =  16 if $pdl->get_datatype == $PDL_S || $pdl->get_datatype == $PDL_US;
   $hdr{BITPIX} =  32 if $pdl->get_datatype == $PDL_L;
   $hdr{BITPIX} = -32 if $pdl->get_datatype == $PDL_F;
   $hdr{BITPIX} = -64 if $pdl->get_datatype == $PDL_D;
   wheader('BITPIX');
   
   $ndims = $pdl->getndims; # Dimensions of data array
   $hdr{NAXIS}  = $ndims;
   wheader('NAXIS');
   for $k (1..$ndims) { $hdr{"NAXIS$k"} = $pdl->getdim($k-1) }
   for $k (1..$ndims) { wheader("NAXIS$k") }
   for $k (sort keys %hdr) { wheader($k) }

   printf FITS "%-80s", "END"; $nbytes += 80;
   $nbytes %= 2880;
   print FITS " "x(2880-$nbytes) if $nbytes != 0; # Fill up HDU

   # Decide how to byte swap - note does not quite work yet. Needs hack
   # to IO.xs 

   my $bswap = sub {};     # Null routine
   if ( !isbigendian() ) { # Need to set a byte swap routine
      $bswap = \&bswap2 if $pdl->get_datatype == $PDL_S || $pdl->get_datatype == $PDL_US;
      $bswap = \&bswap4 if $pdl->get_datatype == $PDL_L || $pdl->get_datatype == $PDL_F;
      $bswap = \&bswap8 if $pdl->get_datatype == $PDL_D;
   }

   # Write FITS data 

   my $p1d = $pdl->clump(-1); # Data as 1D stream

   $off = 0;
   $sz  = howbig($pdl->get_datatype);
   $nbytes = $p1d->getdim(0) * $sz;

   while ($nbytes - $off > 2880) {
      $buff = $p1d->slice($off.":".($off+2880/$sz))->copy;
      &$bswap($buff); print  FITS ${$buff->get_dataref};
      $off += 2880;
   }
   $buff = $p1d->slice("$off:-1")->copy; 
   &$bswap($buff); print  FITS ${$buff->get_dataref};
   print FITS " "x(2880 - $buff->getdim(0) * $sz);  # Fill HDU

   close(FITS);

1;}

sub wheader {     # Local utility routine of wfits()
   my $k = shift;
   if ($hdr{$k} eq "") {
      printf FITS "%-80s", substr($k,0,8);
   }
   else{
      printf FITS "%-8s= ", substr($k,0,8);
      if ($hdr{$k} =~ /^ *([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))? *$/) { # Number?
         printf FITS "%-70s", substr($hdr{$k},0,70);
      }
     else {
         printf FITS "%-70s", "'".substr($hdr{$k},0,68)."'";
      }
   }
   $nbytes += 80; delete $hdr{$k};
1;}

# ***CROCK*** Internal routine to extend 1D PDL array by size $n - dirty hack
# - needs a proper extend function rather than this nasty recreation

sub ext1D { 
   my ($a,$n) = @_;
   my $b = zeroes($a->getdim(0)+$n);  # New pdl
   my $bb = $b->slice("0:".($a->getdim(0)-1));
   $bb .= $a;
   $_[0] = $b;
1;}

# Read ASCII cols from file into PDL variables efficiently
# If no columns are specified all are assumed
# Will optionally only process lines matching a pattern.
# Can take file name or *HANDLE

$colsep = " "; # Default column seperator

sub rcols { 
   croak 'Usage ($x,$y,...) = rcols(*HANDLE|"filename", ["/pattern/",$col1, $col2,] ...)' if $#_<0;

   my $is_handle = ref(\$_[0]) eq "GLOB";
   my $fh = $is_handle ? $_[0] : "FILE";
   open $fh, $_[0] or die "File $_[0] not found\n" unless $is_handle;
   shift;

   my $pattern="";
   if (defined($_[0]) && $_[0] =~ m|^/.*/$|) { # Is a pattern
      $pattern = shift;
      substr($pattern,0,1)=""; substr($pattern,-1,1)="";  # Removes //s
   }

   my @cols = @_;  
   my (@ret,@v,$k); my ($m,$n)=(-1,0); # Count/PDL size

   while(<$fh>) { 

      if ($pattern eq "") {
           next if /^#/;    # Only skip comments
      }
      else{
           next unless /$pattern/; 
      }

      @v = $colsep eq ' ' ? split(' ') : split($colsep) ; $m++;  # Count got
      if ($m==0) { 
          @cols = (0..$#v) if $#cols<0; # Use number of cols in first line
          for (0..$#cols) {
              $ret[$_] = double(pdl([0])); # Create PDLs
          }
      }
      if ($n<$m) {
          for (0..$#cols) {
              ext1D( $ret[$_], 10000 ) # Extend PDL in buffered manner
          }
          $n += 10000;
      }
      $k=0; for(@cols) { set $ret[$k++], $m, 1*$v[$_] } # Set values - '1*' is 
   }                                                    # split() bug workaround

   close($fh) unless $is_handle;
   for (@ret) { $_ = $_->slice("0:$m")->copy; }; # Truncate
   wantarray ? return(@ret) : return $ret[0];
}

# Like rcols but with pattern matching
#
# e.g.:
#
# ($a,$b) = rgrep $file, '/Foo (.*) Bar (.*) Mumble/';
#
# i.e. - The vectors $a and $b get the progressive values of $1, $2 etc.

sub rgrep  { 
   croak 'Usage ($x,$y,...) = rgrep(*HANDLE|"filename", "/pattern/")' if $#_!=1;

   my $is_handle = ref(\$_[0]) eq "GLOB";
   my $fh = $is_handle ? $_[0] : "FILE";
   open $fh, $_[0] or die "File $_[0] not found\n" unless $is_handle;
   shift;

   my $pattern = shift; 
   die "Not a pattern\n" unless $pattern =~ m|^/.*/$|; # Looks like /stuff/
   substr($pattern,0,1)=""; substr($pattern,-1,1)="";  # Removes //s

   my (@ret,@v,$k,$nret); my ($m,$n)=(-1,0); # Count/PDL size

   while(<$fh>) { 
      next unless /$pattern/; 
      $k=1; @v=();
      while(defined $$k) { # Loop over $1, $2, ...
         push @v, $$k; $k++;
      }
         
      $m++;  # Count got
      if ($m==0) { 
          $nret = $k-2;   # Last index of values to return
          for (0..$nret) {
              $ret[$_] = double(pdl([0])); # Create PDLs
          }
      }
      if ($n<$m) {
          for (0..$nret) {
              ext1D( $ret[$_], 10000 ); # Extend PDL in buffered manner
          }
          $n += 10000;
      }
      $k=0; for(0..$nret) { set $ret[$k++], $m, 1*$v[$_] } # Set values - '1*' is 
   }                                                      # ensures numeric
   close($fh) unless $is_handle;
   for (@ret) { $_ = $_->slice("0:$m")->copy; }; # Truncate
   wantarray ? return(@ret) : return $ret[0];
}

# Read a FIGARO/NDF file using Frossie's DSA module (UNTESTED!!!!)

sub rdsa {
    croak 'Usage: ([$xaxis],$data) = rdsa($file)' if $#_!=0;
    my $file = shift; my $pdl = pdl(); my $xpdl;
    eval 'use DSA' unless $dsa_loaded++;
    croak 'Cannot use DSA library' if $@ ne "";

    $status = 0;

    # Most of this stuff stolen from Frossie:

    dsa_open($status);
    dsa_named_input('IMAGE',$file,$status);
    goto skip if $status != 0;

    dsa_get_range('IMAGE',$vmin,$vmax,$status);
    dsa_data_size('IMAGE',5, $data_ndims, \@data_dims, $data_elements, $status);
    dsa_map_data('IMAGE','READ','FLOAT',$data_address,$data_slot,$status);
   
    @data_dims = @data_dims[0..$data_ndims-1];
    print "Dims of $file = @data_dims\n" if $PDL::verbose;
    $pdl->set_datatype($PDL_F);
    $pdl->setdims([@data_dims]); 
    my $dref = $pdl->get_dataref;
    mem2string($data_address,4*$data_elements,$$dref);

    if (wantarray) { # Map X axis values
      dsa_axis_size('IMAGE',1,5, $axis_ndims, \@axis_dims, 
                    $axis_elements, $status);
      dsa_map_axis_data('IMAGE',1,'READ','FLOAT',$axis_address,
                    $axis_slot,$status);
      @axis_dims = @axis_dims[0..$axis_ndims-1];
      $xpdl = pdl();
      $xpdl->set_datatype($PDL_F);
      $xpdl->setdims([@axis_dims]); 
      my $xref = $xpdl->get_dataref;
      mem2string($axis_address,4*$axis_elements,$$xref);
    }

    skip: dsa_close($status);

    croak("rdsa: obtained DSA error") if $status != 0;
  
    return ($xpdl,$pdl);
}


################################ XS CODE ######################################
EOD

sub defpdl {
	pp_def(
		$_[0],
		Pars => $_[1],
		OtherPars => $_[2],
		Code => $_[3]
	);
}

pp_addxs('','

# Determine endianness of machine

int
isbigendian()
   CODE:
     unsigned short i;
     PDL_Byte *b;

     i = 42; b = (PDL_Byte*) (void*) &i;
  
     if (*b == 42) 
        RETVAL = 0;
     else if (*(b+1) == 42) 
        RETVAL = 1;
     else
         croak("Impossible - machine is neither big nor little endian!!\n");
     OUTPUT:
       RETVAL
');

# Byte swap pairs

defpdl(
	'bswap2',
	'[o]x(); ',
	'',
	'
      int i;
      PDL_Short *aa; PDL_Short bb;
      PDL_Byte *a,*b;

      int n = sizeof($x()) / sizeof(PDL_Short);
      aa = (PDL_Short*) &$x();

      for(i=0;i<n; i++) {
         bb = aa[i]; a = (PDL_Byte*) (void*) (aa+i);  
         b = (PDL_Byte*) &bb;
         *a = *(b+1);  *(a+1) = *b; 
     }'
);

# Byte swap quads

defpdl(
	'bswap4',
	'[o]x(); ',
	'',
	'
      int i;
      PDL_Long *aa; PDL_Long bb;
      PDL_Byte *a,*b;

      int n = sizeof($x()) / sizeof(PDL_Long);
      aa = (PDL_Long*) &$x();

      for(i=0;i<n; i++) {
         bb = aa[i]; a = (PDL_Byte*) (void*) (aa+i);  
         b = (PDL_Byte*) &bb;
         *a = *(b+3);  *(a+1) = *(b+2);  *(a+2) = *(b+1); *(a+3) = *b; 
     }'
);

# Byte swap octets

defpdl(
	'bswap8',
	'[o]x(); ',
	'',
	'
      int i;
      PDL_Double *aa; PDL_Double bb;
      PDL_Byte *a,*b;

      int n = sizeof($x()) / sizeof(PDL_Double);
      aa = (PDL_Double*) &$x();

      for(i=0;i<n; i++) {
         bb = aa[i]; a = (PDL_Byte*) (void*) (aa+i);  
         b = (PDL_Byte*) &bb;
         *a     = *(b+7);  *(a+1) = *(b+6);  *(a+2) = *(b+5); *(a+3) = *(b+4); 
         *(a+4) = *(b+3);  *(a+5) = *(b+2);  *(a+6) = *(b+1); *(a+7) = *b; 
     }'
);

pp_done();


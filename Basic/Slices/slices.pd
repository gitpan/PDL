=head1 NAME

PDL::Slice -- Stupid index tricks

=head1 DESCRIPTION

This package provides many of the powerful PerlDL core index
manipulation routines. These routines are usually two-way
so you can get a unit matrix by

	$a = zeroes(1000,1000);
	$a->diagonal() ++;

which is usually fairly efficient. See L<XXX> for more examples.

These functions are usually two-way:

	$b = $a->slice("1:3");
	$b += 5;   		# $a is changed!

If you want to force a copy and no "flow" backwards, you need

	$b = $a->slice("1:3")->copy;
	$b += 5;		# $a is not changed.

The fact that there is this kind of flow makes PDL a very
powerful language in many ways: since you can alter the original
data by altering some easier-to-use representation of it, many things are 
much easier to accomplish.

=head1 FUNCTIONS

=over 8

=cut

# $::PP_VERBOSE=1;

pp_add_boot("  PDL->readdata_affine = pdl_readdata_affineinternal;
	      PDL->writebackdata_affine = pdl_writebackdata_affineinternal;
");

pp_def(
	'affineinternal',
	AffinePriv => 1,
	DefaultFlow => 1,
	P2Child => 1,
	ReadDataFuncName => "pdl_readdata_affineinternal",
	WriteBackDataFuncName => "pdl_writebackdata_affineinternal",
	MakeComp => '$CROAK("AFMC MUSTNT BE CALLED");',
	RedoDims => '$CROAK("AFRD MUSTNT BE CALLED");',
	EquivCPOffsCode => '
		int i; int poffs=$PRIV(offs); int nd;
		for(i=0; i<$CHILD_P(nvals); i++) {
			$EQUIVCPOFFS(i,poffs);
			for(nd=0; nd<$CHILD_P(ndims); nd++) {
				poffs += $PRIV(incs[nd]);
				if(nd<$CHILD_P(ndims)-1 &&
				   (i+1)%$CHILD_P(dimincs[nd+1]) ||
				   nd == $CHILD_P(ndims)-1) 
					break;
				poffs -= $PRIV(incs[nd]) *
					$CHILD_P(dims[nd]);
			}
		}
	',
#	Dump => 1,
);

pp_def(
	'identity',
	P2Child => 1,
	DefaultFlow => 1,
	OtherPars => '',
	Reversible => 1,
	Dims => '$COPYDIMS();',
	ParentInds => '$COPYINDS();',
	Identity => 1,
);

pp_def(
	'converttypei',
	DefaultFlow => 1,
	GlobalNew => 'converttypei_new',
	OtherPars => 'int totype;',
	P2Child => 1,
	Identity => 1,
	Reversible => 1,
# Forced types
	FTypes => {CHILD => '$COMP(totype)'},
);

=item clump(a,n)

Clump "clumps" the first n dimensions into one large dimension so
that if $a has dimensions (5,3,4) then after

	$b = $a->clump(2);   # Clump 2 first dimensions

the element $b->at(7,3) refers to the element $a->at(1,2,3).

=cut

# XXX Make clump work with optional parameter!
if(0) {
# Special-case
pp_def(
	'clump',
	DefaultFlow => 1,
	OtherPars => 'int n',
	P2Child => 1,
	Priv => 'int nnew; int nrem;',
	RedoDims => 'int i; int d1;
		if($COMP(n) > $PARENT(ndims)) {
			$CROAK("Too many dimensions %d to clump from %d",
				$COMP(n),$PARENT(ndims));
		}
		 $COMP(nrem) = ($COMP(n)==-1 ? $PARENT(threadids[0]) : $COMP(n));
		 $PRIV(nnew) = $PARENT(ndims) - $COMP(nrem) + 1;
		 $SETNDIMS($PRIV(nnew));
		 d1=1;
		 for(i=0; i<$PRIV(nrem); i++) {
		 	d1 *= $PARENT(dims[i]);
		 }
		 $CHILD(dims[0]) = d1;
		 for(; i<$PARENT(ndims); i++) {
		 	$CHILD(dims[i-$PRIV(nrem)+1]) = $PARENT(dims[i]);
		 }
		 $SETDIMS();
		 $SETDELTATHREADIDS(1-$COMP(nrem));
		 ',
	EquivCPOffsCode => '
		int i;
		for(i=0; i<$CHILD_P(nvals); i++) {
			$EQUIVCPOFFS(i,i);
		}
		',
	Reversible => 1
);
} else {

# Affine! Make sure vaffine chaining understands to stop in the right
# place.
pp_def(
	'clump',
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	OtherPars => 'int n',
	RedoDims => 'int i; int d1;
		int nrem; int nnew;
		if($COMP(n) > $PARENT(ndims)) {
			$CROAK("Too many dimensions %d to clump from %d",
				$COMP(n),$PARENT(ndims));
		}
		 nrem = ($COMP(n)==-1 ? $PARENT(threadids[0]) : $COMP(n));
		 nnew = $PARENT(ndims) - nrem + 1;
		 $SETNDIMS(nnew);
		 $DOPRIVDIMS();
		 $PRIV(offs) = 0;
		 d1=1;
		 for(i=0; i<nrem; i++) {
		 	d1 *= $PARENT(dims[i]);
		 }
		 $CHILD(dims[0]) = d1;
		 $PRIV(incs[0]) = 1;
		 for(; i<$PARENT(ndims); i++) {
		 	$CHILD(dims[i-nrem+1]) = $PARENT(dims[i]);
			$PRIV(incs[i-nrem+1]) = $PARENT(dimincs[i]);
		 }
		 $SETDIMS();
		 $SETDELTATHREADIDS(1-nrem);
		 ',
);
}

=item xchg(a,b)

C<$a-E<gt>xchg(2,3)> exchanges the dimensions 2 and 3 with each other.

=cut

pp_def(
	'xchg',
	OtherPars => 'int n1; int n2;',
	DefaultFlow => 1,
	Reversible => 1,
	P2Child => 1,
	XCHGOnly => 1,
	EquivDimCheck => 'if($COMP(n1) >= $PARENT(threadids[0]) || 
			     $COMP(n2) >= $PARENT(threadids[0]))
		croak("One of params %d, %d too large: %d",
			$COMP(n1),$COMP(n2),$PARENT(threadids[0]));',
	EquivPDimExpr => '(($CDIM == $COMP(n1)) ? $COMP(n2) : ($CDIM == $COMP(n2)) ? $COMP(n1) : $CDIM)',
	EquivCDimExpr => '(($PDIM == $COMP(n1)) ? $COMP(n2) : ($PDIM == $COMP(n2)) ? $COMP(n1) : $PDIM)',
);

=item mv(a,b)

C<$a-E<gt>mv(0,3)> moves dimensions # 0 of the parent to position 3 in the
newly created child. So if $a has dimensions (5,6,7,8,9,10)
then after 

	$b = $a->mv(0,3);

the piddle $b has dimensions (8,5,6,7,9,10).

=cut

pp_def(
	'mv',
	OtherPars => 'int n1; int n2;',
	DefaultFlow => 1,
	Reversible => 1,
	P2Child => 1,
	XCHGOnly => 1,
	EquivDimCheck => 'if($COMP(n1) >= $PARENT(ndims) || 
			     $COMP(n2) >= $PARENT(ndims))
		croak("One of params %d, %d too large: %d",
			$COMP(n1),$COMP(n2),$PARENT(ndims));',
	EquivPDimExpr => '(($COMP(n1) < $COMP(n2)) ?
	(($CDIM < $COMP(n1) || $CDIM > $COMP(n2)) ?
		$CDIM : (($CDIM == $COMP(n2)) ? $COMP(n1) : $CDIM+1))
	: (($COMP(n2) < $COMP(n1)) ?
		(($CDIM > $COMP(n1) || $CDIM < $COMP(n2)) ?
			$CDIM : (($CDIM == $COMP(n2)) ? $COMP(n1) : $CDIM-1))
		: $CDIM))',
	EquivCDimExpr => '(($COMP(n2) < $COMP(n1)) ?
	(($PDIM < $COMP(n2) || $PDIM > $COMP(n1)) ?
		$PDIM : (($PDIM == $COMP(n1)) ? $COMP(n2) : $PDIM+1))
	: (($COMP(n1) < $COMP(n2)) ?
		(($PDIM > $COMP(n2) || $PDIM < $COMP(n1)) ?
			$PDIM : (($PDIM == $COMP(n1)) ? $COMP(n2) : $PDIM-1))
		: $PDIM))'
);

=item slice('...')

Slice gives you a rectangular slice of the original piddle. 
For example, $a->slice('1:3') gives you the second to fourth elements
of a vector. 

The argument string is a comma-separated list of what to do 
for each dimension. The current formats include 
the following (a,b and c are integers):

":" takes the whole dimension intact.

"" (nothing) is a synonym for ":"
(This means that C<$a-E<gt>slice(':,3')> is equal to $a-E<gt>slice(',3')).

"a" slices only this value out of the corresponding dimension

"(a)" means the same as "a" by itself except that the resulting 
dimension of length
one is deleted (so if $a has dims (3,4,5) then C<$a-E<gt>slice(':,(2),:')>
has dimensions (3,5) whereas $a-E<gt>slice(':,2,:') has dimensions
(3,1,5)).

"a:b" slices the range I<a> to I<b> inclusive out of the dimension

"a:b:c" slices the range I<a> to I<b>, with step c (i.e. 3:7:2 gives the indices
(3,5,7)). This may be confusing to Matlab users but several other
packages already use this syntax.

"*" inserts an extra dimension of width 1 and
"*a" inserts an extra (dummy) dimension of width I<a>.

An extension is planned for a later stage allowing
$a->slice('(=1),(=1|5:8),3:6(=1),4:6') to express a multidimensional
diagonal of $a.

=cut


pp_def(
	'slice',
	P2Child => 1,
	DefaultFlow => 1,
	OtherPars => 'char* str',
	Comp => 'int nnew; int nthintact; int intactnew; int ndum;
	         int corresp[$COMP(intactnew)]; int start[$COMP(intactnew)];
		 int inc[$COMP(intactnew)]; int end[$COMP(intactnew)]; 
		 int nolddims; 
		 int whichold[$COMP(nolddims)]; int oldind[$COMP(nolddims)];
		 ',
	AffinePriv => 1,
	MakeComp => q~
		int i;
		int nthnew; int nthold; int nthreal;
		int dumsize;
		char *s; char *ns;
		int nums[3]; int nthnum;
		$COMP(nnew)=0;
		$COMP(ndum)=0;
		$COMP(nolddims) = 0;
		if(str[0] == '(') 
			$COMP(nolddims)++;
		else if (str[0] == '*')
			$COMP(ndum)++;
		else
			$COMP(nnew)++;
		for(i=0; str[i]; i++)
			if(str[i] == ',') {
				if(str[i+1] == '(') 
					$COMP(nolddims)++;
				else if(str[i+1] == '*')
					$COMP(ndum)++;
				else
					$COMP(nnew)++;
			}
		$COMP(nthintact) = $COMP(nolddims) + $COMP(nnew);
		$COMP(intactnew) = $COMP(nnew)+$COMP(ndum);
		$DOCOMPDIMS();
		nthnew=0; nthold=0; i=0; nthreal=0;
		s=str-1;
		do {
			s++;
			if(isdigit(*s) || *s == '-') {
				nthnew++; nthreal++;
				$COMP(inc[nthnew-1]) = 1;
				$COMP(corresp[nthnew-1]) = nthreal-1;
				$COMP(start[nthnew-1]) = strtol(s,&s,10);
				if(*s != ':') {
					$COMP(end[nthnew-1]) = 
						$COMP(start[nthnew-1]);
					goto outlab;
				}
				s++;
				if(!isdigit(*s) && !(*s == '-')) {
					croak("Invalid slice str ind1 '%s': '%s'",str,s);
				}
				$COMP(end[nthnew-1]) = strtol(s,&s,10);
				if(*s != ':') {goto outlab;}
				s++;
				if(!isdigit(*s) && !(*s == '-')) {
					croak("Invalid slice str ind2 '%s': '%s'",str,s);
				}
				$COMP(inc[nthnew-1]) = strtol(s,&s,10);
			} else switch(*s) {
			case ':':
				s++;
				/* FALLTHRU */
			case ',': case '\0':  /* In these cases, no inc s */
				$COMP(start[nthnew]) = 0;
				$COMP(end[nthnew]) = -1;
				$COMP(inc[nthnew]) = 1;
				$COMP(corresp[nthnew]) = nthreal;
				nthnew++; nthreal++;
				break;
			case '(':
				s++;
				$COMP(oldind[nthold]) = strtol(s,&s,10);
				$COMP(whichold[nthold]) = nthreal;
				nthold++; nthreal++;
				if(*s != ')') {
					croak("Sliceoblit must end with ')': '%s': '%s'",str,s);
				}
				s++;
				break;
			case '*':
				s++;
				if(isdigit(*s)) {
					dumsize = strtol(s,&s,10);
				} else {dumsize = 1;}
				$COMP(corresp[nthnew]) = -1;
				$COMP(start[nthnew]) = 0;
				$COMP(end[nthnew]) = dumsize-1;
				$COMP(inc[nthnew]) = 1;
				nthnew++;
				break;
			}
		   outlab:
			if(*s != ',' && *s != '\0') {
				croak("Invalid slice str '%s': '%s'",str,s);
			}
		} while(*s);
		$SETREVERSIBLE(1); /* XXX Only if incs>0, no dummies */
		~,
	RedoDims => '
		int i; int start; int end; int inc;
		if ($COMP(nthintact) > $PARENT(ndims))
			croak("Too many dims in slice");
		$SETNDIMS($PARENT(ndims)-$COMP(nthintact)+$COMP(intactnew));
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		for(i=0; i<$COMP(intactnew); i++) {
			int parentdim = $COMP(corresp[i]);
			start = $COMP(start[i]); end = $COMP(end[i]);
			inc = $COMP(inc[i]);
			if(parentdim!=-1) {
				if(start < 0) 
					start = $PARENT(dims[parentdim]) + start;
				if(end < 0) 
					end = $PARENT(dims[parentdim]) + end;
				if(start >= $PARENT(dims[parentdim]) ||
				   end >= $PARENT(dims[parentdim])) {
					croak("Slice cannot start or end above limit");
				}
				if((end-start)*inc < 0)
					inc = -inc;
				$PRIV(incs[i]) = $PARENT(dimincs[parentdim]) * inc;
				$PRIV(offs) += start * $PARENT(dimincs[parentdim]);
			} else {
				$PRIV(incs[i]) = 0;
			}
			$CHILD(dims[i]) = ((int)((end-start)/inc))+1;
		}
		for(i=$COMP(nthintact); i<$PARENT(ndims); i++) {
			int cdim = i - $COMP(nthintact) + $COMP(intactnew);
			$PRIV(incs[cdim]) = $PARENT(dimincs[i]);
			$CHILD(dims[cdim]) = $PARENT(dims[i]);
		}
		for(i=0; i<$COMP(nolddims); i++) {
			int oi = $COMP(oldind[i]);
			int wo = $COMP(whichold[i]);
			if(oi < 0) 
				oi += $PARENT(dims[wo]);
			if( oi >= $PARENT(dims[wo]) )
				$CROAK("Cannot obliterate dimension after end");
			$PRIV(offs) += $PARENT(dimincs[wo])
					* oi;
		}
	/*
		for(i=0; i<$CHILD(ndims)-$PRIV(nnew); i++) {
			$CHILD(dims[i+$COMP(intactnew)]) = 
				$PARENT(dims[i+$COMP(nthintact)]);
			$PRIV(incs[i+$COMP(intactnew)]) = 
				$PARENT(dimincs[i+$COMP(nthintact)]);
		}
	*/
		$SETDIMS();
	',
);

=item diagonal(a,....)

Returns the multidimensional diagonal of I<a> over the specified
dimensions.
The diagonal is placed at the first (by number) dimension that is 
diagonalized.
The other diagonalized dimensions are removed. So if $a has dimensions 
(5,3,5,4,6,5) then after

	$b = $a->diagonal(0,2,5);

the piddle $b has dimensions (5,3,4,6) and $b->at(2,1,0,1) refers
to $a->at(2,1,2,0,1,2).

NOTE: diagonal doesn't handle threadids correctly. XXX FIX

=cut

pp_addhdr(<<END
static int cmp_pdll(const void *a_,const void *b_) {
	PDL_Long *a = (PDL_Long *)a_; PDL_Long *b=(PDL_Long *)b_;
	if(*a>*b) return 1; 
	else if(*a==*b) return 0;
	else return -1;
}
END
);
	

pp_def(
	'diagonalI',
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	OtherPars => 'SV *list',
	Comp => 'int nwhichdims; PDL_Long whichdims[$COMP(nwhichdims)];',
	MakeComp => '
		int i,j;
		PDL_Long *tmp= PDL->packdims(list,&($COMP(nwhichdims)));
		if($COMP(nwhichdims) < 1) {
			$CROAK("Diagonal: must have at least 1 dimension");
		}
		$DOCOMPDIMS();
		for(i=0; i<$COMP(nwhichdims); i++) 
			$COMP(whichdims)[i] = tmp[i];
		qsort($COMP(whichdims), $COMP(nwhichdims), sizeof(PDL_Long),
			cmp_pdll);
	',
	RedoDims => '
		int nthr,nthc,nthd; int cd = $COMP(whichdims[0]);
		$SETNDIMS($PARENT(ndims)-$COMP(nwhichdims)+1);
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		nthr=0; nthd=0;
		for(nthc=0; nthc<=$CHILD(ndims); nthc++) {
			if(nthd < $COMP(nwhichdims) &&
			   nthr == $COMP(whichdims)[nthd]) {
				if(nthd != 0) {
					if($CHILD(dims)[cd] != 
					    $PARENT(dims)[nthr]) {
					    	$CROAK("Different dims %d and %d",
							$CHILD(dims)[cd],
							$PARENT(dims)[nthr]);
					}
					$PRIV(incs)[cd] +=
					   $PARENT(dimincs)[nthr];
					nthr++;
				}
				nthd++;
			}
			if(nthc == $CHILD(ndims)) break;
			$CHILD(dims)[nthc] = $PARENT(dims)[nthr];
			$PRIV(incs)[nthc] = $PARENT(dimincs)[nthr];
			nthr++;
		}
		$SETDIMS();
	'
);

=item thread(a,ids)

See L<XXX> for explanation of what this function does.

=cut

# This is a bit tricky. Hope I haven't missed any cases.

pp_def(
	'threadI',
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	OtherPars => 'int id; SV *list',
	Comp => 'int id; int nwhichdims; PDL_Long whichdims[$COMP(nwhichdims)];
			int nrealwhichdims; ',
	MakeComp => '
		int i,j;
		PDL_Long *tmp= PDL->packdims(list,&($COMP(nwhichdims)));
		$DOCOMPDIMS();
		for(i=0; i<$COMP(nwhichdims); i++) 
			$COMP(whichdims)[i] = tmp[i];
		$COMP(nrealwhichdims) = 0;
		for(i=0; i<$COMP(nwhichdims); i++) {
			for(j=i+1; j<$COMP(nwhichdims); j++) 
				if($COMP(whichdims[i]) == $COMP(whichdims[j]) &&
				   $COMP(whichdims[i]) != -1) {
				$CROAK("Thread: duplicate arg %d %d %d",
					i,j,$COMP(whichdims[i]));
			}
			if($COMP(whichdims)[i] != -1) {
				$COMP(nrealwhichdims) ++;
			}
		}
		$COMP(id) = id;
		',
	RedoDims => '
		int nthc,i,j,flag;
		$SETNDIMS($PARENT(ndims));
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		nthc=0;
		for(i=0; i<$PARENT(ndims); i++) {
			flag=0;
			if($PARENT(nthreadids) > $COMP(id) &&
			   i == $PARENT(threadids[$COMP(id)])) {
			   nthc += $COMP(nwhichdims);
			}
			for(j=0; j<$COMP(nwhichdims); j++) {
				if($COMP(whichdims[j] == i)) {flag=1; break;}
			}
			if(flag) {
				continue;
			} 
			$CHILD(dims[nthc]) = $PARENT(dims[i]);
			$PRIV(incs[nthc]) = $PARENT(dimincs[i]);
			nthc++;
		}
		for(i=0; i<$COMP(nwhichdims); i++) {
			int cdim,pdim;
			cdim = i + 
			 ($PARENT(nthreadids) > $COMP(id) ? 
			  $PARENT(threadids[$COMP(id)]) : $PARENT(ndims))
			  - $COMP(nrealwhichdims);
			pdim = $COMP(whichdims[i]);
			if(pdim == -1) {
				$CHILD(dims[cdim]) = 1;
				$PRIV(incs[cdim]) = 0;
			} else {
				$CHILD(dims[cdim]) = $PARENT(dims[pdim]);
				$PRIV(incs[cdim]) = $PARENT(dimincs[pdim]);
			}
		}
		$SETDIMS();
		PDL->reallocthreadids($CHILD_PTR(),
			($PARENT(nthreadids)<=$COMP(id) ? 
				$COMP(id)+1 : $PARENT(nthreadids)));
		for(i=0; i<$CHILD(nthreadids); i++) {
			$CHILD(threadids[i]) = 
			 ($PARENT(nthreadids) > i ? 
			  $PARENT(threadids[i]) : $PARENT(ndims)) +
			 (i <= $COMP(id) ? - $COMP(nrealwhichdims) : 
			  $COMP(nwhichdims) - $COMP(nrealwhichdims));
		}
		$CHILD(threadids[$CHILD(nthreadids)]) = $CHILD(ndims);
		',
);

=item unthread(a)

All threaded dimensions are made real. See L<XXX> for details
and examples.

=cut

pp_def(
	'unthread',
	P2Child => 1,
	DefaultFlow => 1,
	Reversible => 1,
	AffinePriv => 1,
	OtherPars => 'int atind;',
	RedoDims => '
		int i;
		$SETNDIMS($PARENT(ndims));
		$DOPRIVDIMS();
		$PRIV(offs) = 0;
		for(i=0; i<$PARENT(ndims); i++) {
			int corc;
			if(i<$COMP(atind)) {
				corc = i;
			} else if(i < $PARENT(threadids[0])) {
				corc = i + $PARENT(ndims)-$PARENT(threadids[0]);
			} else {
				corc = i - $PARENT(threadids[0]) + $COMP(atind);
			}
			$CHILD(dims[corc]) = $PARENT(dims[i]);
			$PRIV(incs[corc]) = $PARENT(dimincs[i]);
		}
		$SETDIMS();
	',
);

pp_done();

=head1 AUTHOR

Copyright (C) 1997 Tuomas J. Lukka. Redistribution in book form forbidden.

=cut

__DATA__

# A very useful transformation for e.g. axis values: hexagonal
# arrays can be made like this.

if(0) {
deftrans(
	Name => 'repeat',
	Pars => 'int whichind, int howmany',
	MakeComp => '
		$COMP(howmany) = howmany;
		$COMP(whichind) = whichind;
		$SETREVERSIBLE($COMP(howmany)==1);
		',
	Dims => '
		$SETNDIMS($PARENT(ndims));
		LOOPDIMS %{
			$CHILD(dims[$DIM]) = $PARENT(dims[$DIM]);
		%}
		$CHILD(dims[$COMP(whichind)]) *= $PRIV(howmany);
		$SETDIMS();
		',
	ParentInds => 
		'$COPYINDS();
		 $PARENTINDS($COMP(whichind)) %= $PARENT(dims[$PRIV(whichind)]);',
	Print => 'printf("REPEAT: %d, %d\n",
			$COMP(whichind), $COMP(howmany));'
);
}

# Parent's first index is value of indices.

if(0) {
deftrans(
	Name => 'indexed',
	Pars => 'pdl* indices',
	Dims => '
		$SETNDIMS($COMP(indices)->ndims);
		LOOPDIMS %{
			$CHILD(dims[$DIM]) = $COMP(indices)->dims[$DIM];
		%}
		',
	ParentInds => 
		'$COPYINDS();
		 $PARENTINDS(0) = PDL->get($COMP(indices),&($MYINDS(0)));'
);
}



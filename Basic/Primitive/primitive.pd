
sub defpdl {
	my %hash = (Pars => $_[1],
		    OtherPars => $_[2],
		    Code => $_[3]);
	$hash{Doc} = $_[4] if $#_>3;

	pp_def($_[0],%hash);
}

pp_addhdr(<<'EOD');
#define IsNaN(x) (x != x)

#ifndef RAND_MAX
#error "You must have a working RAND_MAX! Something's wrong with your include files"
#endif

EOD

pp_addpm({At=>Top},<<'EOD');

use PDL::Slices;
use Carp;

=head1 NAME

PDL::Primitive - primitive operations for pdl

=head1 DESCRIPTION

This module provides some primitive and useful functions defined
using PDL::PP and able to use the new indexing tricks.

See L<PDL::Indexing> for how to use indices creatively.

For explanation of the signature format, see L<PDL::PP>.

=head1 SYNOPSIS

 use PDL::Primitive;


=cut

EOD


sub projectdocs {
  my $name = shift;
  my $op = shift;
  my $extras = shift;
  return <<EOD;

=for ref

Project via $name to N-1 dimensions

This function reduces the dimensionality of a piddle
by one by taking the $name along the 1st dimension.

By using C<xchg> etc. (see L<PDL::Slices>) it is possible to use
I<any> dimension.

=for usage

    \$a = $op(\$b);

=for example

	\$spectrum = $op \$image->xchg(0,1)

$extras
=cut

EOD

}

sub cumuprojectdocs {
  my $name = shift;
  my $op = shift;
  my $extras = shift;
  return <<EOD;

=for ref

Cumulative $name

This function calculates the cumulative $name
along the 1st dimension.

By using C<xchg> etc. (see L<PDL::Slices>) it is possible to use
I<any> dimension.

The sum is started so that the first element in the cumulative $name
is the first element of the parameter.

=for usage

    \$a = $op(\$b);

=for example

	\$spectrum = $op \$image->xchg(0,1)

$extras
=cut

EOD

}


defpdl(
	'sumover',
	'a(n); int+ [o]b();',
	'',
	'$GENERIC(b) tmp = 0;
	 loop(n) %{ tmp += $a(); %}
	 $b() = tmp;',
	 projectdocs('sum','sumover','')
);

defpdl(
      'zcover',
      'a(n); int+ [o]b();',
      '',
      '$GENERIC(b) tmp = 1;
       loop(n) %{ tmp = tmp && $a() == 0; if (!tmp) break; %}
       $b() = tmp;',
       projectdocs('!= 0','zcover','')
);

pp_def(
      'andover',
      Pars => 'a(n); int+ [o]b();',
      GenericTypes => [B,S,U,L],
      Code => '$GENERIC(b) tmp = 1;
       loop(n) %{ tmp = tmp && $a(); if (!tmp) break; %}
       $b() = tmp;',
      Doc => projectdocs('and','andover','')
);

pp_def(
      'bandover',
      Pars => 'a(n); int+ [o]b();',
      GenericTypes => [B,S,U,L],
      Code => '$GENERIC(b) tmp = ~ 0 ;
       loop(n) %{ tmp &= $a(); if (!tmp) break; %}
       $b() = tmp;',
      Doc => projectdocs('bitwise and','bandover','')
);

pp_def(
      'orover',
      Pars => 'a(n); int+ [o]b();',
      GenericTypes => [B,S,U,L],
      Code => '$GENERIC(b) tmp = 0;
       loop(n) %{ tmp = tmp || $a(); if (tmp) break; %}
       $b() = tmp;',
      Doc => projectdocs('or','orover','')
);

pp_def(
      'borover',
      Pars => 'a(n); int+ [o]b();',
      GenericTypes => [B,S,U,L],
      Code => '$GENERIC(b) tmp = 0;
       loop(n) %{ tmp |= $a(); if (!~tmp) break; %}
       $b() = tmp;',
      Doc => projectdocs('bitwise or','borover','')
);

defpdl(
      'intover',
      'a(n); int+ [o]b();',
      '',
      '$GENERIC(b) tmp = 0;
       int ns = $SIZE(n), nn;
       /* Integration formulae from Press et al 2nd Ed S 4.1 */
       switch (ns) {
      case 1:
          threadloop %{
          $b() = 0.; /* not a(n=>0); as interval has zero width */
          %}
          break;
        case 2:
          threadloop %{
          $b() = 0.5*($a(n=>0)+$a(n=>1));
          %}
          break;
        case 3:
          threadloop %{
          $b() = ($a(n=>0)+4*$a(n=>1)+$a(n=>2))/3.;
          %}
          break;
      case 4:
          threadloop %{
          $b() = ($a(n=>0)+$a(n=>3)+3.*($a(n=>1)+$a(n=>2)))*0.375;
          %}
          break;
      case 5:
          threadloop %{
          $b() = (14.*($a(n=>0)+$a(n=>4))
                   +64.*($a(n=>1)+$a(n=>3))
                   +24.*$a(n=>2))/45.;
          %}
          break;
      default:
          threadloop %{
        for (nn=3;nn<ns-3;nn++) { tmp += $a(n=>nn); }
        tmp += (23./24.)*($a(n=>2)+$a(n=>nn));nn++;
        tmp += (7./6.)  *($a(n=>1)+$a(n=>nn));nn++;
        tmp += 0.375    *($a(n=>0)+$a(n=>nn));
        $b() = tmp;
          %}
      }
      ',
       projectdocs('integral','intover',
q~Notes:

For n > 3, these are all O(h^4) (like Simpson's rule), but are
integrals between the end points assuming the pdl gives values just at
these centres: for such `functions', sumover is correct to O(h), but
is the natural (and correct) choice for binned data, of course.
~)
);


defpdl(
	'cumusumover',
	'a(n); int+ [o]b(n);',
	'',
	'$GENERIC(b) tmp = 0;
	 loop(n) %{ tmp += $a();
		 $b() = tmp;
	 %}
	',
	 cumuprojectdocs('sum','cumusumover','')
);


defpdl(
	'prodover',
	'a(n); int+ [o]b();',
	'',
	'$GENERIC(b) tmp = 1;
	 loop(n) %{ tmp *= $a(); %}
	 $b() = tmp;',
	 projectdocs('product','prodover','')
);

defpdl(
	'cumuprodover',
	'a(n); int+ [o]b(n);',
	'',
	'$GENERIC(b) tmp = 1;
	 loop(n) %{ tmp *= $a();
		 $b() = tmp;
	 %}
	 ',
	 cumuprojectdocs('product','cumuprodover','')
);


# XXX why cnt? Why not size(n)? Why not threadloop for efficiency
defpdl(
	'average',
	'a(n); int+ [o]b();',
	'',
	'$GENERIC(b) tmp = 0, cnt;
	 cnt = 0;
	 loop(n) %{ tmp += $a(); cnt++; %}
	 $b() = tmp/cnt;',
	 projectdocs('average','average','')
);

# Internal utility sorting routine for median/qsort routines.

for (keys %PDL::Types::typehash) {
   $ctype = $PDL::Types::typehash{$_}{ctype};
   $ppsym = $PDL::Types::typehash{$_}{ppsym};

   pp_addhdr("

      void pdl_qsort_$ppsym($ctype* xx, int a, int b) {

         int i,j;

         $ctype t, median;

         i = a; j = b;
         median = xx[(i+j) / 2];
         do {
            while (xx[i] < median)
               i++;
            while (median < xx[j])
               j--;
            if (i <= j) {
               t = xx[i]; xx[i] = xx[j]; xx[j] = t;
               i++; j--;
            }
         } while (i <= j);

         if (a < j)
            pdl_qsort_$ppsym(xx,a,j);
         if (i < b)
            pdl_qsort_$ppsym(xx,i,b);

      }

      void pdl_qsort_ind_$ppsym($ctype* xx,  int* ix, int a, int b) {

         int i,j;

         int t;
        $ctype median;

         i = a; j = b;
         median = xx[ix[(i+j) / 2]];

         do {
          while (xx[ix[i]] < median)
               i++;
            while (median < xx[ix[j]])
               j--;
            if (i <= j) {
               t = ix[i]; ix[i] = ix[j]; ix[j] = t;
               i++; j--;
            }
         } while (i <= j);

         if (a < j)
            pdl_qsort_ind_$ppsym(xx,ix,a,j);
         if (i < b)
            pdl_qsort_ind_$ppsym(xx,ix,i,b);

      }

   ");
}

pp_def('medover',
        Pars => 'a(n); [o]b(); [t]tmp(n);',
	Doc => projectdocs('median','medover',''),
        Code => '
           int nn, nn1, nn2;
	   loop(n) %{ $tmp() = $a(); %}
           nn = $COMP(__n_size)-1;
           $TBSULFD(pdl_qsort_B,pdl_qsort_S,pdl_qsort_U,
             pdl_qsort_L,pdl_qsort_F,pdl_qsort_D) ($P(tmp), 0, nn);

           nn1 = nn/2; nn2 = nn1+1;
           if (nn%2==0) {
	      $b() = $tmp(n => nn1);
           }
           else {
	      $b() = 0.5*( $tmp(n => nn1) + $tmp(n => nn2)  );
           }
');

pp_def('oddmedover',
        Pars => 'a(n); [o]b(); [t]tmp(n);',
	Doc => projectdocs('oddmedian','oddmedover','

The median is sometimes not a good choice as if the array has
an even number of elements it lies half-way between the two
middle values - thus it does not always correspond to a data
value. The lower-odd median is just the lower of these two values
and so it ALWAYS sits on an actual data value which is useful in
some circumstances.
	'),
        Code => '
           int nn, nn1;
	   loop(n) %{ $tmp() = $a(); %}
           nn = $COMP(__n_size)-1;
           $TBSULFD(pdl_qsort_B,pdl_qsort_S,pdl_qsort_U,
             pdl_qsort_L,pdl_qsort_F,pdl_qsort_D) ($P(tmp), 0, nn);

           nn1 = nn/2;
	   $b() = $tmp(n => nn1);
');


# Generate small ops functions to do entire array

for $op ( ['avg','average','average'],
          ['sum','sumover','sum'],
          ['zcheck','zcover','check for zero'],
          ['and','andover','logical and'],
          ['band','bandover','bitwise and'],
          ['or','orover','logical or'],
          ['bor','borover','bitwise or'],
	  ['min','minimum','minimum'],
	  ['max','maximum','maximum'],
	  ['median', 'medover', 'median'],
	  ['oddmedian','oddmedover','oddmedian']) {
   pp_add_exported('', $op->[0]);

   pp_addpm(<<"EOD");

=head2 $op->[0]

=for ref

Return the $op->[2] of all elements in a piddle

=for usage

\$x = $op->[0](\$data);

=cut

*$op->[0] = \\&PDL::$op->[0];
sub PDL::$op->[0] {
	my(\$x) = \@_; my \$tmp;
	\$x->clump(-1)->$op->[1](\$tmp=PDL->nullcreate(\$x) );
	return \$tmp->at();
}
EOD

} # for $op

pp_add_exported('','any all');
pp_addpm(<<'EOPM');

=head2 any

=for ref

Return true if any element in piddle set

Useful in conditional expressions:

=for example

 if (any $a>15) { print "some values are greater than 15\n" }

=cut

*any = \&or;
*PDL::any = \&PDL::or;

=head2 all

=for ref

Return true if all elements in piddle set

Useful in conditional expressions:

=for example

 if (all $a>15) { print "all values are greater than 15\n" }

=cut

*all = \&and;
*PDL::all = \&PDL::and;

EOPM

pp_addpm(<<'EOD'

=head2 minmax

=for ref

Returns an array with minimum, maximum of a piddle.

=for usage

 ($mn, $mx) = minmax($pdl);

 Return $mn as minimum, $mx as maximum, $mn_ind as the index of minimum and
 $mx_ind as the index of the maximum.

=for example

 perldl> $x = pdl [1,-2,3,5,0]

 perldl> ($min, $max) = minmax($x);

 perldl> p "$min $max\n";


=cut

*minmax = \&PDL::minmax;
sub PDL::minmax {
  my ($x)=@_; my $tmp;
  my @arr = $x->clump(-1)->minmaximum;
  return @arr[0,1];
}

EOD
);

pp_add_exported('', 'minmax');
#pp_add_exported('', 'minmax_ind');


pp_def('qsort',
        Pars => 'a(n); [o]b(n);',
        Code => '
           int nn;
	   loop(n) %{ $b() = $a(); %}
           nn = $COMP(__n_size)-1;
           $TBSULFD(pdl_qsort_B,pdl_qsort_S,pdl_qsort_U,
             pdl_qsort_L,pdl_qsort_F,pdl_qsort_D) ($P(b), 0, nn);

', Doc=>'
=for ref

Quicksort a vector into ascending order.

=for example

print qsort random(10);

=cut
');


pp_def('qsorti',
        Pars => 'a(n); int [o]indx(n);',
        Code => '
           int nn;
          int i=0;
           nn = $COMP(__n_size)-1;
          loop(n) %{ $indx() = i++; %}
           $TBSULFD(pdl_qsort_ind_B,pdl_qsort_ind_S,pdl_qsort_ind_U,
             pdl_qsort_ind_L,pdl_qsort_ind_F,pdl_qsort_ind_D) ($P(a), $P(indx),
            0, nn);

', Doc=>'
=for ref

Quicksort a vector and return index of elements in ascending order.

=for example

$ix = qsorti $a;
print $a->index($ix); # Sorted list

=cut
');


defpdl(
	'axisvalues',
	'[o,nc]a(n)',
	'',
	'loop(n) %{ $a() = n; %}',
	'
=for ref

Internal routine

C<axisvalues> is the internal primitive that implements C<axisvals> and
alters its argument.

=cut
'
);


defpdl(
	'inner',
	'a(n); b(n); [o]c(); ', '',
	'double tmp = 0;
	 loop(n) %{ tmp += $a() * $b(); %}
	 $c() = tmp;','
=for ref

Inner product over one dimension

	c = sum_i a_i * b_i

');



defpdl(
	'outer',
	'a(n); b(m); [o]c(n,m); ', '',
	'loop(n,m) %{ $c() = $a() * $b(); %}',
	<<'EOD'
=for ref

outer product over one dimension

Naturally, it is possiblet to achieve the effects of outer
product simply by threading over the "C<*>"
operator but this function is provided for convenience.

=cut
EOD
);


pp_addpm(<<'EOD');
=head2 matmult

=for sig

 Signature: matmult(a(x,y),b(y,z),[o]c(x,z))

=for ref

Matrix multiplication

We peruse the inner product to define matrix multiplication
via a threaded inner product

=cut

  sub PDL::matmult {
    barf "Invalid number of arguments for matmult" if $#_ < 1;
    my ($a,$b,$c) = @_;
    while ($a->getndims < 2) {$a = $a->dummy(-1)} # promote if necessary
    while ($b->getndims < 2) {$b = $b->dummy(-1)}
    if(!defined $c) {$c = PDL->nullcreate($a)}
    $a->dummy(1)->inner($b->xchg(0,1)->dummy(2),$c);
    return $c;
  }

  *matmult = \&PDL::matmult;

EOD

pp_add_exported('', 'matmult');


defpdl(
	'innerwt',
	'a(n); b(n); c(n); [o]d(); ', '',
	'double tmp = 0;
	 loop(n) %{ tmp += $a() * $b() * $c(); %}
	 $d() = tmp;','
=for ref

Weighted (i.e. triple) inner product

	d = sum_i a(i) b(i) c(i)
=cut
');


defpdl(
	'inner2',
	'a(n); b(n,m); c(m); [o]d();',
	'',
	'double tmp=0;
	 loop(n,m) %{
		tmp += $a() * $b() * $c();
	 %}
	 $d() = tmp;
	 ','
=for ref

Inner product of two vectors and a matrix

	d = sum_ij a(i) b(i,j) c(j)

Note that you should probably not thread over a and c since that would be  very
wasteful. Instead, you should use a temporary for b*c.

=cut
');


defpdl(
	'inner2d',
	'a(n,m); b(n,m); [o]c()',
	'',
	'double tmp=0;
	 loop(n,m) %{
	 	tmp += $a() * $b();
	 %}
	 $c() = tmp;
	','
=for ref

Inner product over 2 dimensions.

Equivalent to

	$c = inner($a->clump(2), $b->clump(2))

'
);

defpdl(
	'inner2t',
	'a(j,n); b(n,m); c(m,k); [t]tmp(n,k); [o]d(j,k));',
	'',
	'
	 loop(n,k) %{ double tmp0 = 0;
	 	loop(m) %{ tmp0 += $b() * $c(); %}
		$tmp() = tmp0;
	 %}
	 loop(j,k) %{ double tmp1 = 0;
	 	loop(n) %{ tmp1 += $a() * $tmp(); %}
		$d() = tmp1;
	%}',<<'EOD');
=for ref

Efficient Triple matrix product a*b*c

Efficiency comes from by using the temporary tmp. This operation only scales as
N**3 whereas threading using inner2 would scale as N**4.

The reason for having this routine is that you do not need to
have the same thread-dimensions for C<tmp> as for the other arguments,
which in case of large numbers of matrices makes this much more
memory-efficient.

It is hoped that things like this could be taken care of as a kind of
closures at some point.

=cut
EOD



=item minimum_ind(a(n),int [o]c()), maximum_ind(a(n),int [o]c())

These functions work like the previous except that they
return the index of the maximum element

=item minimum_n_ind(a(n),int [o]c(m)), maximum_n_ind(a(n),int [o]c(m))

These functions work like the previous except that they
return the indices of the I<m> maximum elements.

=cut

for $which (['minimum','<'],
    ['maximum','>']) {
defpdl(
	$which->[0],
	'a(n); [o]c();','',
	'$GENERIC() cur;
	 loop(n) %{
	 	if(!n || $a() '.$which->[1].' cur || IsNaN(cur)) {cur = $a();}
	 %}
	 $c() = cur;
	', projectdocs($which->[0],$which->[0])
	);
defpdl(
	$which->[0]."_ind",
	'a(n); int[o]c();','',
	'$GENERIC() cur; int curind;
	 loop(n) %{
	 	if(!n || $a() '.$which->[1].' cur || IsNaN(cur))
		   {cur = $a(); curind = n;}
	 %}
	 $c() = curind;
	',"Like $which->[0] but returns the index rather than the value"
);
defpdl(
	$which->[0]."_n_ind",
	'a(n); int[o]c(m);','',
	'$GENERIC() cur; int curind;
	 if($SIZE(m) > $SIZE(n)) $CROAK("n_ind: m_size > n_size");
	 loop(m) %{
		 loop(n) %{
		 	int nm; int flag=0;
		 	for(nm=0; nm<m; nm++) {
				if($c(m=>nm) == n) {flag=1; break;}
			}
			if(!flag &&
			   (n<=m || $a() '.$which->[1].' cur || IsNaN(cur)))
				{cur = $a(); curind = n;}
		 %}
		 $c() = curind;
	 %}
	',"Returns the index of C<m> $which->[0] elements"
);
}



pp_addpm(<<'EOD'

=cut
=head2 minmaximum

=for ref

 Find minimum and maximum and their indices for a given piddle;

=for usage

        perldl> $a=pdl [[-2,3,4],[1,0,3]]

	perldl> ($min, $max, $min_ind, $max_ind)=minmaximum($a)

        perldl> p $min, $max, $min_ind, $max_ind
        [-2 0] [4 3] [0 1] [2 2]

        See also minmax, which clumps the piddle together.

=cut
EOD
);

pp_def( 'minmaximum',
	Pars => 'a(n); [o]cmin(); [o] cmax(); int [o]cmin_ind(); int [o]cmax_ind();',
	Code => '$GENERIC() curmin, curmax;
                 int curmin_ind, curmax_ind;
	 loop(n) %{
	 	if (!n || ($a() < curmin) || IsNaN(curmin)) {curmin = $a(); curmin_ind = n;};
	 	if (!n || ($a() > curmax) || IsNaN(curmax)) {curmax = $a(); curmax_ind = n;};
	 %}
	 $cmin() = curmin;
         $cmax() = curmax;
	 $cmin_ind() = curmin_ind;
         $cmax_ind() = curmax_ind;'
	);


for (['hclip','>'],['lclip','<']) {
    pp_def($_->[0],
          Pars => 'a(); b(); [o] c()',
          Code => '$c() = ($a() '.$_->[1].' $b()) ? $b() : $a();',
          Doc =>  'clip $a by $b ($b is '.($_->[0] eq 'hclip' ? 'upper' :
                  'lower').' bound)',
          PMCode=><<"EOD",
sub PDL::$_->[0] {
   my (\$a,\$b) = \@_;
   my \$c;
   if (\$a->is_inplace) {
       \$a->set_inplace(0); \$c = \$a;
   } elsif (\$#_ > 1) {\$c=\$_[2]} else {\$c=PDL->nullcreate(\$a)}
   &PDL::_$_->[0]_int(\$a,\$b,\$c);
   return \$c;
}
EOD
    );
}

pp_add_exported('', clip);

pp_addpm(<<'EOD');

=head2 clip

=for ref

Clip a piddle by (optional) upper or lower bounds.

=for usage

	$b = $a->clip(0,3);
	$c = $a->clip(undef, $x);

=cut

*clip = \&PDL::clip;
sub PDL::clip {
  my($a, $b, $c) = @_;
  my $d; if($a->is_inplace) {$a->set_inplace(0); $d = $a} 
  elsif($#_ > 2) {$d=$_[3]} else {$d = PDL->nullcreate($a)}
 if(defined $b) {
  	&PDL::_lclip_int($a,$b,$d);
	if(defined $c) {
		&PDL::_hclip_int($d,$c,$d);
	}
  } elsif(defined $c) {
	&PDL::_hclip_int($a,$c,$d);
  }
  return $d;
}

EOD

defpdl(
	'wtstat',
	'a(n); wt(n); avg(); [o]b();',
	'int deg',
	'double wtsum = 0;
	 double statsum=0;
	 loop(n) %{
		 register double tmp; register int i;
		 wtsum += $wt();
		tmp=1; for(i=0; i<$COMP(deg); i++) tmp*=$a();
	 	statsum += $wt() * (tmp - $avg()); %}
	 $b() = statsum / wtsum;
	',<<'EOD');
=head2 wtstat

=for ref

Weighted statistical moment of given degree

This calculates a weighted statistic over the vector a.
The formula is

 b() = (sum_i wt_i * (a_i ** degree - avg)) / (sum_i wt_i)

=cut
EOD


pp_addpm(<<'EOD');

=head2 random

=for ref

Constructor which returns piddle of random numbers

=for usage

   $a = random([type], $nx, $ny, $nz,...);
   $a = random $b;

   etc. (see 'zeroes')

This is the uniform distribution between 0 and 1 (assumedly
excluding 1 itself). The arguments are the same as C<zeroes>
(q.v.) - i.e. one can specify dimensions, types or give
a template.

=head2 randsym

=for ref

Constructor which returns piddle of random numbers

=for usage

   $a = randsym([type], $nx, $ny, $nz,...);
   $a = randsym $b;

   etc. (see 'zeroes')

This is the uniform distribution between 0 and 1 (excluding both 0 and
1, cf C<random>). The arguments are the same as C<zeroes> (q.v.) -
i.e. one can specify dimensions, types or give a template.

=cut
EOD

pp_def(
	'random',
	Pars=>'a();',
	PMFunc => '',
	Code =>
	'$a() = ((double)rand()) / (RAND_MAX+1.0);',
	Doc=>undef,
	PMCode=><<'EOD',
sub random { ref($_[0]) && ref($_[0]) ne 'PDL::Type' ? $_[0]->random : PDL->random(@_) }
sub PDL::random {
   my $class = shift;
   my $x = scalar(@_)? $class->new_from_specification(@_) : $class->new_or_inplace;
   &PDL::_random_int($x);
   return $x;
}
EOD
);

pp_def(
	'randsym',
	Pars=>'a();',
	PMFunc => '',
	Code =>
	'$a() = (0.5+(double)rand()) / (RAND_MAX+1.0);',
	Doc=>undef,
	PMCode=><<'EOD',
sub randsym { ref($_[0]) && ref($_[0]) ne 'PDL::Type' ? $_[0]->randsym : PDL->randsym(@_) }
sub PDL::randsym {
   my $class = shift;
   my $x = scalar(@_)? $class->new_from_specification(@_) : $class->new_or_inplace;
   &PDL::_randsym_int($x);
   return $x;
}
EOD
);

pp_addpm(<<'EOD');

=head2 grandom

=for ref

Constructor which returns piddle of Gaussian random numbers

=for usage

   $a = grandom([type], $nx, $ny, $nz,...);
   $a = grandom $b;

   etc. See 'zeroes'

This is generated by summing 12 uniform random
distributions for now. Hopefully someone can be
inspired to create a better version!

Mean = 0, Stddev = 1

=cut

sub grandom { ref($_[0]) && ref($_[0]) ne 'PDL::Type' ? $_[0]->grandom : PDL->grandom(@_) }
sub PDL::grandom {
   my $class = shift;
   my $x = scalar(@_)? $class->new_from_specification(@_) : $class->new_or_inplace;
   use PDL::Math 'erfi';
   $x .= erfi(randsym($x));
   return $x;
}

EOD

pp_add_exported('','grandom');

defpdl(
	'assgn',
	'a(); [o]b();',
	'',
	'$b() = $a();',
'Plain numerical assignment. This is used to implement the ".=" operator'
);

# The last x is ignored...
pp_def('vsearch',
	Pars => 'i(); x(n); int [o]ip()',
	GenericTypes => [F,D], # too restrictive ?
	Code => 'int carp=0;
		 threadloop %{
		   long n1 = $SIZE(n)-1;
                   long jl=-1, jh=n1, m;
		   int up = ($x(n => n1) > $x(n => 0));
		   $GENERIC() d;
  		   while (jh-jl > 1)  /* binary search */
    			{
      				m = (jh+jl) >> 1;
      				if ($i() > $x(n => m) == up)
					jl = m;
      				else
					jh = m;
    			}
		   if (jl == -1) {
			jh = 0;
                   } else if (jl == n1) {
			if ($i() != $x(n => n1)) carp = 1;
			jh = n1;
		   } else {
			jh = jl+1;
		   }
		   $ip() = jh;
		%}
		if (carp) warn("some values had to be extrapolated");
', Doc=><<'EOD');

=for ref

routine for searching 1D values i.e. step-function interpolation.

=for usage

   $inds = vsearch($vals, $xs);

Returns for each value of $val the index of the least larger member
of $xs (which need to be in increasing order). If the value is larger
than any member of $xs, the index to the last element of $xs is returned.

=for example

This function is useful e.g. when you have a list of probabilities
for events and want to generate indices to events:

	$a = pdl(.01,.86,.93,1); # Barnsley IFS probabilities cumulatively
	$b = random 20;
	$c = vsearch($b, $a); # Now, $c will have the appropriate distr.

It is possible to use the C<cumusumover> function to obtain
cumulative probabilities from absolute probabilities.
EOD

pp_def('interpol',
	Pars => 'i(); x(n); y(n); [o] ip()',
	GenericTypes => [F,D], # too restrictive ?
	Code => 'int carp=0;
		 threadloop %{
		   long n1 = $SIZE(n)-1;
                   long jl=-1, jh=n1, m;
		   int up = ($x(n => n1) > $x(n => 0));
		   $GENERIC() d;
  		   while (jh-jl > 1)  /* binary search */
    			{
      				m = (jh+jl) >> 1;
      				if ($i() > $x(n => m) == up)
					jl = m;
      				else
					jh = m;
    			}
		   if (jl == -1) {
			if ($i() != $x(n => 0)) carp = 1;
			jl = 0;
                   } else if (jl == n1) {
			if ($i() != $x(n => n1)) carp = 1;
			jl = n1-1;
		   }
		   jh = jl+1;
		   if ((d = $x(n => jh)-$x(n => jl)) == 0)
			barf("identical abscissas");
		   d = ($x(n => jh)-$i())/d;
		   $ip() = d*$y(n => jl) + (1-d)*$y(n => jh);
		%}
		if (carp) warn("some values had to be extrapolated");
', Doc=><<'EOD');

=for ref

routine for 1D linear interpolation

=for usage

 $interpolated_values = interpol($interpol_at, $ordered_abscissas, $yvalues)

'interpol' uses a binary search to find the suspects, er...,
interpolation indices and therefore abscissas have to be strictly
ordered (increasing or decreasing). For interpolation at lots of
closely spaced abscissas an approach that uses the last index found as
a start for the next search can be faster (compare Numerical Recipes
'hunt' routine). Feel free to implement that on top of the binary
search if you like. For out of bounds values it just does a linear
extrapolation and issues a warning upon completion.

=cut
EOD

pp_add_exported("", one2nd);
pp_addpm(<<'EOD');

=head2 one2nd

=for ref

Converts a one dimensional index piddle to a set of ND coordinates

=for usage

  @coords=one2nd($a, $indices)

returns an array of piddles containing the ND indexes corresponding to
the one dimensional list indices. The indices are assumed to correspond
to array $a clumped using clump(-1). This routine is used in whichND,
but is useful on its own occasionally.

=for example

 perldl> $a=pdl [[[1,2],[-1,1]], [[0,-3],[3,2]]]; $c=$a->clump(-1)

 perldl> $maxind=maximum_ind($c); p $maxind;
 6
 perldl> print one2nd($a, maximum_ind($c))
 0 1 1
 perldl> p $a->at(0,1,1)
 3

=cut


*one2nd = \&PDL::one2nd;
sub PDL::one2nd {
  barf "Usage: one2nd $array $indices\n" if $#_ != 1;
  my ($a, $ind)=@_;
  my @dimension=$a->dims;
  my(@index);
  my $count=0;
  foreach (@dimension) {
    $index[$count++]=$ind % $_;
    $ind=long($ind/$_);
  }
  return @index;
}


EOD

pp_addpm(<<'EOD'
=head2 which

=for ref

Returns piddle of indices of non-zero values.

=for usage

 $i = which($mask);

returns a pdl with indices for all those elements that are
nonzero in the mask. Note that mask really has to be 1-D (use clump(-1)
if you need to work with ND-images)

If you want to return both the indices of non-zero values and the
complement, use the function which_both.


=for example

 perldl> $x = sequence(10); p $x
 [0 1 2 3 4 5 6 7 8 9]
 perldl> $indx = which($x>6); p $indx
 [7 8 9]

=cut

=head2 which_both

=for ref

Returns piddle of indices of non-zero values and their complement

=for usage

 ($i, $c_i) = which_both($mask);

This works just as which, but the complement of $i will be in $c_i.

=for example

 perldl> $x = sequence(10); p $x
 [0 1 2 3 4 5 6 7 8 9]
 perldl> ($small, $big) = which_both ($x >= 5); p "$small\n $big"
 [5 6 7 8 9]
 [0 1 2 3 4]

=cut


EOD
);

for ({Name=>'which',
      Pars => 'mask(n); int [o] inds(m);',
      Variables => 'int dm=0;',
      Elseclause => "",
      Autosize => '$SIZE(m) = sum;'},
     {Name => 'which_both',
      Pars => 'mask(n); int [o] inds(m); int [o]notinds(q)',
      Variables => 'int dm=0; int dm2=0;',
      Elseclause => "else { \n          \$notinds(q => dm2)=n; \n           dm2++;\n     }",
      Autosize => '$SIZE(m) = sum;'."\n".'  	  $SIZE(q) = dpdl->dims[0]-sum;'})
{
pp_def($_->{Name},
	Pars => $_->{Pars},
	Code => $_->{Variables} .
                 'loop(n) %{
			if ($mask()) {
				$inds(m => dm) = n;
				dm++;
			}'.$_->{Elseclause} . "\n".
		' %}',
#		the next one is currently a dirty hack
#               this will probably break once dataflow is enabled again
#               *unless* we have made sure that mask is physical by now!!!
	RedoDimsCode => '
		PDL_Long sum = 0;
		/* not sure if this is necessary */
		pdl * dpdl = $PDL(mask);
		$GENERIC() *m_datap = (($GENERIC() *)(PDL_REPRP(dpdl)));
		PDL_Long inc = PDL_REPRINC(dpdl,0);
		PDL_Long offs = PDL_REPROFFS(dpdl);
		int i;

		if (dpdl->ndims != 1)
		  barf("dimflag currently works only with 1D pdls");

		for (i=0; i<dpdl->dims[0]; i++) {
		       if ( *(m_datap+inc*i+offs)) sum++;
		}

		'.$_->{Autosize} . '
		/* printf("RedoDimsCode: setting dim m to %ld\n",sum); */'
);
}

pp_addpm(<<'EOD'
=head2 where

=for ref

Returns indices to non-zero values or those values from another piddle.

=for usage

 $i = $x->where($x+5 > 0); # $i contains elements of $x
                           # where mask ($x+5 > 0) is 1

Note: $i is always 1-D, even if $x is >1-D. The first argument
(the values) and the second argument (the mask) currently have to have
the same initial dimensions (or horrible things happen).

It is also possible to use the same mask for several piddles with
the same call:

 ($i,$j,$k) = where($x,$y,$z, $x+5>0);

There is also the following syntax, retained only for compatibility
with PDL versions <1.99.
This use is deprecated, and will be removed
in the future.  Use C<which> instead.

 $i = where($x > 0);       # indices to $x, equivalent to 'which()'

Note: the mask has to be 1-D. See the documentation for C<which>

=cut

sub PDL::where {
	if($#_ == 0) {
	        warn "WARNING: one argument form of where() is now deprecated - use which()\n";
		return $_[0]->which();
	} elsif($#_ == 1) {
	        my($data,$mask) = @_;
		$data = $_[0]->clump(-1) if $_[0]->getndims>1;
		$mask = $_[1]->clump(-1) if $_[0]->getndims>1;
		return $data->index($mask->which());
	} else {
		if($_[-1]->getndims > 1) {
			my $mask = $_[-1]->clump(-1)->which;
			return map {$_->clump(-1)->index($mask)}
                               @_[0..$#_-1];
		} else {
			my $mask = $_[-1]->which;
                       return map {$_->index($mask)} @_[0..$#_-1];
		}
	}
}
*where = \&PDL::where;

EOD
);

pp_add_exported("", where);

pp_def('append',
	Pars => 'a(n); b(m); [o] c(mn)',
# note that ideally we want to say '$SIZE(mn) = $SIZE(m)+$SIZE(n);'
# but that requires placing RedoDimsParsedCode *after* assignment of
# childdims to $SIZE(XXX)!!!  XXXXXmake that workXXXXX
	RedoDimsCode => '
		pdl * dpdla = $PDL(a);
		pdl * dpdlb = $PDL(b);
		$SIZE(mn) = dpdla->dims[0] + dpdlb->dims[0];',
	Code => 'register PDL_Long mnp;
		 PDL_Long ns = $SIZE(n);
                 threadloop %{
                       loop(n) %{ $c(mn => n) = $a(); %}
		       loop(m) %{ mnp = m+ns; $c(mn => mnp) = $b(); %}
		 %}',
	Doc => << 'EOD',
=for ref

append two piddles by concantening along their respective first dimensions

=for example

   $a = ones(2,4,7);
   $b = sequence 5;
   $c = $a->append($b);  # size of $c is now (7,4,7) (a jumbo-piddle ;)

C<append> appends two piddles along their first dims. Rest of the dimensions
must be compatible in the threading sense. Resulting size of first dim is
sum of sizes of the two argument piddles' first dims.

EOD
);


for({Name => 'histogram',
    WeightPar => '',
     HistType => 'int+',
     HistOp => '++',
     Doc1 => "",
     Doc2 => "",
     Doc3 => "number of\n",
     Doc4 => "\nUse C<hist()> instead for a high-level interface.\n",
     Doc5 => "histogram(pdl(1,1,2),1,0,3)\n [0 2 1]"},
    {Name => 'whistogram',
     WeightPar => 'float+ wt(n);',
     HistType => 'float+',
     HistOp => '+= $wt()',
     Doc1 => " from weighted data",
     Doc2 => "\$weights, ",
     Doc3 => "sum of the values in \$weights\nthat correspond to ",
     Doc4 => "",
     Doc5 => "whistogram(pdl(1,1,2), pdl(0.1,0.1,0.5), 1, 0, 4)\n [0 0.2 0.5 0]"})
{
pp_def($_->{Name},
	Pars => 'in(n); '.$_->{WeightPar}.$_->{HistType}.  '[o] hist(m)',
		# set outdim by Par!
	OtherPars => 'double step; double min; int msize => m',
	Code => 'register int j;
		 register int maxj = $SIZE(m)-1;
		 register double min  = $COMP(min);
		 register double step = $COMP(step);
		 threadloop %{
			 loop(m) %{ $hist() = 0; %}
		 %}
		 threadloop %{
		 	loop(n) %{
				j = (int) (($in()-min)/step);
				if (j<0) j=0;
				if (j > maxj) j = maxj;
				($hist(m => j))'.$_->{HistOp}.';
			%}
		 %}
	',
Doc=><<"EOD");

=for ref

Calculates a histogram$_->{Doc1} for given stepsize and minimum.

=for usage

 \$h = $_->{Name}(\$data, $_->{Doc2}\$step, \$min, \$numbins);
 \$hist = zeroes \$numbins;  # Put histogram in existing piddle.
 $_->{Name}(\$data, $_->{Doc2}\$hist, \$step, \$min, \$numbins);

The histogram will contain \$numbins bins starting from \$min, each
\$step wide. The value in each bin is the $_->{Doc3}values in \$data that lie within the bin limits.

Data below the lower limit is put in the first bin, and data above the
upper limit is put in the last bin.

The output is reset in a different threadloop so that you
can take a histogram of \$a(10,12) into \$b(15) and get the result
you want.
$_->{Doc4}
=for example

 perldl> p $_->{Doc5}

=cut
EOD
}

for({Name => 'histogram2d',
    WeightPar => '',
     HistType => 'int+',
     HistOp => '++',
     Doc1 => "",
     Doc2 => "",
     Doc3 => "number of\n",
     Doc5 => "histogram2d(pdl(1,1,1,2,2),pdl(2,1,1,1,1),1,0,3,1,0,3)

[
 [0 0 0]
 [0 2 2]
 [0 1 0]
]
"},
    {Name => 'whistogram2d',
     WeightPar => 'float+ wt(n);',
     HistType => 'float+',
     HistOp => '+= $wt()',
     Doc1 => " from weighted data",
     Doc2 => " \$weights,",
     Doc3 => "sum of the values in\n\$weights that correspond to ",
     Doc5 => "whistogram2d(pdl(1,1,1,2,2),pdl(2,1,1,1,1),pdl(0.1,0.2,0.3,0.4,0.5),1,0,3,1,0,3)

[
 [  0   0   0]
 [  0 0.5 0.9]
 [  0 0.1   0]
]
"})
{
pp_def($_->{Name},
	Pars => 'ina(n); inb(n); '.$_->{WeightPar}.$_->{HistType}.  '[o] hist(ma,mb)',
		# set outdim by Par!
	OtherPars => 'double stepa; double mina; int masize => ma;
	              double stepb; double minb; int mbsize => mb;',
	Code => 'register int ja,jb;
		 register int maxja = $SIZE(ma)-1;
		 register int maxjb = $SIZE(mb)-1;
		 register double mina = $COMP(mina);
		 register double minb = $COMP(minb);
		 register double stepa = $COMP(stepa);
		 register double stepb = $COMP(stepb);
		 threadloop %{
			 loop(ma,mb) %{ $hist() = 0; %}
		 %}
		 threadloop %{
		 	loop(n) %{
				ja = (int) (($ina()-mina)/stepa);
				jb = (int) (($inb()-minb)/stepb);
				if (ja<0) ja=0;
				if (ja > maxja) ja = maxja;
				if (jb<0) jb=0;
				if (jb > maxjb) jb = maxjb;
				($hist(ma => ja,mb => jb))'.$_->{HistOp}.';
			%}
		 %}
	',
Doc=><<"EOD");

=for ref

Calculates a 2d histogram$_->{Doc1}.

=for usage

 \$h = $_->{Name}(\$datax, \$datay,$_->{Doc2}
       \$stepx, \$minx, \$nbinx, \$stepy, \$miny, \$nbiny);
 \$hist = zeroes \$nbinx, \$nbiny;  # Put histogram in existing piddle.
 $_->{Name}(\$datax, \$datay,$_->{Doc2} \$hist,
       \$stepx, \$minx, \$nbinx, \$stepy, \$miny, \$nbiny);

The histogram will contain \$nbinx x \$nbiny bins, with the lower
limits of the first one at (\$minx, \$miny), and with bin size
(\$stepx, \$stepy). The value in each bin is the $_->{Doc3}values in \$datax and \$datay that lie within the bin limits.

Data below the lower limit is put in the first bin, and data above the
upper limit is put in the last bin.

=for example

 perldl> p $_->{Doc5}

=cut
EOD
}

sub crassgn {
  "\$c(tri => $_[0]) = \$a(tri => $_[1])*\$b(tri => $_[2]) -
	\$a(tri => $_[2])*\$b(tri => $_[1]);"
}

pp_def('crossp',
        Doc => <<'EOD',
=for ref

Cross product of two 3D vectors

After

=for example

   $c = crossp $a, $b

the inner product $c*$a and $c*$b will be zero, i.e. $c is
orthogonal to $a and $b

=cut
EOD
	Pars => 'a(tri=3); b(tri); [o] c(tri)',
	Code => crassgn(0,1,2)."\n".
		crassgn(1,2,0)."\n".
		crassgn(2,0,1),
);

pp_def('norm',
	Pars => 'vec(n); [o] norm(n)',
	Doc => 'Normalises a vector to unit Euclidean length',
	Code => 'double sum=0;
		 loop(n) %{ sum += $vec()*$vec(); %}
		 if (sum > 0) {
		   sum = sqrt(sum);
		   loop(n) %{ $norm() = $vec()/sum; %}
		 } else {
		   loop(n) %{ $norm() = $vec(); %}
		 }',
);

pp_add_exported('','stats');
pp_addpm(<<'EOD');

=head2 stats

=for ref

Calculates useful statistics on a piddle

=for usage

 ($mean,$rms,$median,$min,$max) = stats($piddle,[$weights]);

This utility calculates all the most useful
quantities in one call.

B<Note:> The RMS value that this function returns in the RMS 
deviation from the mean, also known as the population standard-
deviation.

=cut


*stats	  = \&PDL::stats;
sub PDL::stats {
    barf('Usage: ($mean,[$rms]) = stats($data,[$weights])') if $#_>1;
    my ($data,$weights) = @_;
    my ($mean,$rms);
    if ($#_==0) {
       $mean = ($data->sum)/($data->nelem);
       $rms = sqrt(  ((($data-$mean)**2 )->sum) / ($data->nelem) );
    }
    else {
       $mean = (($weights*$data)->sum) / (($weights)->sum);
       $rms = sqrt(  ( ( $weights*(($data-$mean)**2) )->sum )  / ($weights->sum) );
    }
    my ($median,$min,$max) = ($data->median,$data->min,$data->max);
    print "Mean = $mean, RMS = $rms, Median = $median\n".
          "Min  = $min, Max = $max\n" if $PDL::verbose;
    return $mean unless wantarray;
    return ($mean,$rms,$median,$min,$max);
}
EOD

pp_addpm(<<'EOD'
=head2 whichND

=for ref

Returns the coordinates for non-zero values

=for usage

   @coords=whichND($mask);

returns an array of piddles containing the coordinates of the elements
that are non-zero in $mask.

=for example

   perldl> $a=sequence(10,10,3,4)

   perldl> ($x, $y, $z, $w)=whichND($a == 203); p $x, $y, $z, $w)
   [3] [0] [2] [0]
   perldl> print $a->at($x,$y,$z,$w)
   203
=cut

*whichND = \&PDL::whichND;
sub PDL::whichND {
  my $mask = shift;
  my $ind=($mask->clump(-1))->which;

  return $mask->one2nd($ind);
}

EOD
);

pp_add_exported("", whichND);

pp_def('fibonacci',
        Pars => '[o]x(n);',
	Doc=>'Constructor - a vector with Fibonacci\'s sequence',
	PMFunc=>'',
	PMCode=><<'EOD',
sub fibonacci { ref($_[0]) && ref($_[0]) ne 'PDL::Type' ? $_[0]->fibonacci : PDL->fibonacci(@_) }
sub PDL::fibonacci{
   my $class = shift;
   my $x = scalar(@_)? $class->new_from_specification(@_) : $class->new_or_inplace;
   &PDL::_fibonacci_int($x->clump(-1));
   return $x;
}
EOD
     Code => '

        PDL_Long i=0;
        $GENERIC() x1, x2;

        x1 = 1; x2 = 0;

        loop(n) %{
           $x() = x1 + x2;
           if (i++>0) {
              x2 = x1;
              x1 = $x();
           }
        %}
');



pp_addpm({At=>Bot},<<'EOD');

=head1 AUTHOR

Copyright (C) Tuomas J. Lukka 1997 (lukka@husc.harvard.edu). Contributions
by Christian Soeller (c.soeller@auckland.ac.nz) and Karl Glazebrook
(kgb@aaoepp.aao.gov.au).
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.


=cut

EOD

pp_done();


use strict;

pp_addpm({At=>'Top'},<<'EOD');
=head1 NAME

PDL::Math - extended mathematical operations and special functions

=head1 SYNOPSIS

 use PDL::Math;

 use PDL::Graphics::TriD;
 imag3d [SURF2D,bessj0(rvals(zeroes(50,50))/2)];

=head1 DESCRIPTION

This module extends PDL with more advanced mathematical
functions than provided by standard Perl.

All the functions have one input pdl, and one output, unless otherwise
stated.

The functions are usually available from the system
maths library, however if they are not (determined
when PDL is compiled) a version from the Cephes math
library is used.

=cut
EOD

# Internal doc util

my %doco;
sub doco {
  my @funcs = @_;
  my $doc = pop @funcs;
  for (@funcs) { $doco{$_} = $doc }
}

doco (qw/acos asin atan tan/,
'The usual trigonometric function.');

doco (qw/cosh sinh tanh acosh asinh atanh/,
'The standard hyperbolic function.');

doco (qw/ceil floor rint/,
'Round to integral values in floating-point format.');

doco( 'pow',"Synonym for `**'.");

doco ('erf',"The error function.");
doco ('erfc',"The complement of the error function.");
doco ('erfi',"The inverse of the error function.");
doco ('ndtri',
"=for ref

The value for which the area under the
Gaussian probability density function (integrated from
minus infinity) is equal to the argument (cf L<erfi|/erfi>).");

doco(qw/bessj0 bessj1 bessy0 bessy1/, 
     "The standard Bessel function." );

doco( qw/bessjn bessyn/, 
'=for ref

The standard Bessel function.
This has a second integer
argument which gives the order of the function required.
');

if ($^O !~ /win32/i) {  # doesn't seem to be in the MS VC lib
doco( 'lgamma' ,<<'EOD');
=for ref

log gamma function

This returns 2 piddles -- the first set gives the log(gamma) values,
while the second set, of integer values, gives the sign of the gamma
function.  This is useful for determining factorials, amongst other
things.

EOD

} # if: $^O !~ win32

pp_addhdr('
#include <math.h>
#include "protos.h"
/* Change names when fixing glibc-2.1 bug */
#ifdef MY_FIXY0
#define y0(a) fixy0(a)
extern double fixy0(double a);
#endif
#ifdef MY_FIXYN
#define yn(a,b) fixyn(a,b)
extern double fixyn(int a, double b);
#endif
');
if ($^O =~ /MSWin/) {
# _finite in VC++ 4.0
pp_addhdr('
#define finite _finite
#include <float.h>
');
}
# Standard `-lm'
my (@ufuncs1) = qw(acos asin atan cosh sinh tan tanh); # F,D only
my (@ufuncs1g) = qw(ceil floor rint); # Any type

# Note: 
#  ops.pd has a power() function that does the same thing
#  (although it has OtherPars => 'int swap;' as well)
#  - left this in for now.
# 
my (@bifuncs1) = qw(pow); # Any type

# Extended `-lm'
my (@ufuncs2) = qw(acosh asinh atanh erf erfc);  # F,D only
my (@besufuncs) = qw(j0 j1 y0 y1); # "
my (@besbifuncs) = qw(jn yn); # "
# Need igamma, ibeta, and a fall-back implementation of the above

sub code_ufunc    { return '$b() = ' . $_[0] . '($a());'; }
sub badcode_ufunc { 
    my $name = $_[0];
    return 'if ( $ISBAD(a()) ) { $SETBAD(b()); } else { $b() = ' . $name . '($a()); }'; 
}

sub code_bifunc { 
    my $name = $_[0]; my $a = $_[1] || 'a'; my $b = $_[2] || 'b';
    return "\$b() = $name(\$$a(),\$$b());"; 
}
sub badcode_bifunc { 
    my $name = $_[0]; my $a = $_[1] || 'a'; my $b = $_[2] || 'b';
    return 'if ( $ISBAD('.$a.'()) || $ISBAD('.$b.'()) ) { $SETBAD(b()); } else { ' .
	"\$b() = $name(\$$a(),\$$b()); }"; 
}

sub inplace_doc {
    my $func = shift;
    return "$doco{$func} Works inplace.";
}

my $func;
foreach $func (@ufuncs1) {
    pp_def($func,
	   HandleBad => 1,
	   NoBadifNaN => 1,
	   GenericTypes => ['F','D'],
	   Pars => 'a(); [o]b();',
	   Inplace => 1,
	   Doc => inplace_doc( $func ),
	   Code => code_ufunc($func),
	   BadCode => badcode_ufunc($func),
	   );
}

foreach $func (@ufuncs1g) {
    pp_def($func,
	   HandleBad => 1,
	   NoBadifNaN => 1,
	   Pars => 'a(); [o]b();',
	   Inplace => 1,
	   Doc => inplace_doc( $func ),
	   Code => code_ufunc($func),
	   BadCode => badcode_ufunc($func),
	   );
}

foreach $func (@bifuncs1) {
    pp_def($func,
	   HandleBad => 1,
	   NoBadifNaN => 1,
	   Pars => 'a(); b(); [o]c();',
	   Inplace => [ 'a' ],
	   Doc => inplace_doc( $func ),
	   Code => code_bifunc($func),
	   BadCode => badcode_bifunc($func),
	   );
}

# Functions provided by extended -lm
foreach $func (@ufuncs2) {
    pp_def($func,
	   HandleBad => 1,
	   NoBadifNaN => 1,
	   GenericTypes => ['F','D'],
	   Pars => 'a(); [o]b();',
	   Inplace => 1,
	   Doc => inplace_doc( $func ),
	   Code => code_ufunc($func),
	   BadCode => badcode_ufunc($func),
	   );
}

foreach $func (@besufuncs) {
    my $fname = "bess$func";
    pp_def($fname,
	   HandleBad => 1,
	   NoBadifNaN => 1,
	   GenericTypes => ['F','D'],
	   Pars => 'a(); [o]b();',
	   Inplace => 1,
	   Doc => inplace_doc( $fname ),
	   Code => code_ufunc($func),
	   BadCode => badcode_ufunc($func),
	   );
}

foreach $func (@besbifuncs) {
    my $fname = "bess$func";
    pp_def($fname,
	   HandleBad => 1,
	   NoBadifNaN => 1,
	   GenericTypes => ['F','D'],
	   Pars => 'a(); int n(); [o]b();',
	   Inplace => [ 'a' ],
	   Doc => inplace_doc( $fname ),
	   Code => code_bifunc($func,'n','a'),
	   BadCode => badcode_bifunc($func,'n','a'),
	   );
}

if ($^O !~ /win32/i) {
    pp_def("lgamma",
	   HandleBad => 1,
	   Pars => 'a(); [o]b(); int[o]s()',
	   Doc => $doco{"lgamma"},
	   Code =>
	   'extern int signgam;
	    $b() = lgamma($a());
	    $s() = signgam;',     # what happens to signgam if $a() is bad?
	   BadCode => 
	   'extern int signgam;
            if ( $ISBAD(a()) ) {
               $SETBAD(b()); $SETBAD(s());
            } else {
               $b() = lgamma($a());
               $s() = signgam;
            }',
	   );
} # if: os !~ win32

pp_def(
       'badmask',
       Pars => 'a(); b(); [o]c();',
       Inplace => [ 'a' ],
       HandleBad => 1,
       Code => 
       '$c() = finite($a()) ? $a() : $b();',
       BadCode => 
       '$c() = ( finite($a()) && $ISGOOD(a()) ) ? $a() : $b();',
       CopyBadStatusCode => 
       'if ( a == c && $ISPDLSTATEBAD(a) )
           PDL->propogate_badflag( c, 0 );  /* propogate badflag if inplace AND its changed */
        $SETPDLSTATEGOOD(c);          /* always make sure the output is "good" */
       ',
       Doc => 
'=for ref

Clears all C<infs> and C<nans> in C<$a> to the corresponding value in C<$b>.

badmask can be run with C<$a> inplace:

  badmask($a->inplace,0);
  $a->inplace->badmask(0);

',
       BadDoc => 
       'If bad values are present, these are also cleared.',
       );

pp_def(
       'isfinite',
       Pars => 'a(); int [o]mask();',
       Inplace => 1,
       HandleBad => 1,
       Code => 
       '$mask() = finite((double) $a()) != 0;',
       BadCode => 
       '$mask() = finite((double) $a()) != 0 && $ISGOOD($a());',
       CopyBadStatusCode => 
       'if ( a == mask && $ISPDLSTATEBAD(a) )
           PDL->propogate_badflag( mask, 0 );  /* propogate badflag if inplace AND its changed */
        $SETPDLSTATEGOOD(mask);          /* always make sure the output is "good" */
       ',
       Doc => 
'Sets C<$mask> true if C<$a> is not a C<NaN> or C<inf> (either positive or negative). Works inplace.',
       BadDoc =>
'Bad values are treated as C<NaN> or C<inf>.',
       );

# Extra functions from cephes
pp_def(
       "erfi",
       HandleBad => 1,
       NoBadifNaN => 1,
       GenericTypes => ['F','D'],
       Pars => 'a(); [o]b()',
       Inplace => 1,
       Doc => inplace_doc( "erfi" ),
       Code => 
       'extern double ndtri(double), SQRTH;
	$b() = SQRTH*ndtri((1+(double)$a())/2);',
       BadCode => 
       'extern double ndtri(double), SQRTH;
        if ( $ISBAD(a()) ) { $SETBAD(b()); }
        else { $b() = SQRTH*ndtri((1+(double)$a())/2); }',
       );

pp_def(
       "ndtri",
       HandleBad => 1,
       NoBadifNaN => 1,
       GenericTypes => ['F','D'],
       Pars => 'a(); [o]b()',
       Inplace => 1,
       Doc => inplace_doc( "ndtri" ),
       Code => 
       'extern double ndtri(double);
	$b() = ndtri((double)$a());',
       BadCode => 
       'extern double ndtri(double);
        if ( $ISBAD(a()) ) { $SETBAD(b()); }
	else { $b() = ndtri((double)$a()); }',
       );

pp_def(
       "svd",
       HandleBad => 0,
       Pars => 'a(n,m); [o]u(n,m); [o,phys]z(n); [o]v(n,n);',
       GenericTypes => ['D'],
       Code => '
              extern void SVD( double *W, double *Z, int nRow, int nCol );
              int sm = $SIZE(m), sn = $SIZE(n), i;
              double *w, *t, zv;
              t = w = (double *) malloc(sn*(sm+sn)*sizeof(double));
              loop (m) %{
                loop(n) %{
                  *t++ = $a();
                %}
              %}
              SVD(w, $P(z), sm, sn);
              t = w;
              loop (n) %{
                zv = sqrt($z());
                $z() = zv;
              %}
              loop (m) %{
                loop (n) %{
                  $u() = *t++/$z();
                %}
              %}
              loop (n) %{
                for (i=0;i<sn;i++) {
                  $v(n0=>i, n1=>n) = *t++;
                }
              %}
              free(w);
',
      , Doc => '
=for ref

Singular value decomposition of array.

=for usage

 ($u, $s, $v) = svd($a);

',);

pp_def("polyroots",
      Pars => 'cr(n); ci(n); [o]rr(m); [o]ri(m);',
      RedoDimsCode => 'int sn = $PDL(cr)->dims[0]; $SIZE(m) = sn-1;',
      GenericTypes => ['D'],
      Code => '
              extern int cpoly( double *cr, double *ci, int deg,
                    double *rr, double *ri );
              int deg = $SIZE(n)-1, i;
              if (cpoly($P(cr), $P(ci), deg, $P(rr), $P(ri)))
                 barf("PDL::Math::polyroots failed");
',
      , Doc => '

=for ref

Complex roots of a complex polynomial, given coefficients in order
of decreasing powers.

=for usage

 ($rr, $ri) = polyroots($cr, $ci);

',);

# XXX The next two really need driver routines...

pp_def("eigens",
       HandleBad => 0,
	Pars => '[phys]a(m); [o,phys]ev(n,n); [o,phys]e(n)',
	GenericTypes => ['D'],
	Code => '
		extern void eigens( double *A, double *RR, double *E, int N );
		register int sn = $SIZE(n);
		if($SIZE(m) != (sn * (sn + 1))/2) {
			barf("Wrong sized args for eigens");
		}
		eigens($P(a), $P(ev), $P(e), sn);
',
      PMCode =>'
sub PDL::eigens {
      my ($a) = @_;
      my (@d) = $a->dims;
      barf "Need real square matrix for eigens" 
            if $#d != 1 or $d[0] != $d[1];
      my ($n) = $d[0];
      my ($sym) = 0.5*($a + $a->mv(0,1));
      my ($err) = PDL::max(abs($sym));
      barf "Need symmetric component non-zero for eigens"
          if $err == 0;
      $err = PDL::max(abs($a-$sym))/$err;
      warn "Using symmetrized version of the matrix in eigens"
          if $err > 1e-5;
      # Get lower triangular form -- 
      my ($lt) = PDL::where($sym,$sym->xvals <= $sym->yvals)->copy;
      my ($ev) = PDL->zeroes($n,$n);
      my ($e)  = PDL->zeroes($n);
      &PDL::_eigens_int($lt, $ev, $e);
      return $ev, $e;
}
'
      , Doc => '
=for ref

Eigenvalues and -vectors of a symmetric square matrix.  If passed
an asymmetric matrix, the routine will warn and symmetrize it.

=for usage

 ($e, $ev) = eigens($a);

',);

# XXX Destroys a!!!
# To use the new a again, must store both a and ips.
pp_def("simq",
       HandleBad => 0,
	Pars => '[phys]a(n,n); [phys]b(n); [o,phys]x(n); int [o,phys]ips(n)',
	OtherPars => 'int flag;',
	GenericTypes => ['D'],
	Code => '
		extern int simq( double *A, double *B, double *X,
			int n, int flag, int *IPS );
		simq($P(a),$P(b),$P(x),$SIZE(n),$COMP(flag),$P(ips));
',
      Doc => '
=for ref

Solution of simultaneous linear equations, C<a x = b>.

C<$a> is an C<n x n> matrix (i.e., a vector of length C<n*n>), stored row-wise:
that is, C<a(i,j) = a[ij]>, where C<ij = i*n + j>.  
While this is the
transpose of the normal column-wise storage, this corresponds to
normal PDL usage.  The contents of matrix a may be altered (but may be
required for subsequent calls with flag = -1).

C<$b>, C<$x>, C<$ips> are vectors of length C<n>.

Set C<flag=0> to solve.  
Set C<flag=-1> to do a new back substitution for
different C<$b> vector using the same a matrix previously reduced when
C<flag=0> (the C<$ips> vector generated in the previous solution is also
required).

');

# this doesn't need to be changed to support bad values
# I could put 'HandleBad => 1', but it would just cause an
# unnescessary increase (admittedly small) in the amount of 
# code
#
pp_def("squaretotri",
	Pars => 'a(n,n); b(m)',
	Code => '
             register int mna=0, nb=0, ns = $SIZE(n);
            #if (PERL_VERSION >= 5) && (PERL_SUBVERSION >= 57)
            dXSARGS;
             #endif

	    if($SIZE(m) != (ns * (ns+1))/2) {
	       barf("Wrong sized args for squaretotri");
	    }
            threadloop %{
		loop(m) %{
                       $b() = $a(n0 => mna, n1 => nb);
                      mna++; if(mna > nb) {mna = 0; nb ++;}
		%}
             %}
	',
	Doc => '
=for ref

Convert a symmetric square matrix to triangular vector storage

',
);

pp_addpm({At=>'Bot'},<<'EOD');

sub eigen_c {
	my($mat) = @_;
	my $s = $mat->getdim(0);
	my $z = zeroes($s * ($s+1) / 2);
	my $ev = zeroes($s);
	squaretotri($mat,$z);
	my $k = 0 * $mat;
	PDL::eigens($z, $k, $ev);
	return ($ev, $k);
}


=head1 BUGS

Hasn't been tested on all platforms to ensure Cephes
versions are picked up automatically and used correctly.

=head1 AUTHOR

Copyright (C) R.J.R. Williams 1997 (rjrw@ast.leeds.ac.uk), Karl Glazebrook
(kgb@aaoepp.aao.gov.au) and Tuomas J. Lukka (Tuomas.Lukka@helsinki.fi).

All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.

=cut
EOD
pp_done();

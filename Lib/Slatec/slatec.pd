=head1 NAME

PDL::Slatec -- PDL interface to the slatec numerical programming library

=head1 DESCRIPTION

This module serves the dual purpose of showing how to interface
PDL to an external library and providing various functions to 
interface to the slatec library. In due time, reasonable 
perl functions will be provided to take advantage of all 
the library but currently we only have

=over 8

=item ($eigvals,$eigvecs) = eigsys($mat)

Calculates the eigenvalues and eigenvectors of a real positive
definite symmetric matrix. Note: this function should be extended
to calculate only eigenvalues if called in scalar context!

=item ($inv) = inv($mat)

Inverse of a square matrix

=back

Using this library requires a fortran compiler. The source for the routines
is provided for convenience.

=head1 AUTHOR

Copyright (C) 1997 Tuomas J. Lukka. 

=cut

# for MDim, ld[str] is interpreted as "leading dimension of ..."

# Making the BAD BAD BAD assumption that PDL_Long == int 
# in fortran. BAD BAD BAD XXX (I'm going to regret this)

%ftypes = (S => F, D => D);

sub firstpar {
	$_[0] =~ /^\(([^),]+)[),]/ or die "Can't find first par from $_[0]";
	$1
}

sub defslatec {
	my($pname,$fnames,$argstr) = @_;
	my @args = map {/^\s*$/ ? () : $_} split ';', $argstr;
	my @args2 = map {
		/^\s*([a-zA-Z]+)\s+ 	# "Type name"
		  ((?:\[[^]]*\])?)\s* 	# Options
		  ([a-zA-Z]+)\s*      	# Par name
		  ((?:\([^)]*\))?)\s*$	# Dims
		 /x or die("Invalid slatec par $_");
		[$1,$2,$3,$4]} @args;
	my @ppars = map {
		if($_->[0] =~ /^M?Dim$/) {
			()
		} else {
		($_->[0] eq "Mat" and join '',@{$_}[1,2,3]) or
		($_->[0] eq "IntFlag" and "int ".join '',@{$_}[1,2,3]) or
		die "Invalid ppars ",(join ',',@$_),"\n";
		}
		} @args2;
	my @talts = map {defined $ftypes{$_} or die "FTYPE $_ NOT THERE\n";
			 [$ftypes{$_},$fnames->{$_}]}
			 	keys %$fnames;
	my $func = "\$T".(join '',map {$_->[0]} @talts) . "(" . 
	  (join ',',map {$_->[1]."_"} @talts).")";

	my %lds = map {
		($_->[0] eq "Mat" and $_->[3] ne "()") ? 
			("ld".$_->[2] =>
			 "&\$PRIV(__".firstpar($_->[3])."_size)")
		: ()} @args2;

	my @funcpars =map {(($_->[0] eq "Mat" or
	  		     $_->[0] eq "IntFlag") and "\$P($_->[2])") or
			   ($_->[0] eq "Dim" and "&\$PRIV(__$_->[2]_size)") or
			   ($_->[0] eq "MDim" and $lds{$_->[2]}) or
			   die "Invalid args2";
			}  @args2;

	print "Pars: ",(join ';',@ppars),"\n";

	pp_def($pname,
		Pars => (join ';',@ppars),
		OtherPars => '',
		Code => (join '',@ifincode) . "\n " .
			$func . "  (". (join ',',@funcpars) . ");\n"
			. (join '',@ifoutcode),
		GenericTypes => [map {$_->[0]} @talts],
	);
}

pp_addhdr('
#include "f2c.h"
#include "SlatecProtos.h"
');


pp_add_exported('',"eigsys inv");

pp_addpm(<<'END');

use PDL;
use PDL::Basic;

# Note: handles only real symmetric positive-definite.

sub eigsys {
	my($h) = @_;
	$h = float($h);
	rs($h, 
		(my $eigval=PDL->null),
		(long pdl 1),(my $eigmat=PDL->null),
		(my $fvone = PDL->null),(my $fvtwo = PDL->null),
		(my $errflag=PDL->null)
	);
#	print $covar,$eigval,$eigmat,$fvone,$fvtwo,$errflag;
	if(sum($errflag) > 0) {
		croak("Non-positive-definite matrix given to eigsys: $h\n");
	}
	return ($eigval,$eigmat);
}

sub inv {
	my($m) = @_;
	$m = $m->copy(); # Make sure we don't overwrite :(
	gefa($m,(my $ipvt=null),(my $info=null));
	if(sum($info) > 0) {
		croak("Uninvertible matrix given to inv: $m\n");
	}
	gedi($m,$ipvt,(pdl 0,0),(null),(long pdl 1));
	$m;
}

END

defslatec(
	'svdc',{S => 'ssvdc'},
	'Mat 		x	(n,p);
	 MDim 		ldx;
	 Dim 		n;
	 Dim 		p;
	 Mat 	[o]	s	(p);
	 Mat 	[o]	e	(p);
	 Mat 	[o] 	u	(n,p);
	 MDim 		ldu;
	 Mat 	[o] 	v	(p,p);
	 MDim 		ldv;
	 Mat 	[o] 	work	(n);
	 IntFlag   	job	();
	 IntFlag [o]	info	();
	'
);

defslatec(
	'poco',{S => spoco, D => dpoco},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 Mat 		rcond	();
	 Mat	[o]	z	(n);
	 IntFlag [o]	info	();
	'
);

defslatec(
	'geco',{S => sgeco, D => dgeco},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 IntFlag [o]	ipvt	(n);
	 Mat	 [o]	rcond	();
	 Mat	 [o]	z	(n);
	'
);

defslatec(
	'gefa',{S => sgefa, D => dgefa},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 IntFlag [o]	ipvt	(n);
	 IntFlag [o]	info	();
	'
);

# XXX Ensure two == 2!!
defslatec(
	'podi',{S => spodi, D => dpodi},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 Mat	[o]	det	(two);
	 IntFlag	job	();
	'
);

defslatec(
	'gedi',{S => sgedi, D => dgedi},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 IntFlag [o]	ipvt	(n);
	 Mat	 [o]	det	(two);
	 Mat	 [o]	work	(n);
	 IntFlag	job	();
	'
);
	

defslatec(
	'rs', {S => rs},
	'MDim		lda;
	 Dim		n;
	 Mat		a	(n,n);
	 Mat	[o]	w	(n);
	 IntFlag	matz	();
	 Mat	[o]	z	(n,n);
	 Mat	[t]	fvone	(n);
	 Mat	[t]	fvtwo	(n);
	 IntFlag [o]	ierr	();
	'
);



pp_done();



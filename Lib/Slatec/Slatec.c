/*
 * This file was generated automatically by xsubpp version 1.9402 from the 
 * contents of Slatec.xs. Do not edit this file, edit Slatec.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Slatec.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; /* Structure hold core C functions */
static int __pdl_debugging = 0;
SV* CoreSV;       /* Get's pointer to perl var holding core structure */


#include "f2c.h"
#include "SlatecProtos.h"
typedef struct pdl_svdc_struct {
		PDL_TRANS_START(8);
		pdl_thread  __thread;PDL_Long  __inc_x_n;PDL_Long  __inc_x_p;PDL_Long  __inc_s_p;PDL_Long  __inc_e_p;PDL_Long  __inc_u_n;PDL_Long  __inc_u_p;PDL_Long  __inc_v_p0;PDL_Long  __inc_v_p1;PDL_Long  __inc_work_n;PDL_Long  __p_size;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_svdc_struct;

void pdl_svdc_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_svdc_struct *__privtrans = (pdl_svdc_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[8];__privtrans->__p_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
__creating[3] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]))
				&& 1 ;
__creating[4] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]))
				&& 1 ;
__creating[5] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]))
				&& 1 ;
__creating[6] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[6]))
				&& 1 ;
__creating[7] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[7]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in svdc:" "CANNOT CREATE PARAMETER x");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in svdc:" "CANNOT CREATE PARAMETER job");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in svdc:" "CANNOT CREATE PARAMETER s");
					if((!__creating[3]) && __privtrans->pdls[3]->
				  ndims == 1 && __privtrans->pdls[3]->dims[0] == 0)
				   croak("Error in svdc:" "CANNOT CREATE PARAMETER e");
					if((!__creating[4]) && __privtrans->pdls[4]->
				  ndims == 1 && __privtrans->pdls[4]->dims[0] == 0)
				   croak("Error in svdc:" "CANNOT CREATE PARAMETER u");
					if((!__creating[5]) && __privtrans->pdls[5]->
				  ndims == 1 && __privtrans->pdls[5]->dims[0] == 0)
				   croak("Error in svdc:" "CANNOT CREATE PARAMETER v");
					if((!__creating[6]) && __privtrans->pdls[6]->
				  ndims == 1 && __privtrans->pdls[6]->dims[0] == 0)
				   croak("Error in svdc:" "CANNOT CREATE PARAMETER work");
					if((!__creating[7]) && __privtrans->pdls[7]->
				  ndims == 1 && __privtrans->pdls[7]->dims[0] == 0)
				   croak("Error in svdc:" "CANNOT CREATE PARAMETER info");
					 {
 static char *__parnames[] = {"x","job","s","e","u","v","work","info"};
		static int __realdims[] = {2,0,1,1,2,2,1,0};
		static char __funcname[] = "PDL::Slatec: svdc";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 8
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,8,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in svdc:" "Too few dimensions for x\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__p_size == -1 || __privtrans->__p_size == 1) {
			__privtrans->__p_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__p_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in svdc:" "Cannot create non-output argument x!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 0) {
			croak("Error in svdc:" "Too few dimensions for job\n");
		}
	} else {croak("Error in svdc:" "Cannot create non-output argument job!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 1) {
			croak("Error in svdc:" "Too few dimensions for s\n");
		}
	
		  if(__privtrans->__p_size == -1 || __privtrans->__p_size == 1) {
			__privtrans->__p_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__p_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__p_size;
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(!__creating[3]) {
		if(((__privtrans->pdls[3]))->ndims < 1) {
			croak("Error in svdc:" "Too few dimensions for e\n");
		}
	
		  if(__privtrans->__p_size == -1 || __privtrans->__p_size == 1) {
			__privtrans->__p_size = ((__privtrans->pdls[3]))->dims[0];
		  } else if(__privtrans->__p_size != ((__privtrans->pdls[3]))->dims[0]) {
		  	if(((__privtrans->pdls[3]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__p_size;
 PDL->thread_create_parameter(&__privtrans->__thread,3,dims);
}if(!__creating[4]) {
		if(((__privtrans->pdls[4]))->ndims < 2) {
			croak("Error in svdc:" "Too few dimensions for u\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[4]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[4]))->dims[0]) {
		  	if(((__privtrans->pdls[4]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__p_size == -1 || __privtrans->__p_size == 1) {
			__privtrans->__p_size = ((__privtrans->pdls[4]))->dims[1];
		  } else if(__privtrans->__p_size != ((__privtrans->pdls[4]))->dims[1]) {
		  	if(((__privtrans->pdls[4]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		} else {int dims[3]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;dims[1] = __privtrans->__p_size;
 PDL->thread_create_parameter(&__privtrans->__thread,4,dims);
}if(!__creating[5]) {
		if(((__privtrans->pdls[5]))->ndims < 2) {
			croak("Error in svdc:" "Too few dimensions for v\n");
		}
	
		  if(__privtrans->__p_size == -1 || __privtrans->__p_size == 1) {
			__privtrans->__p_size = ((__privtrans->pdls[5]))->dims[0];
		  } else if(__privtrans->__p_size != ((__privtrans->pdls[5]))->dims[0]) {
		  	if(((__privtrans->pdls[5]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__p_size == -1 || __privtrans->__p_size == 1) {
			__privtrans->__p_size = ((__privtrans->pdls[5]))->dims[1];
		  } else if(__privtrans->__p_size != ((__privtrans->pdls[5]))->dims[1]) {
		  	if(((__privtrans->pdls[5]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		} else {int dims[3]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__p_size;dims[1] = __privtrans->__p_size;
 PDL->thread_create_parameter(&__privtrans->__thread,5,dims);
}if(!__creating[6]) {
		if(((__privtrans->pdls[6]))->ndims < 1) {
			croak("Error in svdc:" "Too few dimensions for work\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[6]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[6]))->dims[0]) {
		  	if(((__privtrans->pdls[6]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in svdc:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,6,dims);
}if(!__creating[7]) {
		if(((__privtrans->pdls[7]))->ndims < 0) {
			croak("Error in svdc:" "Too few dimensions for info\n");
		}
	} else {int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__thread,7,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_x_p = 0; else
		 __privtrans->__inc_x_p = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_s_p = 0; else
		 __privtrans->__inc_s_p = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_e_p = 0; else
		 __privtrans->__inc_e_p = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_u_n = 0; else
		 __privtrans->__inc_u_n = PDL_REPRINC(__privtrans->pdls[4],0);if(__privtrans->pdls[4]->dims[1] <= 1)
		  __privtrans->__inc_u_p = 0; else
		 __privtrans->__inc_u_p = PDL_REPRINC(__privtrans->pdls[4],1);if(__privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_v_p0 = 0; else
		 __privtrans->__inc_v_p0 = PDL_REPRINC(__privtrans->pdls[5],0);if(__privtrans->pdls[5]->dims[1] <= 1)
		  __privtrans->__inc_v_p1 = 0; else
		 __privtrans->__inc_v_p1 = PDL_REPRINC(__privtrans->pdls[5],1);if(__privtrans->pdls[6]->dims[0] <= 1)
		  __privtrans->__inc_work_n = 0; else
		 __privtrans->__inc_work_n = PDL_REPRINC(__privtrans->pdls[6],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_svdc_copy(pdl_trans *__tr) {
                int __dim;
                pdl_svdc_struct *__privtrans = (pdl_svdc_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_svdc_struct *__copy
 			= malloc(sizeof(pdl_svdc_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_x_p=__copy->__inc_x_p;__privtrans->__inc_s_p=__copy->__inc_s_p;__privtrans->__inc_e_p=__copy->__inc_e_p;__privtrans->__inc_u_n=__copy->__inc_u_n;__privtrans->__inc_u_p=__copy->__inc_u_p;__privtrans->__inc_v_p0=__copy->__inc_v_p0;__privtrans->__inc_v_p1=__copy->__inc_v_p1;__privtrans->__inc_work_n=__copy->__inc_work_n;__copy->__p_size=__privtrans->__p_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_svdc_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_svdc_struct *__privtrans = (pdl_svdc_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *x_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *x_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	long *job_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *job_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Float *s_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *s_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	PDL_Float *e_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Float *e_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));
	
	PDL_Float *u_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Float *u_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));
	
	PDL_Float *v_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Float *v_physdatap = ((PDL_Float *)((__privtrans->pdls[5])->data));
	
	PDL_Float *work_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[6]))));
		PDL_Float *work_physdatap = ((PDL_Float *)((__privtrans->pdls[6])->data));
	
	long *info_datap = ((long *)(PDL_REPRP((__privtrans->pdls[7]))));
		long *info_physdatap = ((long *)((__privtrans->pdls[7])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 x_datap += __privtrans->__thread.offs[0];
job_datap += __privtrans->__thread.offs[1];
s_datap += __privtrans->__thread.offs[2];
e_datap += __privtrans->__thread.offs[3];
u_datap += __privtrans->__thread.offs[4];
v_datap += __privtrans->__thread.offs[5];
work_datap += __privtrans->__thread.offs[6];
info_datap += __privtrans->__thread.offs[7];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(ssvdc_)  (x_datap,&__privtrans->__n_size,&__privtrans->__n_size,&__privtrans->__p_size,s_datap,e_datap,u_datap,&__privtrans->__n_size,v_datap,&__privtrans->__p_size,work_datap,job_datap,info_datap);
}	/* THREADLOOPEND */
	 x_datap += __privtrans->__thread.incs[0];
job_datap += __privtrans->__thread.incs[1];
s_datap += __privtrans->__thread.incs[2];
e_datap += __privtrans->__thread.incs[3];
u_datap += __privtrans->__thread.incs[4];
v_datap += __privtrans->__thread.incs[5];
work_datap += __privtrans->__thread.incs[6];
info_datap += __privtrans->__thread.incs[7];

	 } x_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
job_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
s_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
e_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
u_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
v_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];
work_datap += __privtrans->__thread.incs[__tnpdls+6]
	     			     - __privtrans->__thread.incs[6] *
				       __privtrans->__thread.dims[0];
info_datap += __privtrans->__thread.incs[__tnpdls+7]
	     			     - __privtrans->__thread.incs[7] *
				       __privtrans->__thread.dims[0];

	} x_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];job_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];s_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];e_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];u_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];v_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];work_datap -= __privtrans->__thread.incs[__tnpdls+6] *
     				  __privtrans->__thread.dims[1];info_datap -= __privtrans->__thread.incs[__tnpdls+7] *
     				  __privtrans->__thread.dims[1];
 x_datap -= __privtrans->__thread.offs[0];
job_datap -= __privtrans->__thread.offs[1];
s_datap -= __privtrans->__thread.offs[2];
e_datap -= __privtrans->__thread.offs[3];
u_datap -= __privtrans->__thread.offs[4];
v_datap -= __privtrans->__thread.offs[5];
work_datap -= __privtrans->__thread.offs[6];
info_datap -= __privtrans->__thread.offs[7];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_svdc_free(pdl_trans *__tr) {
                int __dim;
                pdl_svdc_struct *__privtrans = (pdl_svdc_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_svdc_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_svdc_vtable = {
		0,0, 2, 8, pdl_svdc_vtable_flags, 
		pdl_svdc_redodims, pdl_svdc_readdata, NULL,
		pdl_svdc_free,NULL,NULL,pdl_svdc_copy,NULL,
		sizeof(pdl_svdc_struct),"pdl_svdc_vtable"
	 };

typedef struct pdl_poco_struct {
		PDL_TRANS_START(4);
		pdl_thread  __thread;PDL_Long  __inc_a_n0;PDL_Long  __inc_a_n1;PDL_Long  __inc_z_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_poco_struct;

void pdl_poco_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_poco_struct *__privtrans = (pdl_poco_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[4];__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
__creating[3] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in poco:" "CANNOT CREATE PARAMETER a");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in poco:" "CANNOT CREATE PARAMETER rcond");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in poco:" "CANNOT CREATE PARAMETER z");
					if((!__creating[3]) && __privtrans->pdls[3]->
				  ndims == 1 && __privtrans->pdls[3]->dims[0] == 0)
				   croak("Error in poco:" "CANNOT CREATE PARAMETER info");
					 {
 static char *__parnames[] = {"a","rcond","z","info"};
		static int __realdims[] = {2,0,1,0};
		static char __funcname[] = "PDL::Slatec: poco";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in poco:" "Too few dimensions for a\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in poco:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in poco:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in poco:" "Cannot create non-output argument a!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 0) {
			croak("Error in poco:" "Too few dimensions for rcond\n");
		}
	} else {croak("Error in poco:" "Cannot create non-output argument rcond!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 1) {
			croak("Error in poco:" "Too few dimensions for z\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in poco:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(!__creating[3]) {
		if(((__privtrans->pdls[3]))->ndims < 0) {
			croak("Error in poco:" "Too few dimensions for info\n");
		}
	} else {int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__thread,3,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_n0 = 0; else
		 __privtrans->__inc_a_n0 = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_a_n1 = 0; else
		 __privtrans->__inc_a_n1 = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_n = 0; else
		 __privtrans->__inc_z_n = PDL_REPRINC(__privtrans->pdls[2],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_poco_copy(pdl_trans *__tr) {
                int __dim;
                pdl_poco_struct *__privtrans = (pdl_poco_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_poco_struct *__copy
 			= malloc(sizeof(pdl_poco_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_a_n0=__copy->__inc_a_n0;__privtrans->__inc_a_n1=__copy->__inc_a_n1;__privtrans->__inc_z_n=__copy->__inc_z_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_poco_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_poco_struct *__privtrans = (pdl_poco_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *a_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *a_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	PDL_Float *rcond_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Float *rcond_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	
	PDL_Float *z_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *z_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	long *info_datap = ((long *)(PDL_REPRP((__privtrans->pdls[3]))));
		long *info_physdatap = ((long *)((__privtrans->pdls[3])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
rcond_datap += __privtrans->__thread.offs[1];
z_datap += __privtrans->__thread.offs[2];
info_datap += __privtrans->__thread.offs[3];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(spoco_) THISIS_D(dpoco_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,rcond_datap,z_datap,info_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
rcond_datap += __privtrans->__thread.incs[1];
z_datap += __privtrans->__thread.incs[2];
info_datap += __privtrans->__thread.incs[3];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
rcond_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
z_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
info_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];rcond_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];z_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];info_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
rcond_datap -= __privtrans->__thread.offs[1];
z_datap -= __privtrans->__thread.offs[2];
info_datap -= __privtrans->__thread.offs[3];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *a_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	PDL_Double *rcond_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Double *rcond_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	
	PDL_Double *z_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	long *info_datap = ((long *)(PDL_REPRP((__privtrans->pdls[3]))));
		long *info_physdatap = ((long *)((__privtrans->pdls[3])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
rcond_datap += __privtrans->__thread.offs[1];
z_datap += __privtrans->__thread.offs[2];
info_datap += __privtrans->__thread.offs[3];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(spoco_) THISIS_D(dpoco_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,rcond_datap,z_datap,info_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
rcond_datap += __privtrans->__thread.incs[1];
z_datap += __privtrans->__thread.incs[2];
info_datap += __privtrans->__thread.incs[3];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
rcond_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
z_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
info_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];rcond_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];z_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];info_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
rcond_datap -= __privtrans->__thread.offs[1];
z_datap -= __privtrans->__thread.offs[2];
info_datap -= __privtrans->__thread.offs[3];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_poco_free(pdl_trans *__tr) {
                int __dim;
                pdl_poco_struct *__privtrans = (pdl_poco_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_poco_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_poco_vtable = {
		0,0, 2, 4, pdl_poco_vtable_flags, 
		pdl_poco_redodims, pdl_poco_readdata, NULL,
		pdl_poco_free,NULL,NULL,pdl_poco_copy,NULL,
		sizeof(pdl_poco_struct),"pdl_poco_vtable"
	 };

typedef struct pdl_geco_struct {
		PDL_TRANS_START(4);
		pdl_thread  __thread;PDL_Long  __inc_a_n0;PDL_Long  __inc_a_n1;PDL_Long  __inc_ipvt_n;PDL_Long  __inc_z_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_geco_struct;

void pdl_geco_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_geco_struct *__privtrans = (pdl_geco_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[4];__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 1 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
__creating[3] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in geco:" "CANNOT CREATE PARAMETER a");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in geco:" "CANNOT CREATE PARAMETER ipvt");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in geco:" "CANNOT CREATE PARAMETER rcond");
					if((!__creating[3]) && __privtrans->pdls[3]->
				  ndims == 1 && __privtrans->pdls[3]->dims[0] == 0)
				   croak("Error in geco:" "CANNOT CREATE PARAMETER z");
					 {
 static char *__parnames[] = {"a","ipvt","rcond","z"};
		static int __realdims[] = {2,1,0,1};
		static char __funcname[] = "PDL::Slatec: geco";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in geco:" "Too few dimensions for a\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in geco:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in geco:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in geco:" "Cannot create non-output argument a!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 1) {
			croak("Error in geco:" "Too few dimensions for ipvt\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in geco:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,1,dims);
}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 0) {
			croak("Error in geco:" "Too few dimensions for rcond\n");
		}
	} else {int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(!__creating[3]) {
		if(((__privtrans->pdls[3]))->ndims < 1) {
			croak("Error in geco:" "Too few dimensions for z\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
		  	if(((__privtrans->pdls[3]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in geco:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,3,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_n0 = 0; else
		 __privtrans->__inc_a_n0 = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_a_n1 = 0; else
		 __privtrans->__inc_a_n1 = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_ipvt_n = 0; else
		 __privtrans->__inc_ipvt_n = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_z_n = 0; else
		 __privtrans->__inc_z_n = PDL_REPRINC(__privtrans->pdls[3],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_geco_copy(pdl_trans *__tr) {
                int __dim;
                pdl_geco_struct *__privtrans = (pdl_geco_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_geco_struct *__copy
 			= malloc(sizeof(pdl_geco_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_a_n0=__copy->__inc_a_n0;__privtrans->__inc_a_n1=__copy->__inc_a_n1;__privtrans->__inc_ipvt_n=__copy->__inc_ipvt_n;__privtrans->__inc_z_n=__copy->__inc_z_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_geco_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_geco_struct *__privtrans = (pdl_geco_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *a_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *a_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	long *ipvt_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *ipvt_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Float *rcond_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *rcond_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	PDL_Float *z_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Float *z_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
ipvt_datap += __privtrans->__thread.offs[1];
rcond_datap += __privtrans->__thread.offs[2];
z_datap += __privtrans->__thread.offs[3];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(sgeco_) THISIS_D(dgeco_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,ipvt_datap,rcond_datap,z_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
ipvt_datap += __privtrans->__thread.incs[1];
rcond_datap += __privtrans->__thread.incs[2];
z_datap += __privtrans->__thread.incs[3];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
ipvt_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
rcond_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
z_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];ipvt_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];rcond_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];z_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
ipvt_datap -= __privtrans->__thread.offs[1];
rcond_datap -= __privtrans->__thread.offs[2];
z_datap -= __privtrans->__thread.offs[3];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *a_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	long *ipvt_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *ipvt_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Double *rcond_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *rcond_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	PDL_Double *z_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Double *z_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
ipvt_datap += __privtrans->__thread.offs[1];
rcond_datap += __privtrans->__thread.offs[2];
z_datap += __privtrans->__thread.offs[3];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(sgeco_) THISIS_D(dgeco_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,ipvt_datap,rcond_datap,z_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
ipvt_datap += __privtrans->__thread.incs[1];
rcond_datap += __privtrans->__thread.incs[2];
z_datap += __privtrans->__thread.incs[3];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
ipvt_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
rcond_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
z_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];ipvt_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];rcond_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];z_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
ipvt_datap -= __privtrans->__thread.offs[1];
rcond_datap -= __privtrans->__thread.offs[2];
z_datap -= __privtrans->__thread.offs[3];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_geco_free(pdl_trans *__tr) {
                int __dim;
                pdl_geco_struct *__privtrans = (pdl_geco_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_geco_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_geco_vtable = {
		0,0, 1, 4, pdl_geco_vtable_flags, 
		pdl_geco_redodims, pdl_geco_readdata, NULL,
		pdl_geco_free,NULL,NULL,pdl_geco_copy,NULL,
		sizeof(pdl_geco_struct),"pdl_geco_vtable"
	 };

typedef struct pdl_gefa_struct {
		PDL_TRANS_START(3);
		pdl_thread  __thread;PDL_Long  __inc_a_n0;PDL_Long  __inc_a_n1;PDL_Long  __inc_ipvt_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_gefa_struct;

void pdl_gefa_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_gefa_struct *__privtrans = (pdl_gefa_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[3];__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 1 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in gefa:" "CANNOT CREATE PARAMETER a");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in gefa:" "CANNOT CREATE PARAMETER ipvt");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in gefa:" "CANNOT CREATE PARAMETER info");
					 {
 static char *__parnames[] = {"a","ipvt","info"};
		static int __realdims[] = {2,1,0};
		static char __funcname[] = "PDL::Slatec: gefa";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in gefa:" "Too few dimensions for a\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in gefa:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in gefa:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in gefa:" "Cannot create non-output argument a!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 1) {
			croak("Error in gefa:" "Too few dimensions for ipvt\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in gefa:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,1,dims);
}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 0) {
			croak("Error in gefa:" "Too few dimensions for info\n");
		}
	} else {int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_n0 = 0; else
		 __privtrans->__inc_a_n0 = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_a_n1 = 0; else
		 __privtrans->__inc_a_n1 = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_ipvt_n = 0; else
		 __privtrans->__inc_ipvt_n = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_gefa_copy(pdl_trans *__tr) {
                int __dim;
                pdl_gefa_struct *__privtrans = (pdl_gefa_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_gefa_struct *__copy
 			= malloc(sizeof(pdl_gefa_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_a_n0=__copy->__inc_a_n0;__privtrans->__inc_a_n1=__copy->__inc_a_n1;__privtrans->__inc_ipvt_n=__copy->__inc_ipvt_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_gefa_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_gefa_struct *__privtrans = (pdl_gefa_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *a_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *a_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	long *ipvt_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *ipvt_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	long *info_datap = ((long *)(PDL_REPRP((__privtrans->pdls[2]))));
		long *info_physdatap = ((long *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
ipvt_datap += __privtrans->__thread.offs[1];
info_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(sgefa_) THISIS_D(dgefa_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,ipvt_datap,info_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
ipvt_datap += __privtrans->__thread.incs[1];
info_datap += __privtrans->__thread.incs[2];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
ipvt_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
info_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];ipvt_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];info_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
ipvt_datap -= __privtrans->__thread.offs[1];
info_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *a_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	long *ipvt_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *ipvt_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	long *info_datap = ((long *)(PDL_REPRP((__privtrans->pdls[2]))));
		long *info_physdatap = ((long *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
ipvt_datap += __privtrans->__thread.offs[1];
info_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(sgefa_) THISIS_D(dgefa_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,ipvt_datap,info_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
ipvt_datap += __privtrans->__thread.incs[1];
info_datap += __privtrans->__thread.incs[2];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
ipvt_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
info_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];ipvt_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];info_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
ipvt_datap -= __privtrans->__thread.offs[1];
info_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_gefa_free(pdl_trans *__tr) {
                int __dim;
                pdl_gefa_struct *__privtrans = (pdl_gefa_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_gefa_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_gefa_vtable = {
		0,0, 1, 3, pdl_gefa_vtable_flags, 
		pdl_gefa_redodims, pdl_gefa_readdata, NULL,
		pdl_gefa_free,NULL,NULL,pdl_gefa_copy,NULL,
		sizeof(pdl_gefa_struct),"pdl_gefa_vtable"
	 };

typedef struct pdl_podi_struct {
		PDL_TRANS_START(3);
		pdl_thread  __thread;PDL_Long  __inc_a_n0;PDL_Long  __inc_a_n1;PDL_Long  __inc_det_two;PDL_Long  __two_size;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_podi_struct;

void pdl_podi_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_podi_struct *__privtrans = (pdl_podi_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[3];__privtrans->__two_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in podi:" "CANNOT CREATE PARAMETER a");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in podi:" "CANNOT CREATE PARAMETER job");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in podi:" "CANNOT CREATE PARAMETER det");
					 {
 static char *__parnames[] = {"a","job","det"};
		static int __realdims[] = {2,0,1};
		static char __funcname[] = "PDL::Slatec: podi";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in podi:" "Too few dimensions for a\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in podi:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in podi:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in podi:" "Cannot create non-output argument a!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 0) {
			croak("Error in podi:" "Too few dimensions for job\n");
		}
	} else {croak("Error in podi:" "Cannot create non-output argument job!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 1) {
			croak("Error in podi:" "Too few dimensions for det\n");
		}
	
		  if(__privtrans->__two_size == -1 || __privtrans->__two_size == 1) {
			__privtrans->__two_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__two_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in podi:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__two_size;
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_n0 = 0; else
		 __privtrans->__inc_a_n0 = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_a_n1 = 0; else
		 __privtrans->__inc_a_n1 = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_det_two = 0; else
		 __privtrans->__inc_det_two = PDL_REPRINC(__privtrans->pdls[2],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_podi_copy(pdl_trans *__tr) {
                int __dim;
                pdl_podi_struct *__privtrans = (pdl_podi_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_podi_struct *__copy
 			= malloc(sizeof(pdl_podi_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_a_n0=__copy->__inc_a_n0;__privtrans->__inc_a_n1=__copy->__inc_a_n1;__privtrans->__inc_det_two=__copy->__inc_det_two;__copy->__two_size=__privtrans->__two_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_podi_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_podi_struct *__privtrans = (pdl_podi_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *a_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *a_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	long *job_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *job_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Float *det_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *det_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
job_datap += __privtrans->__thread.offs[1];
det_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(spodi_) THISIS_D(dpodi_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,det_datap,job_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
job_datap += __privtrans->__thread.incs[1];
det_datap += __privtrans->__thread.incs[2];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
job_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
det_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];job_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];det_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
job_datap -= __privtrans->__thread.offs[1];
det_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *a_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	long *job_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *job_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Double *det_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *det_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
job_datap += __privtrans->__thread.offs[1];
det_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(spodi_) THISIS_D(dpodi_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,det_datap,job_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
job_datap += __privtrans->__thread.incs[1];
det_datap += __privtrans->__thread.incs[2];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
job_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
det_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];job_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];det_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
job_datap -= __privtrans->__thread.offs[1];
det_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_podi_free(pdl_trans *__tr) {
                int __dim;
                pdl_podi_struct *__privtrans = (pdl_podi_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_podi_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_podi_vtable = {
		0,0, 2, 3, pdl_podi_vtable_flags, 
		pdl_podi_redodims, pdl_podi_readdata, NULL,
		pdl_podi_free,NULL,NULL,pdl_podi_copy,NULL,
		sizeof(pdl_podi_struct),"pdl_podi_vtable"
	 };

typedef struct pdl_gedi_struct {
		PDL_TRANS_START(5);
		pdl_thread  __thread;PDL_Long  __inc_a_n0;PDL_Long  __inc_a_n1;PDL_Long  __inc_ipvt_n;PDL_Long  __inc_det_two;PDL_Long  __inc_work_n;PDL_Long  __two_size;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_gedi_struct;

void pdl_gedi_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_gedi_struct *__privtrans = (pdl_gedi_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[5];__privtrans->__two_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
__creating[3] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]))
				&& 1 ;
__creating[4] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in gedi:" "CANNOT CREATE PARAMETER a");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in gedi:" "CANNOT CREATE PARAMETER job");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in gedi:" "CANNOT CREATE PARAMETER ipvt");
					if((!__creating[3]) && __privtrans->pdls[3]->
				  ndims == 1 && __privtrans->pdls[3]->dims[0] == 0)
				   croak("Error in gedi:" "CANNOT CREATE PARAMETER det");
					if((!__creating[4]) && __privtrans->pdls[4]->
				  ndims == 1 && __privtrans->pdls[4]->dims[0] == 0)
				   croak("Error in gedi:" "CANNOT CREATE PARAMETER work");
					 {
 static char *__parnames[] = {"a","job","ipvt","det","work"};
		static int __realdims[] = {2,0,1,1,1};
		static char __funcname[] = "PDL::Slatec: gedi";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in gedi:" "Too few dimensions for a\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in gedi:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in gedi:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in gedi:" "Cannot create non-output argument a!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 0) {
			croak("Error in gedi:" "Too few dimensions for job\n");
		}
	} else {croak("Error in gedi:" "Cannot create non-output argument job!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 1) {
			croak("Error in gedi:" "Too few dimensions for ipvt\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in gedi:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(!__creating[3]) {
		if(((__privtrans->pdls[3]))->ndims < 1) {
			croak("Error in gedi:" "Too few dimensions for det\n");
		}
	
		  if(__privtrans->__two_size == -1 || __privtrans->__two_size == 1) {
			__privtrans->__two_size = ((__privtrans->pdls[3]))->dims[0];
		  } else if(__privtrans->__two_size != ((__privtrans->pdls[3]))->dims[0]) {
		  	if(((__privtrans->pdls[3]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in gedi:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__two_size;
 PDL->thread_create_parameter(&__privtrans->__thread,3,dims);
}if(!__creating[4]) {
		if(((__privtrans->pdls[4]))->ndims < 1) {
			croak("Error in gedi:" "Too few dimensions for work\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[4]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[4]))->dims[0]) {
		  	if(((__privtrans->pdls[4]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in gedi:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,4,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_n0 = 0; else
		 __privtrans->__inc_a_n0 = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_a_n1 = 0; else
		 __privtrans->__inc_a_n1 = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_ipvt_n = 0; else
		 __privtrans->__inc_ipvt_n = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_det_two = 0; else
		 __privtrans->__inc_det_two = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_work_n = 0; else
		 __privtrans->__inc_work_n = PDL_REPRINC(__privtrans->pdls[4],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_gedi_copy(pdl_trans *__tr) {
                int __dim;
                pdl_gedi_struct *__privtrans = (pdl_gedi_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_gedi_struct *__copy
 			= malloc(sizeof(pdl_gedi_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_a_n0=__copy->__inc_a_n0;__privtrans->__inc_a_n1=__copy->__inc_a_n1;__privtrans->__inc_ipvt_n=__copy->__inc_ipvt_n;__privtrans->__inc_det_two=__copy->__inc_det_two;__privtrans->__inc_work_n=__copy->__inc_work_n;__copy->__two_size=__privtrans->__two_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_gedi_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_gedi_struct *__privtrans = (pdl_gedi_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *a_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *a_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	long *job_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *job_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	long *ipvt_datap = ((long *)(PDL_REPRP((__privtrans->pdls[2]))));
		long *ipvt_physdatap = ((long *)((__privtrans->pdls[2])->data));
	
	PDL_Float *det_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Float *det_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));
	
	PDL_Float *work_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Float *work_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
job_datap += __privtrans->__thread.offs[1];
ipvt_datap += __privtrans->__thread.offs[2];
det_datap += __privtrans->__thread.offs[3];
work_datap += __privtrans->__thread.offs[4];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(sgedi_) THISIS_D(dgedi_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,ipvt_datap,det_datap,work_datap,job_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
job_datap += __privtrans->__thread.incs[1];
ipvt_datap += __privtrans->__thread.incs[2];
det_datap += __privtrans->__thread.incs[3];
work_datap += __privtrans->__thread.incs[4];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
job_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ipvt_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
det_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
work_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];job_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ipvt_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];det_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];work_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
job_datap -= __privtrans->__thread.offs[1];
ipvt_datap -= __privtrans->__thread.offs[2];
det_datap -= __privtrans->__thread.offs[3];
work_datap -= __privtrans->__thread.offs[4];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *a_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	long *job_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *job_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	long *ipvt_datap = ((long *)(PDL_REPRP((__privtrans->pdls[2]))));
		long *ipvt_physdatap = ((long *)((__privtrans->pdls[2])->data));
	
	PDL_Double *det_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Double *det_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));
	
	PDL_Double *work_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Double *work_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
job_datap += __privtrans->__thread.offs[1];
ipvt_datap += __privtrans->__thread.offs[2];
det_datap += __privtrans->__thread.offs[3];
work_datap += __privtrans->__thread.offs[4];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(sgedi_) THISIS_D(dgedi_)  (a_datap,&__privtrans->__n_size,&__privtrans->__n_size,ipvt_datap,det_datap,work_datap,job_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
job_datap += __privtrans->__thread.incs[1];
ipvt_datap += __privtrans->__thread.incs[2];
det_datap += __privtrans->__thread.incs[3];
work_datap += __privtrans->__thread.incs[4];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
job_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ipvt_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
det_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
work_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];job_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ipvt_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];det_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];work_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
job_datap -= __privtrans->__thread.offs[1];
ipvt_datap -= __privtrans->__thread.offs[2];
det_datap -= __privtrans->__thread.offs[3];
work_datap -= __privtrans->__thread.offs[4];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_gedi_free(pdl_trans *__tr) {
                int __dim;
                pdl_gedi_struct *__privtrans = (pdl_gedi_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_gedi_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_gedi_vtable = {
		0,0, 2, 5, pdl_gedi_vtable_flags, 
		pdl_gedi_redodims, pdl_gedi_readdata, NULL,
		pdl_gedi_free,NULL,NULL,pdl_gedi_copy,NULL,
		sizeof(pdl_gedi_struct),"pdl_gedi_vtable"
	 };

typedef struct pdl_rs_struct {
		PDL_TRANS_START(7);
		pdl_thread  __thread;PDL_Long  __inc_a_n0;PDL_Long  __inc_a_n1;PDL_Long  __inc_w_n;PDL_Long  __inc_z_n0;PDL_Long  __inc_z_n1;PDL_Long  __inc_fvone_n;PDL_Long  __inc_fvtwo_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_rs_struct;

void pdl_rs_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_rs_struct *__privtrans = (pdl_rs_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[7];__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
__creating[3] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]))
				&& 1 ;
__creating[4] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]))
				&& 1 ;
__creating[5] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]))
				&& 1 ;
__creating[6] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[6]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in rs:" "CANNOT CREATE PARAMETER a");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in rs:" "CANNOT CREATE PARAMETER matz");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in rs:" "CANNOT CREATE PARAMETER w");
					if((!__creating[3]) && __privtrans->pdls[3]->
				  ndims == 1 && __privtrans->pdls[3]->dims[0] == 0)
				   croak("Error in rs:" "CANNOT CREATE PARAMETER z");
					if((!__creating[4]) && __privtrans->pdls[4]->
				  ndims == 1 && __privtrans->pdls[4]->dims[0] == 0)
				   croak("Error in rs:" "CANNOT CREATE PARAMETER fvone");
					if((!__creating[5]) && __privtrans->pdls[5]->
				  ndims == 1 && __privtrans->pdls[5]->dims[0] == 0)
				   croak("Error in rs:" "CANNOT CREATE PARAMETER fvtwo");
					if((!__creating[6]) && __privtrans->pdls[6]->
				  ndims == 1 && __privtrans->pdls[6]->dims[0] == 0)
				   croak("Error in rs:" "CANNOT CREATE PARAMETER ierr");
					 {
 static char *__parnames[] = {"a","matz","w","z","fvone","fvtwo","ierr"};
		static int __realdims[] = {2,0,1,2,1,1,0};
		static char __funcname[] = "PDL::Slatec: rs";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 7
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,7,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in rs:" "Too few dimensions for a\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in rs:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in rs:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in rs:" "Cannot create non-output argument a!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 0) {
			croak("Error in rs:" "Too few dimensions for matz\n");
		}
	} else {croak("Error in rs:" "Cannot create non-output argument matz!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 1) {
			croak("Error in rs:" "Too few dimensions for w\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in rs:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(!__creating[3]) {
		if(((__privtrans->pdls[3]))->ndims < 2) {
			croak("Error in rs:" "Too few dimensions for z\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
		  	if(((__privtrans->pdls[3]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in rs:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[3]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[3]))->dims[1]) {
		  	if(((__privtrans->pdls[3]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in rs:" "Wrong dims\n");
			}
		  }
		} else {int dims[3]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,3,dims);
}if(!__creating[4]) {
		if(((__privtrans->pdls[4]))->ndims < 1) {
			croak("Error in rs:" "Too few dimensions for fvone\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[4]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[4]))->dims[0]) {
		  	if(((__privtrans->pdls[4]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in rs:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,4,dims);
}if(!__creating[5]) {
		if(((__privtrans->pdls[5]))->ndims < 1) {
			croak("Error in rs:" "Too few dimensions for fvtwo\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[5]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[5]))->dims[0]) {
		  	if(((__privtrans->pdls[5]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in rs:" "Wrong dims\n");
			}
		  }
		} else {int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,5,dims);
}if(!__creating[6]) {
		if(((__privtrans->pdls[6]))->ndims < 0) {
			croak("Error in rs:" "Too few dimensions for ierr\n");
		}
	} else {int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__thread,6,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_n0 = 0; else
		 __privtrans->__inc_a_n0 = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_a_n1 = 0; else
		 __privtrans->__inc_a_n1 = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_w_n = 0; else
		 __privtrans->__inc_w_n = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_z_n0 = 0; else
		 __privtrans->__inc_z_n0 = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_z_n1 = 0; else
		 __privtrans->__inc_z_n1 = PDL_REPRINC(__privtrans->pdls[3],1);if(__privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_fvone_n = 0; else
		 __privtrans->__inc_fvone_n = PDL_REPRINC(__privtrans->pdls[4],0);if(__privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_fvtwo_n = 0; else
		 __privtrans->__inc_fvtwo_n = PDL_REPRINC(__privtrans->pdls[5],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_rs_copy(pdl_trans *__tr) {
                int __dim;
                pdl_rs_struct *__privtrans = (pdl_rs_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_rs_struct *__copy
 			= malloc(sizeof(pdl_rs_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_a_n0=__copy->__inc_a_n0;__privtrans->__inc_a_n1=__copy->__inc_a_n1;__privtrans->__inc_w_n=__copy->__inc_w_n;__privtrans->__inc_z_n0=__copy->__inc_z_n0;__privtrans->__inc_z_n1=__copy->__inc_z_n1;__privtrans->__inc_fvone_n=__copy->__inc_fvone_n;__privtrans->__inc_fvtwo_n=__copy->__inc_fvtwo_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_rs_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_rs_struct *__privtrans = (pdl_rs_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *a_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *a_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	long *matz_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *matz_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Float *w_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *w_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	PDL_Float *z_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Float *z_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));
	
	PDL_Float *fvone_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Float *fvone_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));
	
	PDL_Float *fvtwo_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Float *fvtwo_physdatap = ((PDL_Float *)((__privtrans->pdls[5])->data));
	
	long *ierr_datap = ((long *)(PDL_REPRP((__privtrans->pdls[6]))));
		long *ierr_physdatap = ((long *)((__privtrans->pdls[6])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 a_datap += __privtrans->__thread.offs[0];
matz_datap += __privtrans->__thread.offs[1];
w_datap += __privtrans->__thread.offs[2];
z_datap += __privtrans->__thread.offs[3];
fvone_datap += __privtrans->__thread.offs[4];
fvtwo_datap += __privtrans->__thread.offs[5];
ierr_datap += __privtrans->__thread.offs[6];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
 THISIS_F(rs_)  (&__privtrans->__n_size,&__privtrans->__n_size,a_datap,w_datap,matz_datap,z_datap,fvone_datap,fvtwo_datap,ierr_datap);
}	/* THREADLOOPEND */
	 a_datap += __privtrans->__thread.incs[0];
matz_datap += __privtrans->__thread.incs[1];
w_datap += __privtrans->__thread.incs[2];
z_datap += __privtrans->__thread.incs[3];
fvone_datap += __privtrans->__thread.incs[4];
fvtwo_datap += __privtrans->__thread.incs[5];
ierr_datap += __privtrans->__thread.incs[6];

	 } a_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
matz_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
w_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
z_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
fvone_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
fvtwo_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];
ierr_datap += __privtrans->__thread.incs[__tnpdls+6]
	     			     - __privtrans->__thread.incs[6] *
				       __privtrans->__thread.dims[0];

	} a_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];matz_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];w_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];z_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];fvone_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];fvtwo_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];ierr_datap -= __privtrans->__thread.incs[__tnpdls+6] *
     				  __privtrans->__thread.dims[1];
 a_datap -= __privtrans->__thread.offs[0];
matz_datap -= __privtrans->__thread.offs[1];
w_datap -= __privtrans->__thread.offs[2];
z_datap -= __privtrans->__thread.offs[3];
fvone_datap -= __privtrans->__thread.offs[4];
fvtwo_datap -= __privtrans->__thread.offs[5];
ierr_datap -= __privtrans->__thread.offs[6];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_rs_free(pdl_trans *__tr) {
                int __dim;
                pdl_rs_struct *__privtrans = (pdl_rs_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_rs_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_rs_vtable = {
		0,0, 2, 7, pdl_rs_vtable_flags, 
		pdl_rs_redodims, pdl_rs_readdata, NULL,
		pdl_rs_free,NULL,NULL,pdl_rs_copy,NULL,
		sizeof(pdl_rs_struct),"pdl_rs_vtable"
	 };



XS(XS_PDL__Slatec_set_debugging)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: PDL::Slatec::set_debugging(i)");
    {
	int	i = (int)SvIV(ST(0));
#line 2500 "Slatec.xs"
	int	RETVAL;
#line 2500 "Slatec.xs"
#line 2501 "Slatec.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 2504 "Slatec.xs"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
#line 2504 "Slatec.xs"
#line 2504 "Slatec.xs"
    }
    XSRETURN(1);
}

XS(XS_PDL__Slatec_svdc)
{
    dXSARGS;
    if (items != 8)
	croak("Usage: PDL::Slatec::svdc(x,s,e,u,v,work,job,info)");
    {
	pdl *	x = PDL->SvPDLV(ST(0));
	pdl *	s = PDL->SvPDLV(ST(1));
	pdl *	e = PDL->SvPDLV(ST(2));
	pdl *	u = PDL->SvPDLV(ST(3));
	pdl *	v = PDL->SvPDLV(ST(4));
	pdl *	work = PDL->SvPDLV(ST(5));
	pdl *	job = PDL->SvPDLV(ST(6));
	pdl *	info = PDL->SvPDLV(ST(7));
#line 2517 "Slatec.xs"
#line 2517 "Slatec.xs"
#line 2518 "Slatec.xs"
 { pdl_svdc_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_svdc_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;x = PDL->make_now(x);
job = PDL->make_now(job);
s = PDL->make_now(s);
e = PDL->make_now(e);
u = PDL->make_now(u);
v = PDL->make_now(v);
work = PDL->make_now(work);
info = PDL->make_now(info);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		  }
		  if(!((s->state & PDL_NOMYDIMS) &&
		       s->trans == NULL) &&
		 	__privtrans->__datatype < s->datatype) {
		 	__privtrans->__datatype = s->datatype;
		  }
		  if(!((e->state & PDL_NOMYDIMS) &&
		       e->trans == NULL) &&
		 	__privtrans->__datatype < e->datatype) {
		 	__privtrans->__datatype = e->datatype;
		  }
		  if(!((u->state & PDL_NOMYDIMS) &&
		       u->trans == NULL) &&
		 	__privtrans->__datatype < u->datatype) {
		 	__privtrans->__datatype = u->datatype;
		  }
		  if(!((v->state & PDL_NOMYDIMS) &&
		       v->trans == NULL) &&
		 	__privtrans->__datatype < v->datatype) {
		 	__privtrans->__datatype = v->datatype;
		  }
		  if(!((work->state & PDL_NOMYDIMS) &&
		       work->trans == NULL) &&
		 	__privtrans->__datatype < work->datatype) {
		 	__privtrans->__datatype = work->datatype;
		  }
		  if(((x->state & PDL_NOMYDIMS) &&
		         x->trans == NULL) &&
		       0) {
			  x->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != x->datatype) {
			x = PDL->get_convertedpdl(x,__privtrans->__datatype);
		    }if(((job->state & PDL_NOMYDIMS) &&
		         job->trans == NULL) &&
		       0) {
			  job->datatype =  PDL_L ;
		    } else if( PDL_L  != job->datatype) {
			job = PDL->get_convertedpdl(job, PDL_L );
		    }if(((s->state & PDL_NOMYDIMS) &&
		         s->trans == NULL) &&
		       01) {
			  s->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != s->datatype) {
			s = PDL->get_convertedpdl(s,__privtrans->__datatype);
		    }if(((e->state & PDL_NOMYDIMS) &&
		         e->trans == NULL) &&
		       01) {
			  e->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != e->datatype) {
			e = PDL->get_convertedpdl(e,__privtrans->__datatype);
		    }if(((u->state & PDL_NOMYDIMS) &&
		         u->trans == NULL) &&
		       01) {
			  u->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != u->datatype) {
			u = PDL->get_convertedpdl(u,__privtrans->__datatype);
		    }if(((v->state & PDL_NOMYDIMS) &&
		         v->trans == NULL) &&
		       01) {
			  v->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != v->datatype) {
			v = PDL->get_convertedpdl(v,__privtrans->__datatype);
		    }if(((work->state & PDL_NOMYDIMS) &&
		         work->trans == NULL) &&
		       01) {
			  work->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != work->datatype) {
			work = PDL->get_convertedpdl(work,__privtrans->__datatype);
		    }if(((info->state & PDL_NOMYDIMS) &&
		         info->trans == NULL) &&
		       01) {
			  info->datatype =  PDL_L ;
		    } else if( PDL_L  != info->datatype) {
			info = PDL->get_convertedpdl(info, PDL_L );
		    }{}__privtrans->pdls[0] = x;
__privtrans->pdls[1] = job;
__privtrans->pdls[2] = s;
__privtrans->pdls[3] = e;
__privtrans->pdls[4] = u;
__privtrans->pdls[5] = v;
__privtrans->pdls[6] = work;
__privtrans->pdls[7] = info;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}
#line 2618 "Slatec.xs"
#line 2618 "Slatec.xs"
#line 2618 "Slatec.xs"
    }
    XSRETURN_EMPTY;
}

XS(XS_PDL__Slatec_poco)
{
    dXSARGS;
    if (items != 4)
	croak("Usage: PDL::Slatec::poco(a,rcond,z,info)");
    {
	pdl *	a = PDL->SvPDLV(ST(0));
	pdl *	rcond = PDL->SvPDLV(ST(1));
	pdl *	z = PDL->SvPDLV(ST(2));
	pdl *	info = PDL->SvPDLV(ST(3));
#line 2626 "Slatec.xs"
#line 2626 "Slatec.xs"
#line 2627 "Slatec.xs"
 { pdl_poco_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_poco_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;a = PDL->make_now(a);
rcond = PDL->make_now(rcond);
z = PDL->make_now(z);
info = PDL->make_now(info);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < a->datatype) {
		 	__privtrans->__datatype = a->datatype;
		  }
		  if(
		 	__privtrans->__datatype < rcond->datatype) {
		 	__privtrans->__datatype = rcond->datatype;
		  }
		  if(!((z->state & PDL_NOMYDIMS) &&
		       z->trans == NULL) &&
		 	__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		  }
		  if(((a->state & PDL_NOMYDIMS) &&
		         a->trans == NULL) &&
		       0) {
			  a->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != a->datatype) {
			a = PDL->get_convertedpdl(a,__privtrans->__datatype);
		    }if(((rcond->state & PDL_NOMYDIMS) &&
		         rcond->trans == NULL) &&
		       0) {
			  rcond->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != rcond->datatype) {
			rcond = PDL->get_convertedpdl(rcond,__privtrans->__datatype);
		    }if(((z->state & PDL_NOMYDIMS) &&
		         z->trans == NULL) &&
		       01) {
			  z->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != z->datatype) {
			z = PDL->get_convertedpdl(z,__privtrans->__datatype);
		    }if(((info->state & PDL_NOMYDIMS) &&
		         info->trans == NULL) &&
		       01) {
			  info->datatype =  PDL_L ;
		    } else if( PDL_L  != info->datatype) {
			info = PDL->get_convertedpdl(info, PDL_L );
		    }{}__privtrans->pdls[0] = a;
__privtrans->pdls[1] = rcond;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = info;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}
#line 2679 "Slatec.xs"
#line 2679 "Slatec.xs"
#line 2679 "Slatec.xs"
    }
    XSRETURN_EMPTY;
}

XS(XS_PDL__Slatec_geco)
{
    dXSARGS;
    if (items != 4)
	croak("Usage: PDL::Slatec::geco(a,ipvt,rcond,z)");
    {
	pdl *	a = PDL->SvPDLV(ST(0));
	pdl *	ipvt = PDL->SvPDLV(ST(1));
	pdl *	rcond = PDL->SvPDLV(ST(2));
	pdl *	z = PDL->SvPDLV(ST(3));
#line 2687 "Slatec.xs"
#line 2687 "Slatec.xs"
#line 2688 "Slatec.xs"
 { pdl_geco_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_geco_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;a = PDL->make_now(a);
ipvt = PDL->make_now(ipvt);
rcond = PDL->make_now(rcond);
z = PDL->make_now(z);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < a->datatype) {
		 	__privtrans->__datatype = a->datatype;
		  }
		  if(!((rcond->state & PDL_NOMYDIMS) &&
		       rcond->trans == NULL) &&
		 	__privtrans->__datatype < rcond->datatype) {
		 	__privtrans->__datatype = rcond->datatype;
		  }
		  if(!((z->state & PDL_NOMYDIMS) &&
		       z->trans == NULL) &&
		 	__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		  }
		  if(((a->state & PDL_NOMYDIMS) &&
		         a->trans == NULL) &&
		       0) {
			  a->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != a->datatype) {
			a = PDL->get_convertedpdl(a,__privtrans->__datatype);
		    }if(((ipvt->state & PDL_NOMYDIMS) &&
		         ipvt->trans == NULL) &&
		       01) {
			  ipvt->datatype =  PDL_L ;
		    } else if( PDL_L  != ipvt->datatype) {
			ipvt = PDL->get_convertedpdl(ipvt, PDL_L );
		    }if(((rcond->state & PDL_NOMYDIMS) &&
		         rcond->trans == NULL) &&
		       01) {
			  rcond->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != rcond->datatype) {
			rcond = PDL->get_convertedpdl(rcond,__privtrans->__datatype);
		    }if(((z->state & PDL_NOMYDIMS) &&
		         z->trans == NULL) &&
		       01) {
			  z->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != z->datatype) {
			z = PDL->get_convertedpdl(z,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = a;
__privtrans->pdls[1] = ipvt;
__privtrans->pdls[2] = rcond;
__privtrans->pdls[3] = z;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}
#line 2741 "Slatec.xs"
#line 2741 "Slatec.xs"
#line 2741 "Slatec.xs"
    }
    XSRETURN_EMPTY;
}

XS(XS_PDL__Slatec_gefa)
{
    dXSARGS;
    if (items != 3)
	croak("Usage: PDL::Slatec::gefa(a,ipvt,info)");
    {
	pdl *	a = PDL->SvPDLV(ST(0));
	pdl *	ipvt = PDL->SvPDLV(ST(1));
	pdl *	info = PDL->SvPDLV(ST(2));
#line 2748 "Slatec.xs"
#line 2748 "Slatec.xs"
#line 2749 "Slatec.xs"
 { pdl_gefa_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_gefa_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;a = PDL->make_now(a);
ipvt = PDL->make_now(ipvt);
info = PDL->make_now(info);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < a->datatype) {
		 	__privtrans->__datatype = a->datatype;
		  }
		  if(((a->state & PDL_NOMYDIMS) &&
		         a->trans == NULL) &&
		       0) {
			  a->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != a->datatype) {
			a = PDL->get_convertedpdl(a,__privtrans->__datatype);
		    }if(((ipvt->state & PDL_NOMYDIMS) &&
		         ipvt->trans == NULL) &&
		       01) {
			  ipvt->datatype =  PDL_L ;
		    } else if( PDL_L  != ipvt->datatype) {
			ipvt = PDL->get_convertedpdl(ipvt, PDL_L );
		    }if(((info->state & PDL_NOMYDIMS) &&
		         info->trans == NULL) &&
		       01) {
			  info->datatype =  PDL_L ;
		    } else if( PDL_L  != info->datatype) {
			info = PDL->get_convertedpdl(info, PDL_L );
		    }{}__privtrans->pdls[0] = a;
__privtrans->pdls[1] = ipvt;
__privtrans->pdls[2] = info;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}
#line 2784 "Slatec.xs"
#line 2784 "Slatec.xs"
#line 2784 "Slatec.xs"
    }
    XSRETURN_EMPTY;
}

XS(XS_PDL__Slatec_podi)
{
    dXSARGS;
    if (items != 3)
	croak("Usage: PDL::Slatec::podi(a,det,job)");
    {
	pdl *	a = PDL->SvPDLV(ST(0));
	pdl *	det = PDL->SvPDLV(ST(1));
	pdl *	job = PDL->SvPDLV(ST(2));
#line 2791 "Slatec.xs"
#line 2791 "Slatec.xs"
#line 2792 "Slatec.xs"
 { pdl_podi_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_podi_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;a = PDL->make_now(a);
job = PDL->make_now(job);
det = PDL->make_now(det);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < a->datatype) {
		 	__privtrans->__datatype = a->datatype;
		  }
		  if(!((det->state & PDL_NOMYDIMS) &&
		       det->trans == NULL) &&
		 	__privtrans->__datatype < det->datatype) {
		 	__privtrans->__datatype = det->datatype;
		  }
		  if(((a->state & PDL_NOMYDIMS) &&
		         a->trans == NULL) &&
		       0) {
			  a->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != a->datatype) {
			a = PDL->get_convertedpdl(a,__privtrans->__datatype);
		    }if(((job->state & PDL_NOMYDIMS) &&
		         job->trans == NULL) &&
		       0) {
			  job->datatype =  PDL_L ;
		    } else if( PDL_L  != job->datatype) {
			job = PDL->get_convertedpdl(job, PDL_L );
		    }if(((det->state & PDL_NOMYDIMS) &&
		         det->trans == NULL) &&
		       01) {
			  det->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != det->datatype) {
			det = PDL->get_convertedpdl(det,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = a;
__privtrans->pdls[1] = job;
__privtrans->pdls[2] = det;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}
#line 2832 "Slatec.xs"
#line 2832 "Slatec.xs"
#line 2832 "Slatec.xs"
    }
    XSRETURN_EMPTY;
}

XS(XS_PDL__Slatec_gedi)
{
    dXSARGS;
    if (items != 5)
	croak("Usage: PDL::Slatec::gedi(a,ipvt,det,work,job)");
    {
	pdl *	a = PDL->SvPDLV(ST(0));
	pdl *	ipvt = PDL->SvPDLV(ST(1));
	pdl *	det = PDL->SvPDLV(ST(2));
	pdl *	work = PDL->SvPDLV(ST(3));
	pdl *	job = PDL->SvPDLV(ST(4));
#line 2841 "Slatec.xs"
#line 2841 "Slatec.xs"
#line 2842 "Slatec.xs"
 { pdl_gedi_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_gedi_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;a = PDL->make_now(a);
job = PDL->make_now(job);
ipvt = PDL->make_now(ipvt);
det = PDL->make_now(det);
work = PDL->make_now(work);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < a->datatype) {
		 	__privtrans->__datatype = a->datatype;
		  }
		  if(!((det->state & PDL_NOMYDIMS) &&
		       det->trans == NULL) &&
		 	__privtrans->__datatype < det->datatype) {
		 	__privtrans->__datatype = det->datatype;
		  }
		  if(!((work->state & PDL_NOMYDIMS) &&
		       work->trans == NULL) &&
		 	__privtrans->__datatype < work->datatype) {
		 	__privtrans->__datatype = work->datatype;
		  }
		  if(((a->state & PDL_NOMYDIMS) &&
		         a->trans == NULL) &&
		       0) {
			  a->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != a->datatype) {
			a = PDL->get_convertedpdl(a,__privtrans->__datatype);
		    }if(((job->state & PDL_NOMYDIMS) &&
		         job->trans == NULL) &&
		       0) {
			  job->datatype =  PDL_L ;
		    } else if( PDL_L  != job->datatype) {
			job = PDL->get_convertedpdl(job, PDL_L );
		    }if(((ipvt->state & PDL_NOMYDIMS) &&
		         ipvt->trans == NULL) &&
		       01) {
			  ipvt->datatype =  PDL_L ;
		    } else if( PDL_L  != ipvt->datatype) {
			ipvt = PDL->get_convertedpdl(ipvt, PDL_L );
		    }if(((det->state & PDL_NOMYDIMS) &&
		         det->trans == NULL) &&
		       01) {
			  det->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != det->datatype) {
			det = PDL->get_convertedpdl(det,__privtrans->__datatype);
		    }if(((work->state & PDL_NOMYDIMS) &&
		         work->trans == NULL) &&
		       01) {
			  work->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != work->datatype) {
			work = PDL->get_convertedpdl(work,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = a;
__privtrans->pdls[1] = job;
__privtrans->pdls[2] = ipvt;
__privtrans->pdls[3] = det;
__privtrans->pdls[4] = work;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}
#line 2903 "Slatec.xs"
#line 2903 "Slatec.xs"
#line 2903 "Slatec.xs"
    }
    XSRETURN_EMPTY;
}

XS(XS_PDL__Slatec_rs)
{
    dXSARGS;
    if (items != 7)
	croak("Usage: PDL::Slatec::rs(a,w,matz,z,fvone,fvtwo,ierr)");
    {
	pdl *	a = PDL->SvPDLV(ST(0));
	pdl *	w = PDL->SvPDLV(ST(1));
	pdl *	matz = PDL->SvPDLV(ST(2));
	pdl *	z = PDL->SvPDLV(ST(3));
	pdl *	fvone = PDL->SvPDLV(ST(4));
	pdl *	fvtwo = PDL->SvPDLV(ST(5));
	pdl *	ierr = PDL->SvPDLV(ST(6));
#line 2914 "Slatec.xs"
#line 2914 "Slatec.xs"
#line 2915 "Slatec.xs"
 { pdl_rs_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_rs_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;a = PDL->make_now(a);
matz = PDL->make_now(matz);
w = PDL->make_now(w);
z = PDL->make_now(z);
fvone = PDL->make_now(fvone);
fvtwo = PDL->make_now(fvtwo);
ierr = PDL->make_now(ierr);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < a->datatype) {
		 	__privtrans->__datatype = a->datatype;
		  }
		  if(!((w->state & PDL_NOMYDIMS) &&
		       w->trans == NULL) &&
		 	__privtrans->__datatype < w->datatype) {
		 	__privtrans->__datatype = w->datatype;
		  }
		  if(!((z->state & PDL_NOMYDIMS) &&
		       z->trans == NULL) &&
		 	__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		  }
		  if(!((fvone->state & PDL_NOMYDIMS) &&
		       fvone->trans == NULL) &&
		 	__privtrans->__datatype < fvone->datatype) {
		 	__privtrans->__datatype = fvone->datatype;
		  }
		  if(!((fvtwo->state & PDL_NOMYDIMS) &&
		       fvtwo->trans == NULL) &&
		 	__privtrans->__datatype < fvtwo->datatype) {
		 	__privtrans->__datatype = fvtwo->datatype;
		  }
		  if(((a->state & PDL_NOMYDIMS) &&
		         a->trans == NULL) &&
		       0) {
			  a->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != a->datatype) {
			a = PDL->get_convertedpdl(a,__privtrans->__datatype);
		    }if(((matz->state & PDL_NOMYDIMS) &&
		         matz->trans == NULL) &&
		       0) {
			  matz->datatype =  PDL_L ;
		    } else if( PDL_L  != matz->datatype) {
			matz = PDL->get_convertedpdl(matz, PDL_L );
		    }if(((w->state & PDL_NOMYDIMS) &&
		         w->trans == NULL) &&
		       01) {
			  w->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != w->datatype) {
			w = PDL->get_convertedpdl(w,__privtrans->__datatype);
		    }if(((z->state & PDL_NOMYDIMS) &&
		         z->trans == NULL) &&
		       01) {
			  z->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != z->datatype) {
			z = PDL->get_convertedpdl(z,__privtrans->__datatype);
		    }if(((fvone->state & PDL_NOMYDIMS) &&
		         fvone->trans == NULL) &&
		       01) {
			  fvone->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != fvone->datatype) {
			fvone = PDL->get_convertedpdl(fvone,__privtrans->__datatype);
		    }if(((fvtwo->state & PDL_NOMYDIMS) &&
		         fvtwo->trans == NULL) &&
		       01) {
			  fvtwo->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != fvtwo->datatype) {
			fvtwo = PDL->get_convertedpdl(fvtwo,__privtrans->__datatype);
		    }if(((ierr->state & PDL_NOMYDIMS) &&
		         ierr->trans == NULL) &&
		       01) {
			  ierr->datatype =  PDL_L ;
		    } else if( PDL_L  != ierr->datatype) {
			ierr = PDL->get_convertedpdl(ierr, PDL_L );
		    }{}__privtrans->pdls[0] = a;
__privtrans->pdls[1] = matz;
__privtrans->pdls[2] = w;
__privtrans->pdls[3] = z;
__privtrans->pdls[4] = fvone;
__privtrans->pdls[5] = fvtwo;
__privtrans->pdls[6] = ierr;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}
#line 3002 "Slatec.xs"
#line 3002 "Slatec.xs"
#line 3002 "Slatec.xs"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_PDL__Slatec)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("PDL::Slatec::set_debugging", XS_PDL__Slatec_set_debugging, file);
        newXS("PDL::Slatec::svdc", XS_PDL__Slatec_svdc, file);
        newXS("PDL::Slatec::poco", XS_PDL__Slatec_poco, file);
        newXS("PDL::Slatec::geco", XS_PDL__Slatec_geco, file);
        newXS("PDL::Slatec::gefa", XS_PDL__Slatec_gefa, file);
        newXS("PDL::Slatec::podi", XS_PDL__Slatec_podi, file);
        newXS("PDL::Slatec::gedi", XS_PDL__Slatec_gedi, file);
        newXS("PDL::Slatec::rs", XS_PDL__Slatec_rs, file);

    /* Initialisation Section */

#line 3005 "Slatec.xs"

   /* Get pointer to structure of core shared C routines */
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
   if (CoreSV==NULL)
     croak("This module requires use of PDL::Core first");
   PDL = (Core*) (void*) SvIV( CoreSV );  /* Core* value */


    /* End of Initialisation Section */

    ST(0) = &sv_yes;
    XSRETURN(1);
}

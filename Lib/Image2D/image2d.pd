pp_addpm({At=>Top},<<'EOD');

=head1 NAME

PDL::Image2D - Miscellaneous 2D image processing functions

=head1 DESCRIPTION

Miscellaneous 2D image processing functions - for want
of anywhere else to put them

=head1 SYNOPSIS

 use PDL::Image2D;

=cut

EOD

pp_addhdr('

#define IsNaN(x) (x != x)

/* Fast Modulus with proper negative behaviour */

#define REALMOD(a,b) {while ((a)>=(b)) (a) -= (b); while ((a)<0) (a) += (b);}

/* Local quick-sort routine for doubles */

void pdl_lqsortD(double* xx, int a, int b) {

   int i,j;

   double t, median;

   i = a; j = b;
   median = xx[(i+j) / 2];
   do {
      while (xx[i] < median)
	 i++;
      while (median < xx[j])
	 j--;
      if (i <= j) {
	 t = xx[i]; xx[i] = xx[j]; xx[j] = t;
	 i++; j--;
      }
   } while (i <= j);

   if (a < j)
      pdl_lqsortD(xx,a,j);
   if (i < b)
      pdl_lqsortD(xx,i,b);
 }

');

pp_def('conv2d', Doc=><<'EOD',
=for ref

2D convolution of an array with a kernel (smoothing)

For large kernels, using a FFT routine,
such as L<PDL::FFT::fftconvolve()|PDL::FFT/fftconvolve>,
will be quicker.

=for usage

 $new = conv2d $old, $kernel, {OPTIONS}

=for example

 $smoothed = conv2d $image, ones(3,3), {Boundary => Reflect}

=for options

 Boundary - controls what values are assumed for the image when kernel
            crosses its edge:
 	    => Default  - periodic boundary conditions 
                          (i.e. wrap around axis)
 	    => Reflect  - reflect at boundary
 	    => Truncate - truncate at boundary

=cut

EOD
        Pars => 'a(m,n); kern(p,q); [o]b(m,n);',
        OtherPars => 'int opt;',
        PMCode => '

sub PDL::conv2d {
   my $opt; $opt = pop @_ if ref($_[$#_]) eq \'HASH\';
   die \'Usage: conv2d( a(m,n), kern(p,q), [o]b(m,n), {Options} )\'
      if $#_<1 || $#_>2;
   my($a,$kern) = @_;
   my $c = $#_ == 2 ? $_[2] : PDL->null;
   &PDL::_conv2d_int($a,$kern,$c,
	(!(defined $opt && exists $$opt{Boundary}))?0:
	(($$opt{Boundary} eq "Reflect") +
	2*($$opt{Boundary} eq "Truncate")));
   return $c;
}

',
        Code => '
           int i,j, i1,j1, i2,j2, poff, qoff;
           double tmp;
           int opt = $COMP(opt);
           int m_size = $COMP(__m_size);
           int n_size = $COMP(__n_size);
           int p_size = $COMP(__p_size);
           int q_size = $COMP(__q_size);
           int *mapi, *mapj;

           mapi = (int *) malloc((p_size+m_size)*sizeof(int));
           mapj = (int *) malloc((q_size+n_size)*sizeof(int));

           if ((mapi==NULL) || (mapj==NULL))
               barf("Out of Memory");

           poff = p_size/2; mapi += p_size-1;
           qoff = q_size/2; mapj += q_size-1;

	   for (i=1-p_size; i<m_size; i++) {
              i2 = i+poff;
              switch (opt) {
	case 1:      /* REFLECT */
                 if (i2<0)
                    i2 = -i2-1;
                 else if (i2 >= m_size)
                    i2 = 2*m_size-(i2+1);
                 break;
	case 2:      /* TRUNCATE */
                 if (i2<0 || i2 >= m_size)
                    i2 = -1;
                 break;
	default:
                 REALMOD(i2,m_size);
               }
               mapi[i] = i2;
	   }
	   for (j=1-q_size; j<n_size; j++) {
              j2 = j+qoff;
              switch (opt) {
	case 1:      /* REFLECT */
                 if (j2<0)
                    j2 = -j2-1;
                 else if (j2 >= n_size)
                    j2 = 2*n_size-(j2+1);
                 break;
	case 2:      /* TRUNCATE */
                 if (j2<0 || j2>=n_size)
                    j2 = -1;
                 break;
	default:
                 REALMOD(j2,n_size);
               }
               mapj[j] = j2;
	   }

           threadloop %{
           for(j=0; j<n_size; j++) { for(i=0; i<m_size; i++) {
              tmp = 0;
              for(j1=0; j1<q_size; j1++) {
                  j2 = mapj[j-j1];

                  if (j2 >= 0) {
                     for(i1=0; i1<p_size; i1++) {
                       i2 = mapi[i-i1];
                       if (i2 >= 0)
                          tmp += $a(m=>i2,n=>j2) * $kern(p=>i1,q=>j1);
                     }
                  }
              }
              $b(m=>i,n=>j) = tmp;
           }} %}
	   free(mapj+1-q_size); free(mapi+1-p_size);
');


pp_def('med2d', Doc=> <<'EOD',
=for ref

2D median-convolution of an array with a kernel (smoothing)

Note: only points in the kernel E<gt>0 are included in the median, other
points are weighted by the kernel value (medianing lots of zeroes
is rather pointless)

=for usage

 $new = med2d $old, $kernel, {OPTIONS}

=for example

 $smoothed = med2d $image, ones(3,3), {Boundary => Reflect}

=for options

 Boundary - controls what values are assumed for the image when kernel
            crosses its edge:
 	    => Default  - periodic boundary conditions (i.e. wrap around axis)
 	    => Reflect  - reflect at boundary
 	    => Truncate - truncate at boundary

=cut

EOD
        Pars => 'a(m,n); kern(p,q); [o]b(m,n);',
        OtherPars => 'int opt;',
        PMCode => '

sub PDL::med2d {
   my $opt; $opt = pop @_ if ref($_[$#_]) eq \'HASH\';
   die \'Usage: med2d( a(m,n), kern(p,q), [o]b(m,n), {Options} )\'
      if $#_<1 || $#_>2;
   my($a,$kern) = @_;
   my $c = $#_ == 2 ? $_[2] : PDL->null;
   &PDL::_med2d_int($a,$kern,$c,
	(!(defined $opt && exists $opt->{Boundary}))?0:
	(($$opt{Boundary} eq "Reflect") +
	2*($$opt{Boundary} eq "Truncate")));
   return $c;
}

',
        Code => '
           int i,j, i1,j1, i2,j2, poff, qoff,
           count;
           PDL_Double *tmp;
           PDL_Double kk;

           int opt = $COMP(opt);
           int m_size = $COMP(__m_size);
           int n_size = $COMP(__n_size);
           int p_size = $COMP(__p_size);
           int q_size = $COMP(__q_size);
           int *mapi, *mapj;

           poff = p_size/2; qoff = q_size/2;

           tmp = malloc(p_size*q_size*sizeof(PDL_Double));
           mapi = (int *) malloc((p_size+m_size)*sizeof(int));
           mapj = (int *) malloc((q_size+n_size)*sizeof(int));
           if ((tmp==NULL) || (mapi==NULL) || (mapj==NULL))
               barf("Out of Memory");

           poff = p_size/2; mapi += p_size-1;
           qoff = q_size/2; mapj += q_size-1;

	   for (i=1-p_size; i<m_size; i++) {
              i2 = i+poff;
              switch (opt) {
	case 1:      /* REFLECT */
                 if (i2<0)
                    i2 = -i2-1;
                 else if (i2 >= m_size)
                    i2 = 2*m_size-(i2+1);
                 break;
	case 2:      /* TRUNCATE */
                 if (i2<0 || i2 >= m_size)
                    i2 = -1;
                 break;
	default:
                 REALMOD(i2,m_size);
               }
               mapi[i] = i2;
	   }
	   for (j=1-q_size; j<n_size; j++) {
              j2 = j+qoff;
              switch (opt) {
	case 1:      /* REFLECT */
                 if (j2<0)
                    j2 = -j2-1;
                 else if (j2 >= n_size)
                    j2 = 2*n_size-(j2+1);
                 break;
	case 2:      /* TRUNCATE */
                 if (j2<0 || j2>=n_size)
                    j2 = -1;
                 break;
	default:
                 REALMOD(j2,n_size);
               }
               mapj[j] = j2;
	   }

           threadloop %{
           for(j=0; j<n_size; j++) { for(i=0; i<m_size; i++) {
              count = 0;
              for(j1=0; j1<q_size; j1++) {
                  j2 = mapj[j-j1];

                  if (j2 >= 0)
                     for(i1=0; i1<p_size; i1++) {
                        i2 = mapi[i-i1];
                        if (i2 >= 0) {
                           kk = $kern(p=>i1,q=>j1);
                           if (kk>0) {
                              tmp[count++] = $a(m=>i2,n=>j2) * kk;
                           }
                        }
              }}
              pdl_lqsortD(tmp,0,count-1);

              $b(m=>i,n=>j) = tmp[(count-1)/2];
           }} %}
           free(mapj+1-q_size); free(mapi+1-p_size); free(tmp);
');

pp_def('patch2d', Doc=><<'EOD',
=for ref

patch bad pixels out of 2D images,

=for usage

 $patched = patch2d $data, $bad;

C<$bad> is a 2D mask array where 1=bad pixel 0=good pixel. Pixels are replaced by the average
of their non-bad neighbours.

=cut

EOD
        Pars => 'a(m,n); int bad(m,n); [o]b(m,n);',
        Code => '
           int m_size, n_size,  i,j, i1,j1, i2,j2, norm;
           double tmp;

           m_size = $COMP(__m_size); n_size = $COMP(__n_size);

           for(j=0; j<n_size; j++) { for(i=0; i<m_size; i++) {
              $b(m=>i,n=>j) = $a(m=>i,n=>j);
              if ($bad(m=>i,n=>j)==1) {
                 tmp = 0; norm=0;
                 for(j1=-1; j1<=1; j1++) { for(i1=-1; i1<=1; i1++) {
                     i2 = i+i1; j2 = j+j1;
                     if (j2>0 && i2>0 && i2<m_size && j2<n_size &&
                        $bad(m=>i2,n=>j2)!=1)
                        tmp += $a(m=>i2,n=>j2); norm++;
                 }}
                 if (norm>0) {  /* Patch */
                    $b(m=>i,n=>j) = tmp/norm;
                 }

              } /* Next pixel */
           }}
');


pp_def('max2d_ind',Doc=><<'EOD',
=for ref

Return value/position of maximum value in 2D image

Contributed by Tim Jeness

=cut

EOD

        Pars => 'a(m,n); [o]val(); int [o]x(); int[o]y();',
        Code => '
        double cur; int curind1; int curind2;
        curind1=0;
        curind2=0;
        loop(m) %{
           loop(n) %{
           if((!m && !n) || $a() > cur || IsNaN(cur)) {
                cur = $a(); curind1 = m; curind2 = n;
              }
           %}
        %}
        $val() = cur;
        $x()   = curind1;
        $y()   = curind2;
        ');

pp_def('centroid2d',Doc=><<'EOD',
=for ref

Refine a list of object positions in 2D image by centroiding in a box

C<$box> is the full-width of the box, i.e. the window
is C<+/- $box/2>.

=cut

EOD
	Pars => 'im(m,n); x(); y(); box(); [o]xcen(); [o]ycen();',
	Code => '
   int i,j,i1,i2,j1,j2,m_size,n_size;
   double sum,data,sumx,sumy;

   m_size = $SIZE(m); n_size = $SIZE(n);

   i1 = $x() - $box()/2; i1 = i1<0 ? 0 : i1;
   i2 = $x() + $box()/2; i1 = i1>=m_size ? m_size-1 : i1;
   j1 = $y() - $box()/2; j1 = j1<0 ? 0 : j1;
   j2 = $y() + $box()/2; j1 = j1>=n_size ? n_size-1 : j1;

   sum = sumx = sumy = 0;
   for(j=j1; j<=j2; j++) { for(i=i1; i<=i2; i++) {
      data = $im(m=>i,n=>j);
      sum += data;
      sumx += data*i;
      sumy += data*j;
   }}
   $xcen() = sumx/sum;
   $ycen() = sumy/sum;
'
);

pp_addhdr('

/* Add an equivalence to a list - used by pdl_cc8compt */

void AddEquiv ( PDL_Long* equiv, PDL_Long i, PDL_Long j) {

   PDL_Long k, tmp;

   if (i==j)
      return;

    k = j;
    do {
      k = equiv[k];
    } while ( k != j && k != i );

    if ( k == j ) {
       tmp = equiv[i];
       equiv[i] = equiv[j];
       equiv[j] = tmp;
    }
}

');


pp_def('cc8compt',Doc=>'
=for ref

Connected 8-component labeling of a binary image.

Connected 8-component labeling of 0,1 image - i.e. find seperate
segmented objects and fill object pixels with object number

=for example

 $segmented = cc8compt( $image > $threshold );

=cut

',
        Pars => 'a(m,n); [o]b(m,n);',
        Code => '

      PDL_Long i,j,k;
      PDL_Long newlabel;
      PDL_Long neighbour[4];
      PDL_Long nfound;
      PDL_Long pass,count,next,this;
      PDL_Long *equiv;
      PDL_Long i1,j1,i2;
      PDL_Long nx = $SIZE(m);
      PDL_Long ny = $SIZE(n);

      loop(n) %{ loop(m) %{ /* Copy */
         $b() = $a();
      %} %}

      /* 1st pass counts max possible compts, 2nd records equivalences
*/

      for (pass = 0; pass<2; pass++) {

      if (pass==1) {
         equiv = (PDL_Long*) malloc((newlabel+1)*sizeof(PDL_Long));
         if (equiv==(PDL_Long*)0)
            barf("Out of memory");
         for(i=0;i<=newlabel;i++)
             equiv[i]=i;
      }

      newlabel = 1; /* Running label */

      for(j=0; j<ny; j++) { for(i=0; i<nx; i++) { /* Loop over image
pixels */

            nfound = 0; /* Number of neighbour >0 */

            i1 = i-1; j1 = j-1; i2 = i+1;

            if ($b(m=>i, n=>j) > 0) { /* Check 4 neighbour already seen
*/

               if (i>0 && $b(m=>i1, n=>j)>0)
                   neighbour[nfound++] = $b(m=>i1, n=>j); /* Store label
of it */
               if (j>0 && $b(m=>i, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i, n=>j1);
               if (j>0 && i>0  && $b(m=>i1, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i1, n=>j1);
               if (j>0 && i<(nx-1) && $b(m=>i2, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i2, n=>j1);

               if (nfound==0)  { /* Assign new label */
                  $b(m=>i, n=>j) = newlabel++;
               }
               else {
                  $b(m=>i, n=>j) =  neighbour[0];
                  if (nfound>1 && pass == 1) {  /* Assign equivalents */
                      for(k=1; k<nfound; k++)
                         AddEquiv( equiv, (PDL_Long)$b(m=>i, n=>j),
neighbour[k] );
                  }
               }
            }

            else {  /* No label */

               $b(m=>i, n=>j) = 0;
            }

      }} /* End of image loop */

      } /* Passes */

      /* Replace each cycle by single label */

       count = 0;
       for (i = 1; i <= newlabel; i++)
         if ( i <= equiv[i] ) {
             count++;
             this = i;
             while ( equiv[this] != i ) {
               next = equiv[this];
               equiv[this] = count;
               this = next;
             }
          equiv[this] = count;
         }


      /* Now remove equivalences */

      for(j=0; j<ny; j++) { for(i=0; i<nx; i++) { /* Loop over image
pixels */
           $b(m=>i, n=>j)   = equiv[ (PDL_Long) $b(m=>i, n=>j)  ] ;
      }}

      free(equiv); /* Tidy */
');

pp_addhdr('
#define MAXSEC 32
#define line(x1, x2, y) for (k=x1;k<=x2;k++) \
	{ /* printf("line from %d to %d\n",x1,x2); */ \
	image[k+wx*y] = col; }
#define PX(n) ps[2*n]
#define PY(n) ps[2*n+1]
	
void polyfill(PDL_Long *image, int wx, int wy, float *ps, int n,
	PDL_Long col, int *ierr)
{
   int ymin, ymax, xmin, xmax, fwrd = 1, i, j, k, nsect;
   int x[MAXSEC], temp, l;
   float s1, s2, t1, t2;
   
   ymin = PY(0); ymax = PY(0);
   xmin = PX(0); xmax = PX(0);
   *ierr = 0;
   
   for (i=1; i<n; i++) {
     ymin = ymin > PY(i) ? PY(i) : ymin;	
     ymax = ymax < PY(i) ? PY(i) : ymax;
     xmin = xmin > PX(i) ? PX(i) : xmin;	
     xmax = xmax < PX(i) ? PX(i) : xmax;
   }
   if (xmin < 0 || xmax >= wx || ymin < 0 || ymax >= wy) {
   	*ierr = 1; /* clipping */
	return;
   }
   s1 = PX(n-1);
   t1 = PY(n-1);
   for (l=ymin; l<= ymax; l++) {
	nsect = 0;
	fwrd = 1;
	for (i=0; i<n; i++) {
	  s2 = PX(i);
	  t2 = PY(i);
	  if ((t1 < l &&  l <= t2) || (t1 >= l && l > t2)) {
		if (nsect > MAXSEC) {
			*ierr = 2; /* too complex */
			return;
		}
		x[nsect] = (s1+(s2-s1)*((l-t1)/(t2-t1)));
	  	nsect += 1;
	  }
	  s1 = s2;
	  t1 = t2;
 	}
	/* sort the intersections */
	for (i=1; i<nsect; i++)
		for (j=0; j<i; j++)
			if (x[j] > x[i]) {
				temp = x[j];
				x[j] = x[i];
				x[i] = temp;
			}
	if (fwrd) {
		for (i=0; i<nsect-1; i += 2)
			line(x[i],x[i+1],l);
		fwrd = 0;
	} else {
		for (i=nsect-1; i>0; i -= 2)
			line(x[i-1],x[i],l);
		fwrd = 1;
	}
   }
}

');

pp_def('polyfill',
	Pars => 'int [o,nc] im(m,n); float ps(two=2,np); int col()',
	Code => 'int ierr = 0, nerr;
	         threadloop %{
		   polyfill($P(im), $SIZE(m), $SIZE(n), $P(ps), $SIZE(np), $col(), &nerr);
		   ierr = ierr < nerr ? nerr : ierr;
		 %}
		 if (ierr) warn("errors during polygonfilling");
		 ',
	Doc => << 'EOD',
=for ref

fill the area inside the given polygon with a given colour

This function works inplace, i.e. modifies C<im>.

=cut
EOD
);

pp_add_exported('', 'polyfillv');
pp_addpm(<<'EOPM');

=head2 polyfillv

=for ref

return the (dataflown) area of an image within a polygon

=for example

  # increment intensity in area bounded by $poly
  $im->polyfillv($pol)++; # legal in perl >= 5.6
  # compute average intensity within area bounded by $poly
  $av = $im->polyfillv($poly)->avg;

=cut

sub PDL::polyfillv {
  my ($im, $ps) = @_;
  my $msk = zeroes(long,$im->dims);
  polyfill($msk, $ps, 1);
  return $im->where($msk == 1);
}
*polyfillv = \&PDL::polyfillv;

EOPM

pp_addhdr('#include "rotate.c"'."\n\n");
pp_add_exported('','rotnewsz');
pp_addxs('

void
rotnewsz(m,n,angle)
	int m
	int n
	float angle
	PPCODE:
	int newcols, newrows;

	if (getnewsize(m,n,angle,&newcols,&newrows) != 0)
		croak("wrong angle (should be between -90 and +90)");
	EXTEND(sp,2);
	PUSHs(sv_2mortal(newSVnv(newcols)));
	PUSHs(sv_2mortal(newSVnv(newrows)));
');

pp_def('rot2d',
	Pars => 'im(m,n); float angle(); bg(); int aa(); [o] om(p,q)',
	Code => 'int ierr;
		 if ((ierr = rotate($P(im),$P(om),$SIZE(m),$SIZE(n),$SIZE(p),
			$SIZE(q),$angle(),$bg(),$aa())) != 0)
			if (ierr == -1)
				croak("error during rotate, wrong angle");
			else
				croak("wrong output dims, did you set them?");
		',
	# ugly workaround since $SIZE(m) and $SIZE(n) are not initialized
	# when the redodimscode is called
	# need to fix this!
	RedoDimsCode => 'int ncols, nrows;
			if ($PDL(im)->ndims < 2)
				croak("need > 2d piddle");
			if (getnewsize($PDL(im)->dims[0],$PDL(im)->dims[1],
				$angle(), &ncols,
				&nrows) != 0) 
			   croak("error during rotate, wrong angle");
			/* printf("o: %d, p: %d\n",ncols,nrows); */
			$SIZE(p) = ncols;
			$SIZE(q) = nrows;',
	GenericTypes => [B],
	Doc => << 'EOD',
=for ref

rotate an image by given C<angle>

=for example

  # rotate by 10.5 degrees with antialiasing, set missing values to 7
  $rot = $im->rot2d(10.5,7,1);

This function rotates an image through an C<angle> between -90 and + 90
degrees. Uses/doesn't use antialiasing depending on the C<aa> flag.
Pixels outside the rotated image are set to C<bg>.

Code modified from pnmrotate (Copyright Jef Poskanzer) with an algorithm based
on "A Fast Algorithm for General  Raster  Rotation"  by  Alan Paeth,
Graphics Interface '86, pp. 77-81.

Use the C<rotnewsz> function to find out about the dimension of the
newly created image

  ($newcols,$newrows) = rotnewsz $oldn, $oldm, $angle;

EOD
);

pp_def('bilin2d',
    Pars => 'I(n,m); O(q,p)',
    Doc=><<'EOD',
=for ref

Bilineary maps the first piddle in the second. The
interpolated values are actually added to the second
piddle which is supposed to be larger than the first one.

=cut

EOD
,
    Code =>'
  int i,j,ii,jj,ii1,jj1,num;
  double x,y,dx,dy,y1,y2,y3,y4,t,u,sum;

  if ($SIZE(q)>=$SIZE(n) && $SIZE(p)>=$SIZE(m)) {
    threadloop %{
      dx = ((double) ($SIZE(n)-1)) / ($SIZE(q)-1);
      dy = ((double) ($SIZE(m)-1)) / ($SIZE(p)-1);
      for(i=0,x=0;i<$SIZE(q);i++,x+=dx) {
	for(j=0,y=0;j<$SIZE(p);j++,y+=dy) {
	  ii = (int) floor(x);
	  if (ii>=($SIZE(n)-1)) ii = $SIZE(n)-2;
	  jj = (int) floor(y);
	  if (jj>=($SIZE(m)-1)) jj = $SIZE(m)-2;
	  ii1 = ii+1;
	  jj1 = jj+1;
	  y1 = $I(n=>ii,m=>jj);
	  y2 = $I(n=>ii1,m=>jj);
	  y3 = $I(n=>ii1,m=>jj1);
	  y4 = $I(n=>ii,m=>jj1);
	  t = x-ii;
	  u = y-jj;
	  $O(q=>i,p=>j) += (1-t)*(1-u)*y1 + t*(1-u)*y2 + t*u*y3 + (1-t)*u*y4;
	}
      }
      %}
  }
  else { 
    barf("the second matrix must be greater than first! (bilin2d)");
  }
');

pp_def('rescale2d',
    Pars => 'I(n,m); O(q,p)',
    Doc=><<'EOD',
=for ref

The first piddle is rescaled to the dimensions of the second
(expandind or meaning values as needed) and then added to it.

=cut

EOD
,
    Code =>'
int ix,iy,ox,oy,i,j,lx,ly,cx,cy,xx,yy,num;
double kx,ky,temp;

ix = $SIZE(n);   
iy = $SIZE(m);   
ox = $SIZE(p);   
oy = $SIZE(q);   

if(ox >= ix && oy >= iy) {
  threadloop %{
    kx = ((double) (ox)) / (ix);
    ky = ((double) (oy)) / (iy);
    lx = 0;
    for(i=0;i<ix;i++) {
      ly = 0;
      for(j=0;j<iy;j++) {
	cx = rint((i+1)*kx)-1;
	cy = rint((j+1)*ky)-1;
	for(xx=lx;xx<=cx;xx++)
	  for(yy=ly;yy<=cy;yy++) {
/*	    fprintf(stderr,"i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	    $O(p=>xx,q=>yy) += $I(n=>j,m=>i);
	  }
	ly = cy + 1;
      }
      lx = cx + 1;
    }
  %}
}
else if(ox < ix && oy < iy) {
  threadloop %{
    kx = ((double) (ix)) / (ox);
    ky = ((double) (iy)) / (oy);
    lx = 0;
    for(i=0;i<ox;i++) {
      ly = 0;
      for(j=0;j<oy;j++) {
	cx = rint((i+1)*kx)-1;
	cy = rint((j+1)*ky)-1;
	temp = 0.0;
	num = 0;
	for(xx=lx;xx<=cx;xx++)
	  for(yy=ly;yy<=cy;yy++) {
/*	    fprintf(stderr,"i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	    temp += $I(n=>yy,m=>xx);
	    num++;
	  }
	$O(p=>i,q=>j) += temp/num;
	ly = cy + 1;
      }
      lx = cx + 1;
    }
  %}
}
else if(ox >= ix && oy < iy) {
  threadloop %{
    kx = ((double) (ox)) / (ix);
    ky = ((double) (iy)) / (oy);
    lx = 0;
    for(i=0;i<ix;i++) {
      ly = 0;
      for(j=0;j<oy;j++) {
	cx = rint((i+1)*kx)-1;
	cy = rint((j+1)*ky)-1;
	temp = 0.0;
	num = 0;
	for(yy=ly;yy<=cy;yy++) {
/*	  fprintf(stderr,"1 i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	    temp += $I(n=>yy,m=>i);
	  num++;
	}
	for(xx=lx;xx<=cx;xx++) {
/*	  fprintf(stderr,"2 i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	  $O(p=>xx,q=>j) += temp/num;
	}
	ly = cy + 1;
      }
      lx = cx + 1;
    }
  %}
}
else if(ox < ix && oy >= iy) {
  threadloop %{
    kx = ((double) (ix)) / (ox);
    ky = ((double) (oy)) / (iy);
    lx = 0;
    for(i=0;i<ox;i++) {
      ly = 0;
      for(j=0;j<iy;j++) {
	cx = rint((i+1)*kx)-1;
	cy = rint((j+1)*ky)-1;
	temp = 0.0;
	num = 0;
	for(xx=lx;xx<=cx;xx++) {
/*	  fprintf(stderr,"1 i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	    temp += $I(n=>j,m=>xx);
	  num++;
	}
	for(yy=ly;yy<=cy;yy++) {
/*	  fprintf(stderr,"2 i: %d, j: %d, xx: %d, yy: %d\n",i,j,xx,yy); */
	  $O(p=>i,q=>yy) += temp/num;
	}
	ly = cy + 1;
      }
      lx = cx + 1;
    }
  %}
}
else barf("I am not supposed to be here, please report the bug to <chri@infis.univ.ts.it>");
  ');

pp_addpm({At=>Bot},<<'EOD');

=head1 AUTHORS

Copyright (C) Karl Glazebrook 1997 with additions by Robin Williams
(rjrw@ast.leeds.ac.uk) and Tim Jeness (timj@jach.hawaii.edu).
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.

=cut

EOD

pp_done();

pp_addpm({At=>Top},<<'EOD');

=head1 NAME

PDL::Image2D - Miscellaneous 2D image processing functions


=head1 DESCRIPTION

  Miscellaneous 2D image processing functions - for want
  of anywhere else to put them

=head1 SYNOPSIS

 use PDL::Image2D;

=cut

EOD

pp_addhdr('

/* Fast Modulus with proper negative behaviour */

#define REALMOD(a,b) {while ((a)>=(b)) (a) -= (b); while ((a)<0) (a) += (b);}

/* Local quick-sort routine for doubles */

void pdl_lqsortD(double* xx, int a, int b) {
	
   int i,j;
	
   double t, median;
	
   i = a; j = b;
   median = xx[(i+j) / 2];
   do {
      while (xx[i] < median)
	 i++;
      while (median < xx[j])
	 j--;
      if (i <= j) {
	 t = xx[i]; xx[i] = xx[j]; xx[j] = t;
	 i++; j--;
      }
   } while (i <= j);
	
   if (a < j)
      pdl_lqsortD(xx,a,j);
   if (i < b)
      pdl_lqsortD(xx,i,b);
 }
            
');

pp_def('conv2d', Doc=><<'EOD',
=head2 conv2d

=for ref

2D convolution of an array with a kernel (smoothing)

=for usage

 $new = conv2d $old, $kernel, {OPTIONS}

=for example

  perldl> $smoothed = conv2d $image, ones(3,3), {Boundary => Reflect}

=for options

 Boundary - controls what values are assumed for the image when kernel 
            crosses its edge:
 	    => Default  - periodic boundary conditions (i.e. wrap around axis)
 	    => Reflect  - reflect at boundary
 	    => Truncate - truncate at boundary

=cut

EOD
        Pars => 'a(m,n); kern(p,q); [o]b(m,n);',
        OtherPars => 'int opt;',
        PMCode => '
        
sub PDL::conv2d {
   my $opt; $opt = pop @_ if ref($_[$#_]) eq \'HASH\';
   die \'Usage: conv2d( a(m,n), kern(p,q), [o]b(m,n), {Options} )\'
      if $#_<1 || $#_>2;
   my($a,$kern) = @_;
   my $c = $#_ == 2 ? $_[2] : PDL->null;
   &PDL::_conv2d_int($a,$kern,$c, 
	(!(defined $opt && exists $$opt{Boundary}))?0:
	(($$opt{Boundary} eq "Reflect") +
	2*($$opt{Boundary} eq "Truncate")));
   return $c;
}

',              
        Code => '
           int i,j, i1,j1, i2,j2, poff, qoff;
           double tmp;
           int opt = $COMP(opt); 
           int m_size = $COMP(__m_size); 
           int n_size = $COMP(__n_size);
           int p_size = $COMP(__p_size); 
           int q_size = $COMP(__q_size);
           int *mapi, *mapj;

           mapi = (int *) malloc((p_size+m_size)*sizeof(int));
           mapj = (int *) malloc((q_size+n_size)*sizeof(int));

           if ((mapi==NULL) || (mapj==NULL))
               barf("Out of Memory");
           
           poff = p_size/2; mapi += p_size-1;
           qoff = q_size/2; mapj += q_size-1;

	   for (i=1-p_size; i<m_size; i++) {
              i2 = i+poff;
              switch (opt) {
	case 1:      /* REFLECT */
                 if (i2<0) 
                    i2 = -i2;
                 else if (i2 >= m_size) 
                    i2 = 2*m_size-(i2+1);
                 break;
	case 2:      /* TRUNCATE */
                 if (i2<0 || i2 >= m_size) 
                    i2 = -1;
                 break;
	default:
                 REALMOD(i2,m_size);                         
               }
               mapi[i] = i2;
	   }
	   for (j=1-q_size; j<n_size; j++) {
              j2 = j+qoff;
              switch (opt) {
	case 1:      /* REFLECT */
                 if (j2<0) 
                    j2 = -j2;
                 else if (j2 >= n_size) 
                    j2 = 2*n_size-(j2+1);
                 break;
	case 2:      /* TRUNCATE */
                 if (j2<0 || j2>=n_size) 
                    j2 = -1;
                 break;
	default:
                 REALMOD(j2,n_size);                         
               }
               mapj[j] = j2;
	   }

           threadloop %{
           for(j=0; j<n_size; j++) { for(i=0; i<m_size; i++) { 
              tmp = 0; 
              for(j1=0; j1<q_size; j1++) {
                  j2 = mapj[j-j1]; 
                  
                  if (j2 >= 0) {
                     for(i1=0; i1<p_size; i1++) { 
                       i2 = mapi[i-i1];
                       if (i2 >= 0) 
                          tmp += $a(m=>i2,n=>j2) * $kern(p=>i1,q=>j1);
                     }
                  }                  
              }
              $b(m=>i,n=>j) = tmp;
           }} %}
	   free(mapj+1-q_size); free(mapi+1-p_size);
');


pp_def('med2d', Doc=> <<'EOD',

=head2 med2d

=for ref 

2D median-convolution of an array with a kernel (smoothing)

Note: only points in the kernel >0 are included in the median, other
points are weighted by the kernel value (medianing lots of zeroes
is rather pointless)

=for usage

 $new = med2d $old, $kernel, {OPTIONS}

=for example

  perldl> $smoothed = med2d $image, ones(3,3), {Boundary => Reflect}

=for options

 Boundary - controls what values are assumed for the image when kernel 
            crosses its edge:
 	    => Default  - periodic boundary conditions (i.e. wrap around axis)
 	    => Reflect  - reflect at boundary
 	    => Truncate - truncate at boundary

=cut

EOD
        Pars => 'a(m,n); kern(p,q); [o]b(m,n);',
        OtherPars => 'int opt;',
        PMCode => '
        
sub PDL::med2d {
   my $opt; $opt = pop @_ if ref($_[$#_]) eq \'HASH\';
   die \'Usage: med2d( a(m,n), kern(p,q), [o]b(m,n), {Options} )\'
      if $#_<1 || $#_>2;
   my($a,$kern) = @_;
   my $c = $#_ == 2 ? $_[2] : PDL->null;
   &PDL::_med2d_int($a,$kern,$c,
	(!(defined $opt && exists $opt->{Boundary}))?0:
	(($$opt{Boundary} eq "Reflect") +
	2*($$opt{Boundary} eq "Truncate")));
   return $c;
}

',     
        Code => '
           int i,j, i1,j1, i2,j2, poff, qoff,
           count;
           PDL_Double *tmp;
           PDL_Double kk;

           int opt = $COMP(opt); 
           int m_size = $COMP(__m_size); 
           int n_size = $COMP(__n_size);
           int p_size = $COMP(__p_size); 
           int q_size = $COMP(__q_size);
           int *mapi, *mapj;

           poff = p_size/2; qoff = q_size/2; 

           tmp = malloc(p_size*q_size*sizeof(PDL_Double));
           mapi = (int *) malloc((p_size+m_size)*sizeof(int));
           mapj = (int *) malloc((q_size+n_size)*sizeof(int));
           if ((tmp==NULL) || (mapi==NULL) || (mapj==NULL))
               barf("Out of Memory");
           
           poff = p_size/2; mapi += p_size-1;
           qoff = q_size/2; mapj += q_size-1;

	   for (i=1-p_size; i<m_size; i++) {
              i2 = i+poff;
              switch (opt) {
	case 1:      /* REFLECT */
                 if (i2<0) 
                    i2 = -i2;
                 else if (i2 >= m_size) 
                    i2 = 2*m_size-(i2+1);
                 break;
	case 2:      /* TRUNCATE */
                 if (i2<0 || i2 >= m_size) 
                    i2 = -1;
                 break;
	default:
                 REALMOD(i2,m_size);                         
               }
               mapi[i] = i2;
	   }
	   for (j=1-q_size; j<n_size; j++) {
              j2 = j+qoff;
              switch (opt) {
	case 1:      /* REFLECT */
                 if (j2<0) 
                    j2 = -j2;
                 else if (j2 >= n_size) 
                    j2 = 2*n_size-(j2+1);
                 break;
	case 2:      /* TRUNCATE */
                 if (j2<0 || j2>=n_size) 
                    j2 = -1;
                 break;
	default:
                 REALMOD(j2,n_size);                         
               }
               mapj[j] = j2;
	   }

           threadloop %{
           for(j=0; j<n_size; j++) { for(i=0; i<m_size; i++) { 
              count = 0;
              for(j1=0; j1<q_size; j1++) { 
                  j2 = mapj[j-j1]; 
                  
                  if (j2 >= 0) 
                     for(i1=0; i1<p_size; i1++) { 
                        i2 = mapi[i-i1]; 
                        if (i2 >= 0) {
                           kk = $kern(p=>i1,q=>j1);
                           if (kk>0) {                          
                              tmp[count++] = $a(m=>i2,n=>j2) * kk;
                           }
                        }          
              }}
              pdl_lqsortD(tmp,0,count-1);
              
              $b(m=>i,n=>j) = tmp[(count-1)/2];
           }} %}
           free(mapj+1-q_size); free(mapi+1-p_size); free(tmp);
');

pp_def('patch2d', Doc=><<'EOD',
=head2 patch2d

=for ref

patch bad pixels out of 2D images, 

=for usage

$patched = patch2d $data, $bad;

$bad is a 2D mask array where 1=bad pixel 0=good pixel. Pixels are replaced by the average
of their non-bad neighbours.

=cut

EOD
        Pars => 'a(m,n); int bad(m,n); [o]b(m,n);',
        Code => '
           int m_size, n_size,  i,j, i1,j1, i2,j2, norm;
           double tmp;

           m_size = $COMP(__m_size); n_size = $COMP(__n_size);

           for(j=0; j<n_size; j++) { for(i=0; i<m_size; i++) { 
              $b(m=>i,n=>j) = $a(m=>i,n=>j);
              if ($bad(m=>i,n=>j)==1) {
                 tmp = 0; norm=0;
                 for(j1=-1; j1<=1; j1++) { for(i1=-1; i1<=1; i1++) { 
                     i2 = i+i1; j2 = j+j1;                       
                     if (j2>0 && i2>0 && i2<m_size && j2<n_size && 
                        $bad(m=>i2,n=>j2)!=1)
                        tmp += $a(m=>i2,n=>j2); norm++;
                 }}
                 if (norm>0) {  /* Patch */
                    $b(m=>i,n=>j) = tmp/norm;
                 }

              } /* Next pixel */
           }}
');


pp_def('max2d_ind',Doc=><<'EOD',
=head2 max2d_ind

=for ref

Return value/position of maximum value in 2D image

Contributed by Tim Jeness

=cut

EOD

        Pars => 'a(m,n); [o]b(); int [o]c(); int[o]d();',
        Code => '
        double cur; int curind1; int curind2;
        curind1=0;
        curind2=0;
        loop(m) %{
           loop(n) %{
           if((!m && !n) || $a() > cur) {
                cur = $a(); curind1 = m; curind2 = n;
              }
           %}
        %}
        $b() = cur;
        $c() = curind1;
        $d() = curind2;
        ');
           
pp_def('centroid2d',Doc=><<'EOD',
=head2 centroid2d

=for ref

Refine a list of object positions in 2D image by centroiding in a box

$box is the full-width of the box, i.e. the window 
is +/- $box/2

=cut

EOD
	Pars => 'im(m,n); x(); y(); box(); [o]xcen(); [o]ycen();',
	Code => ' 
   int i,j,i1,i2,j1,j2,m_size,n_size;
   double sum,data,sumx,sumy;
  
   m_size = $SIZE(m); n_size = $SIZE(n);
    
   i1 = $x() - $box()/2; i1 = i1<0 ? 0 : i1;
   i2 = $x() + $box()/2; i1 = i1>=m_size ? m_size-1 : i1;
   j1 = $y() - $box()/2; j1 = j1<0 ? 0 : j1;
   j2 = $y() + $box()/2; j1 = j1>=n_size ? n_size-1 : j1;  
   
   sum = sumx = sumy = 0;
   for(j=j1; j<=j2; j++) { for(i=i1; i<=i2; i++) {
      data = $im(m=>i,n=>j);
      sum += data;
      sumx += data*i;
      sumy += data*j;
   }}
   $xcen() = sumx/sum;
   $ycen() = sumy/sum;	
'
);

pp_addhdr('

/* Add an equivalence to a list - used by pdl_cc8compt */

void AddEquiv ( PDL_Long* equiv, PDL_Long i, PDL_Long j) {

   PDL_Long k, tmp;

   if (i==j)
      return;

    k = j;
    do {
      k = equiv[k];
    } while ( k != j && k != i );

    if ( k == j ) {
       tmp = equiv[i];
       equiv[i] = equiv[j];
       equiv[j] = tmp;
    }
}

');


pp_def('cc8compt',Doc=>'
=for ref

Connected 8-component labeling of a binary image.

Connected 8-component labeling of 0,1 image - i.e. find seperate
segmented objects and fill object pixels with object number

=for example

perldl> $segmented = cc8compt($image>$threshold);

=cut

',
        Pars => 'a(m,n); [o]b(m,n);',
        Code => '

      PDL_Long i,j,k;
      PDL_Long newlabel;
      PDL_Long neighbour[4];
      PDL_Long nfound;
      PDL_Long pass,count,next,this;
      PDL_Long *equiv;
      PDL_Long i1,j1,i2;
      PDL_Long nx = $SIZE(m);
      PDL_Long ny = $SIZE(n);

      loop(n) %{ loop(m) %{ /* Copy */
         $b() = $a();
      %} %}

      /* 1st pass counts max possible compts, 2nd records equivalences
*/

      for (pass = 0; pass<2; pass++) {

      if (pass==1) {
         equiv = (PDL_Long*) malloc((newlabel+1)*sizeof(PDL_Long));
         if (equiv==(PDL_Long*)0)
            barf("Out of memory");
         for(i=0;i<=newlabel;i++)
             equiv[i]=i;
      }

      newlabel = 1; /* Running label */

      for(j=0; j<ny; j++) { for(i=0; i<nx; i++) { /* Loop over image
pixels */

            nfound = 0; /* Number of neighbour >0 */

            i1 = i-1; j1 = j-1; i2 = i+1;

            if ($b(m=>i, n=>j) > 0) { /* Check 4 neighbour already seen
*/

               if (i>0 && $b(m=>i1, n=>j)>0)
                   neighbour[nfound++] = $b(m=>i1, n=>j); /* Store label
of it */
               if (j>0 && $b(m=>i, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i, n=>j1);
               if (j>0 && i>0  && $b(m=>i1, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i1, n=>j1);
               if (j>0 && i<nx && $b(m=>i2, n=>j1)>0)
                   neighbour[nfound++] = $b(m=>i2, n=>j1);

               if (nfound==0)  { /* Assign new label */
                  $b(m=>i, n=>j) = newlabel++;
               }
               else {
                  $b(m=>i, n=>j) =  neighbour[0];
                  if (nfound>1 && pass == 1) {  /* Assign equivalents */
                      for(k=1; k<nfound; k++)
                         AddEquiv( equiv, (PDL_Long)$b(m=>i, n=>j),
neighbour[k] );
                  }
               }
            }

            else {  /* No label */

               $b(m=>i, n=>j) = 0;
            }

      }} /* End of image loop */

      } /* Passes */

      /* Replace each cycle by single label */

       count = 0;
       for (i = 1; i <= newlabel; i++)
         if ( i <= equiv[i] ) {
             count++;
             this = i;
             while ( equiv[this] != i ) {
               next = equiv[this];
               equiv[this] = count;
               this = next;
             }
          equiv[this] = count;
         }


      /* Now remove equivalences */

      for(j=0; j<ny; j++) { for(i=0; i<nx; i++) { /* Loop over image
pixels */
           $b(m=>i, n=>j)   = equiv[ (PDL_Long) $b(m=>i, n=>j)  ] ;
      }}

      free(equiv); /* Tidy */
');

        
pp_addpm({At=>Bot},<<'EOD');

=head1 AUTHORS

Copyright (C) Karl Glazebrook 1997 with additions by Robin Williams
(rjrw@ast.leeds.ac.uk) and Tim Jeness (timj@jach.hawaii.edu). Reproducing 
documentation from the pdl distribution in any way that does not include a
statement telling who the original authors are is forbidden.  Reproducing
and/or distributing the documentation  in any  form that  alters the text is
forbidden. 

=cut

EOD

pp_done();

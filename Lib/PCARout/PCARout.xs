
/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; /* Structure hold core C functions */
static int __pdl_debugging = 0;
SV* CoreSV;       /* Get's pointer to perl var holding core structure */

#include <math.h>
extern double pow(double,double); 
 extern double sqrt(double);
typedef struct pdl_pca_oja_struct {
		PDL_TRANS_START(3);
		pdl_thread  __thread;PDL_Long  __inc_data_ndims;PDL_Long  __inc_w_ndims;PDL_Long  __ndims_size;
		
		char __ddone; /* Dims done */
		} pdl_pca_oja_struct;

void pdl_pca_oja_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_pca_oja_struct *__privtrans = (pdl_pca_oja_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[3];__privtrans->__ndims_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 0 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in pca_oja:" "CANNOT CREATE PARAMETER eta");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in pca_oja:" "CANNOT CREATE PARAMETER data");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in pca_oja:" "CANNOT CREATE PARAMETER w");
					 {
 static char *__parnames[] = {"eta","data","w"};
		static int __realdims[] = {0,1,1};
		static char __funcname[] = "PDL::Lib::PCARout: pca_oja";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 0) {
			croak("Error in pca_oja:" "Too few dimensions for eta\n");
		}
	} else {croak("Error in pca_oja:" "Cannot create non-output argument eta!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 1) {
			croak("Error in pca_oja:" "Too few dimensions for data\n");
		}
	
		  if(__privtrans->__ndims_size == -1 || __privtrans->__ndims_size == 1) {
			__privtrans->__ndims_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__ndims_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_oja:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_oja:" "Cannot create non-output argument data!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 1) {
			croak("Error in pca_oja:" "Too few dimensions for w\n");
		}
	
		  if(__privtrans->__ndims_size == -1 || __privtrans->__ndims_size == 1) {
			__privtrans->__ndims_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__ndims_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_oja:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_oja:" "Cannot create non-output argument w!\n");}if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_data_ndims = 0; else
		 __privtrans->__inc_data_ndims = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_w_ndims = 0; else
		 __privtrans->__inc_w_ndims = PDL_REPRINC(__privtrans->pdls[2],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_pca_oja_copy(pdl_trans *__tr) {
                int __dim;
                pdl_pca_oja_struct *__privtrans = (pdl_pca_oja_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_pca_oja_struct *__copy
 			= malloc(sizeof(pdl_pca_oja_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_data_ndims=__copy->__inc_data_ndims;__privtrans->__inc_w_ndims=__copy->__inc_w_ndims;__copy->__ndims_size=__privtrans->__ndims_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_pca_oja_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_pca_oja_struct *__privtrans = (pdl_pca_oja_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_B
#define THISIS_B(a) a
	PDL_Byte *eta_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Byte *eta_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	
	PDL_Byte *data_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Byte *data_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));
	
	PDL_Byte *w_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Byte *w_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 eta_datap += __privtrans->__thread.offs[0];
data_datap += __privtrans->__thread.offs[1];
w_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{double sum=0;
	 double y = 0;
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	y += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */;
	 }} /* Close ndims */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
		register double tmp = (eta_datap)[0] /* ACCESS() */ * y * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */;
		tmp = ((w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ += tmp);
	 	sum += tmp * tmp;
	 }} /* Close ndims */
	 sum = sqrt(sum);
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	(w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ /= sum;
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 eta_datap += __privtrans->__thread.incs[0];
data_datap += __privtrans->__thread.incs[1];
w_datap += __privtrans->__thread.incs[2];

	 } eta_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
w_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} eta_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];w_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 eta_datap -= __privtrans->__thread.offs[0];
data_datap -= __privtrans->__thread.offs[1];
w_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_S: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_S
#define THISIS_S(a) a
	PDL_Short *eta_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Short *eta_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	
	PDL_Short *data_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Short *data_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));
	
	PDL_Short *w_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Short *w_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 eta_datap += __privtrans->__thread.offs[0];
data_datap += __privtrans->__thread.offs[1];
w_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{double sum=0;
	 double y = 0;
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	y += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */;
	 }} /* Close ndims */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
		register double tmp = (eta_datap)[0] /* ACCESS() */ * y * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */;
		tmp = ((w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ += tmp);
	 	sum += tmp * tmp;
	 }} /* Close ndims */
	 sum = sqrt(sum);
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	(w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ /= sum;
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 eta_datap += __privtrans->__thread.incs[0];
data_datap += __privtrans->__thread.incs[1];
w_datap += __privtrans->__thread.incs[2];

	 } eta_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
w_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} eta_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];w_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 eta_datap -= __privtrans->__thread.offs[0];
data_datap -= __privtrans->__thread.offs[1];
w_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_US: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_U
#define THISIS_U(a) a
	PDL_Ushort *eta_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Ushort *eta_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	
	PDL_Ushort *data_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Ushort *data_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));
	
	PDL_Ushort *w_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Ushort *w_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 eta_datap += __privtrans->__thread.offs[0];
data_datap += __privtrans->__thread.offs[1];
w_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{double sum=0;
	 double y = 0;
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	y += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */;
	 }} /* Close ndims */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
		register double tmp = (eta_datap)[0] /* ACCESS() */ * y * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */;
		tmp = ((w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ += tmp);
	 	sum += tmp * tmp;
	 }} /* Close ndims */
	 sum = sqrt(sum);
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	(w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ /= sum;
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 eta_datap += __privtrans->__thread.incs[0];
data_datap += __privtrans->__thread.incs[1];
w_datap += __privtrans->__thread.incs[2];

	 } eta_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
w_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} eta_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];w_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 eta_datap -= __privtrans->__thread.offs[0];
data_datap -= __privtrans->__thread.offs[1];
w_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_L: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_L
#define THISIS_L(a) a
	PDL_Long *eta_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Long *eta_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	
	PDL_Long *data_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Long *data_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	
	PDL_Long *w_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Long *w_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 eta_datap += __privtrans->__thread.offs[0];
data_datap += __privtrans->__thread.offs[1];
w_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{double sum=0;
	 double y = 0;
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	y += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */;
	 }} /* Close ndims */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
		register double tmp = (eta_datap)[0] /* ACCESS() */ * y * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */;
		tmp = ((w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ += tmp);
	 	sum += tmp * tmp;
	 }} /* Close ndims */
	 sum = sqrt(sum);
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	(w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ /= sum;
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 eta_datap += __privtrans->__thread.incs[0];
data_datap += __privtrans->__thread.incs[1];
w_datap += __privtrans->__thread.incs[2];

	 } eta_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
w_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} eta_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];w_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 eta_datap -= __privtrans->__thread.offs[0];
data_datap -= __privtrans->__thread.offs[1];
w_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *eta_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *eta_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	PDL_Float *data_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Float *data_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	
	PDL_Float *w_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *w_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 eta_datap += __privtrans->__thread.offs[0];
data_datap += __privtrans->__thread.offs[1];
w_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{double sum=0;
	 double y = 0;
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	y += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */;
	 }} /* Close ndims */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
		register double tmp = (eta_datap)[0] /* ACCESS() */ * y * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */;
		tmp = ((w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ += tmp);
	 	sum += tmp * tmp;
	 }} /* Close ndims */
	 sum = sqrt(sum);
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	(w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ /= sum;
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 eta_datap += __privtrans->__thread.incs[0];
data_datap += __privtrans->__thread.incs[1];
w_datap += __privtrans->__thread.incs[2];

	 } eta_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
w_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} eta_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];w_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 eta_datap -= __privtrans->__thread.offs[0];
data_datap -= __privtrans->__thread.offs[1];
w_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *eta_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *eta_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	PDL_Double *data_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Double *data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	
	PDL_Double *w_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *w_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 eta_datap += __privtrans->__thread.offs[0];
data_datap += __privtrans->__thread.offs[1];
w_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{double sum=0;
	 double y = 0;
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	y += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */;
	 }} /* Close ndims */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
		register double tmp = (eta_datap)[0] /* ACCESS() */ * y * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */;
		tmp = ((w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ += tmp);
	 	sum += tmp * tmp;
	 }} /* Close ndims */
	 sum = sqrt(sum);
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	(w_datap)[0+__privtrans->__inc_w_ndims*ndims] /* ACCESS() */ /= sum;
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 eta_datap += __privtrans->__thread.incs[0];
data_datap += __privtrans->__thread.incs[1];
w_datap += __privtrans->__thread.incs[2];

	 } eta_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
w_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} eta_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];w_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 eta_datap -= __privtrans->__thread.offs[0];
data_datap -= __privtrans->__thread.offs[1];
w_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_pca_oja_free(pdl_trans *__tr) {
                int __dim;
                pdl_pca_oja_struct *__privtrans = (pdl_pca_oja_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_pca_oja_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pca_oja_vtable = {
		0,0, 2, 3, pdl_pca_oja_vtable_flags, 
		pdl_pca_oja_redodims, pdl_pca_oja_readdata, NULL,
		pdl_pca_oja_free,NULL,NULL,pdl_pca_oja_copy,NULL,
		sizeof(pdl_pca_oja_struct),"pdl_pca_oja_vtable"
	 };

typedef struct pdl_pca_ojakarhunen_struct {
		PDL_TRANS_START(6);
		pdl_thread  __thread;PDL_Long  __inc_w_ndims;PDL_Long  __inc_w_nvals;PDL_Long  __inc_wtmp_ndims;PDL_Long  __inc_wtmp_nvals;PDL_Long  __inc_ytmp_nvals;PDL_Long  __inc_ytmpx_nvals0;PDL_Long  __inc_ytmpx_nvals1;PDL_Long  __inc_data_ndims;PDL_Long  __ndims_size;PDL_Long  __nvals_size;
		
		char __ddone; /* Dims done */
		} pdl_pca_ojakarhunen_struct;

void pdl_pca_ojakarhunen_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_pca_ojakarhunen_struct *__privtrans = (pdl_pca_ojakarhunen_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[6];__privtrans->__ndims_size = -1;
__privtrans->__nvals_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 0 ;
__creating[3] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]))
				&& 0 ;
__creating[4] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]))
				&& 0 ;
__creating[5] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]))
				&& 0 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in pca_ojakarhunen:" "CANNOT CREATE PARAMETER w");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in pca_ojakarhunen:" "CANNOT CREATE PARAMETER wtmp");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in pca_ojakarhunen:" "CANNOT CREATE PARAMETER ytmp");
					if((!__creating[3]) && __privtrans->pdls[3]->
				  ndims == 1 && __privtrans->pdls[3]->dims[0] == 0)
				   croak("Error in pca_ojakarhunen:" "CANNOT CREATE PARAMETER ytmpx");
					if((!__creating[4]) && __privtrans->pdls[4]->
				  ndims == 1 && __privtrans->pdls[4]->dims[0] == 0)
				   croak("Error in pca_ojakarhunen:" "CANNOT CREATE PARAMETER eta");
					if((!__creating[5]) && __privtrans->pdls[5]->
				  ndims == 1 && __privtrans->pdls[5]->dims[0] == 0)
				   croak("Error in pca_ojakarhunen:" "CANNOT CREATE PARAMETER data");
					 {
 static char *__parnames[] = {"w","wtmp","ytmp","ytmpx","eta","data"};
		static int __realdims[] = {2,2,1,2,0,1};
		static char __funcname[] = "PDL::Lib::PCARout: pca_ojakarhunen";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in pca_ojakarhunen:" "Too few dimensions for w\n");
		}
	
		  if(__privtrans->__ndims_size == -1 || __privtrans->__ndims_size == 1) {
			__privtrans->__ndims_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__ndims_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_ojakarhunen:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_ojakarhunen:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_ojakarhunen:" "Cannot create non-output argument w!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 2) {
			croak("Error in pca_ojakarhunen:" "Too few dimensions for wtmp\n");
		}
	
		  if(__privtrans->__ndims_size == -1 || __privtrans->__ndims_size == 1) {
			__privtrans->__ndims_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__ndims_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_ojakarhunen:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[1]))->dims[1];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[1]))->dims[1]) {
		  	if(((__privtrans->pdls[1]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_ojakarhunen:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_ojakarhunen:" "Cannot create non-output argument wtmp!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 1) {
			croak("Error in pca_ojakarhunen:" "Too few dimensions for ytmp\n");
		}
	
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_ojakarhunen:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_ojakarhunen:" "Cannot create non-output argument ytmp!\n");}if(!__creating[3]) {
		if(((__privtrans->pdls[3]))->ndims < 2) {
			croak("Error in pca_ojakarhunen:" "Too few dimensions for ytmpx\n");
		}
	
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[3]))->dims[0];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[3]))->dims[0]) {
		  	if(((__privtrans->pdls[3]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_ojakarhunen:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[3]))->dims[1];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[3]))->dims[1]) {
		  	if(((__privtrans->pdls[3]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_ojakarhunen:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_ojakarhunen:" "Cannot create non-output argument ytmpx!\n");}if(!__creating[4]) {
		if(((__privtrans->pdls[4]))->ndims < 0) {
			croak("Error in pca_ojakarhunen:" "Too few dimensions for eta\n");
		}
	} else {croak("Error in pca_ojakarhunen:" "Cannot create non-output argument eta!\n");}if(!__creating[5]) {
		if(((__privtrans->pdls[5]))->ndims < 1) {
			croak("Error in pca_ojakarhunen:" "Too few dimensions for data\n");
		}
	
		  if(__privtrans->__ndims_size == -1 || __privtrans->__ndims_size == 1) {
			__privtrans->__ndims_size = ((__privtrans->pdls[5]))->dims[0];
		  } else if(__privtrans->__ndims_size != ((__privtrans->pdls[5]))->dims[0]) {
		  	if(((__privtrans->pdls[5]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_ojakarhunen:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_ojakarhunen:" "Cannot create non-output argument data!\n");}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_w_ndims = 0; else
		 __privtrans->__inc_w_ndims = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_w_nvals = 0; else
		 __privtrans->__inc_w_nvals = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_wtmp_ndims = 0; else
		 __privtrans->__inc_wtmp_ndims = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_wtmp_nvals = 0; else
		 __privtrans->__inc_wtmp_nvals = PDL_REPRINC(__privtrans->pdls[1],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_ytmp_nvals = 0; else
		 __privtrans->__inc_ytmp_nvals = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_ytmpx_nvals0 = 0; else
		 __privtrans->__inc_ytmpx_nvals0 = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_ytmpx_nvals1 = 0; else
		 __privtrans->__inc_ytmpx_nvals1 = PDL_REPRINC(__privtrans->pdls[3],1);if(__privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_data_ndims = 0; else
		 __privtrans->__inc_data_ndims = PDL_REPRINC(__privtrans->pdls[5],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_pca_ojakarhunen_copy(pdl_trans *__tr) {
                int __dim;
                pdl_pca_ojakarhunen_struct *__privtrans = (pdl_pca_ojakarhunen_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_pca_ojakarhunen_struct *__copy
 			= malloc(sizeof(pdl_pca_ojakarhunen_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_w_ndims=__copy->__inc_w_ndims;__privtrans->__inc_w_nvals=__copy->__inc_w_nvals;__privtrans->__inc_wtmp_ndims=__copy->__inc_wtmp_ndims;__privtrans->__inc_wtmp_nvals=__copy->__inc_wtmp_nvals;__privtrans->__inc_ytmp_nvals=__copy->__inc_ytmp_nvals;__privtrans->__inc_ytmpx_nvals0=__copy->__inc_ytmpx_nvals0;__privtrans->__inc_ytmpx_nvals1=__copy->__inc_ytmpx_nvals1;__privtrans->__inc_data_ndims=__copy->__inc_data_ndims;__copy->__ndims_size=__privtrans->__ndims_size;__copy->__nvals_size=__privtrans->__nvals_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_pca_ojakarhunen_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_pca_ojakarhunen_struct *__privtrans = (pdl_pca_ojakarhunen_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_B
#define THISIS_B(a) a
	PDL_Byte *w_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Byte *w_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	
	PDL_Byte *wtmp_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Byte *wtmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));
	
	PDL_Byte *ytmp_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Byte *ytmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));
	
	PDL_Byte *ytmpx_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Byte *ytmpx_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));
	
	PDL_Byte *eta_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Byte *eta_physdatap = ((PDL_Byte *)((__privtrans->pdls[4])->data));
	
	PDL_Byte *data_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Byte *data_physdatap = ((PDL_Byte *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ -= (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals+__privtrans->__inc_ytmpx_nvals1*nvals] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close nvals */
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<=nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_S: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_S
#define THISIS_S(a) a
	PDL_Short *w_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Short *w_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	
	PDL_Short *wtmp_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Short *wtmp_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));
	
	PDL_Short *ytmp_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Short *ytmp_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));
	
	PDL_Short *ytmpx_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Short *ytmpx_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));
	
	PDL_Short *eta_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Short *eta_physdatap = ((PDL_Short *)((__privtrans->pdls[4])->data));
	
	PDL_Short *data_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Short *data_physdatap = ((PDL_Short *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ -= (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals+__privtrans->__inc_ytmpx_nvals1*nvals] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close nvals */
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<=nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_US: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_U
#define THISIS_U(a) a
	PDL_Ushort *w_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Ushort *w_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	
	PDL_Ushort *wtmp_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Ushort *wtmp_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));
	
	PDL_Ushort *ytmp_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Ushort *ytmp_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));
	
	PDL_Ushort *ytmpx_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Ushort *ytmpx_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));
	
	PDL_Ushort *eta_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Ushort *eta_physdatap = ((PDL_Ushort *)((__privtrans->pdls[4])->data));
	
	PDL_Ushort *data_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Ushort *data_physdatap = ((PDL_Ushort *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ -= (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals+__privtrans->__inc_ytmpx_nvals1*nvals] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close nvals */
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<=nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_L: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_L
#define THISIS_L(a) a
	PDL_Long *w_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Long *w_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	
	PDL_Long *wtmp_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Long *wtmp_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	
	PDL_Long *ytmp_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Long *ytmp_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));
	
	PDL_Long *ytmpx_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Long *ytmpx_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	
	PDL_Long *eta_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Long *eta_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));
	
	PDL_Long *data_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Long *data_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ -= (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals+__privtrans->__inc_ytmpx_nvals1*nvals] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close nvals */
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<=nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *w_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *w_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	PDL_Float *wtmp_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Float *wtmp_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	
	PDL_Float *ytmp_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *ytmp_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	PDL_Float *ytmpx_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Float *ytmpx_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));
	
	PDL_Float *eta_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Float *eta_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));
	
	PDL_Float *data_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Float *data_physdatap = ((PDL_Float *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ -= (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals+__privtrans->__inc_ytmpx_nvals1*nvals] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close nvals */
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<=nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *w_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *w_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	PDL_Double *wtmp_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Double *wtmp_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	
	PDL_Double *ytmp_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *ytmp_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	PDL_Double *ytmpx_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Double *ytmpx_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));
	
	PDL_Double *eta_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Double *eta_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));
	
	PDL_Double *data_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Double *data_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ -= (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals+__privtrans->__inc_ytmpx_nvals1*nvals] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close nvals */
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<=nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_pca_ojakarhunen_free(pdl_trans *__tr) {
                int __dim;
                pdl_pca_ojakarhunen_struct *__privtrans = (pdl_pca_ojakarhunen_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_pca_ojakarhunen_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pca_ojakarhunen_vtable = {
		0,0, 6, 6, pdl_pca_ojakarhunen_vtable_flags, 
		pdl_pca_ojakarhunen_redodims, pdl_pca_ojakarhunen_readdata, NULL,
		pdl_pca_ojakarhunen_free,NULL,NULL,pdl_pca_ojakarhunen_copy,NULL,
		sizeof(pdl_pca_ojakarhunen_struct),"pdl_pca_ojakarhunen_vtable"
	 };

typedef struct pdl_pca_sanger_struct {
		PDL_TRANS_START(6);
		pdl_thread  __thread;PDL_Long  __inc_w_ndims;PDL_Long  __inc_w_nvals;PDL_Long  __inc_wtmp_ndims;PDL_Long  __inc_wtmp_nvals;PDL_Long  __inc_ytmp_nvals;PDL_Long  __inc_ytmpx_nvals0;PDL_Long  __inc_ytmpx_nvals1;PDL_Long  __inc_data_ndims;PDL_Long  __ndims_size;PDL_Long  __nvals_size;
		
		char __ddone; /* Dims done */
		} pdl_pca_sanger_struct;

void pdl_pca_sanger_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_pca_sanger_struct *__privtrans = (pdl_pca_sanger_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[6];__privtrans->__ndims_size = -1;
__privtrans->__nvals_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 0 ;
__creating[3] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]))
				&& 0 ;
__creating[4] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]))
				&& 0 ;
__creating[5] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]))
				&& 0 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in pca_sanger:" "CANNOT CREATE PARAMETER w");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in pca_sanger:" "CANNOT CREATE PARAMETER wtmp");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in pca_sanger:" "CANNOT CREATE PARAMETER ytmp");
					if((!__creating[3]) && __privtrans->pdls[3]->
				  ndims == 1 && __privtrans->pdls[3]->dims[0] == 0)
				   croak("Error in pca_sanger:" "CANNOT CREATE PARAMETER ytmpx");
					if((!__creating[4]) && __privtrans->pdls[4]->
				  ndims == 1 && __privtrans->pdls[4]->dims[0] == 0)
				   croak("Error in pca_sanger:" "CANNOT CREATE PARAMETER eta");
					if((!__creating[5]) && __privtrans->pdls[5]->
				  ndims == 1 && __privtrans->pdls[5]->dims[0] == 0)
				   croak("Error in pca_sanger:" "CANNOT CREATE PARAMETER data");
					 {
 static char *__parnames[] = {"w","wtmp","ytmp","ytmpx","eta","data"};
		static int __realdims[] = {2,2,1,2,0,1};
		static char __funcname[] = "PDL::Lib::PCARout: pca_sanger";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in pca_sanger:" "Too few dimensions for w\n");
		}
	
		  if(__privtrans->__ndims_size == -1 || __privtrans->__ndims_size == 1) {
			__privtrans->__ndims_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__ndims_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_sanger:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_sanger:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_sanger:" "Cannot create non-output argument w!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 2) {
			croak("Error in pca_sanger:" "Too few dimensions for wtmp\n");
		}
	
		  if(__privtrans->__ndims_size == -1 || __privtrans->__ndims_size == 1) {
			__privtrans->__ndims_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__ndims_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_sanger:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[1]))->dims[1];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[1]))->dims[1]) {
		  	if(((__privtrans->pdls[1]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_sanger:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_sanger:" "Cannot create non-output argument wtmp!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 1) {
			croak("Error in pca_sanger:" "Too few dimensions for ytmp\n");
		}
	
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_sanger:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_sanger:" "Cannot create non-output argument ytmp!\n");}if(!__creating[3]) {
		if(((__privtrans->pdls[3]))->ndims < 2) {
			croak("Error in pca_sanger:" "Too few dimensions for ytmpx\n");
		}
	
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[3]))->dims[0];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[3]))->dims[0]) {
		  	if(((__privtrans->pdls[3]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_sanger:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nvals_size == -1 || __privtrans->__nvals_size == 1) {
			__privtrans->__nvals_size = ((__privtrans->pdls[3]))->dims[1];
		  } else if(__privtrans->__nvals_size != ((__privtrans->pdls[3]))->dims[1]) {
		  	if(((__privtrans->pdls[3]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_sanger:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_sanger:" "Cannot create non-output argument ytmpx!\n");}if(!__creating[4]) {
		if(((__privtrans->pdls[4]))->ndims < 0) {
			croak("Error in pca_sanger:" "Too few dimensions for eta\n");
		}
	} else {croak("Error in pca_sanger:" "Cannot create non-output argument eta!\n");}if(!__creating[5]) {
		if(((__privtrans->pdls[5]))->ndims < 1) {
			croak("Error in pca_sanger:" "Too few dimensions for data\n");
		}
	
		  if(__privtrans->__ndims_size == -1 || __privtrans->__ndims_size == 1) {
			__privtrans->__ndims_size = ((__privtrans->pdls[5]))->dims[0];
		  } else if(__privtrans->__ndims_size != ((__privtrans->pdls[5]))->dims[0]) {
		  	if(((__privtrans->pdls[5]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in pca_sanger:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in pca_sanger:" "Cannot create non-output argument data!\n");}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_w_ndims = 0; else
		 __privtrans->__inc_w_ndims = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_w_nvals = 0; else
		 __privtrans->__inc_w_nvals = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_wtmp_ndims = 0; else
		 __privtrans->__inc_wtmp_ndims = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_wtmp_nvals = 0; else
		 __privtrans->__inc_wtmp_nvals = PDL_REPRINC(__privtrans->pdls[1],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_ytmp_nvals = 0; else
		 __privtrans->__inc_ytmp_nvals = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_ytmpx_nvals0 = 0; else
		 __privtrans->__inc_ytmpx_nvals0 = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_ytmpx_nvals1 = 0; else
		 __privtrans->__inc_ytmpx_nvals1 = PDL_REPRINC(__privtrans->pdls[3],1);if(__privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_data_ndims = 0; else
		 __privtrans->__inc_data_ndims = PDL_REPRINC(__privtrans->pdls[5],0); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_pca_sanger_copy(pdl_trans *__tr) {
                int __dim;
                pdl_pca_sanger_struct *__privtrans = (pdl_pca_sanger_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_pca_sanger_struct *__copy
 			= malloc(sizeof(pdl_pca_sanger_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_w_ndims=__copy->__inc_w_ndims;__privtrans->__inc_w_nvals=__copy->__inc_w_nvals;__privtrans->__inc_wtmp_ndims=__copy->__inc_wtmp_ndims;__privtrans->__inc_wtmp_nvals=__copy->__inc_wtmp_nvals;__privtrans->__inc_ytmp_nvals=__copy->__inc_ytmp_nvals;__privtrans->__inc_ytmpx_nvals0=__copy->__inc_ytmpx_nvals0;__privtrans->__inc_ytmpx_nvals1=__copy->__inc_ytmpx_nvals1;__privtrans->__inc_data_ndims=__copy->__inc_data_ndims;__copy->__ndims_size=__privtrans->__ndims_size;__copy->__nvals_size=__privtrans->__nvals_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_pca_sanger_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_pca_sanger_struct *__privtrans = (pdl_pca_sanger_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_B
#define THISIS_B(a) a
	PDL_Byte *w_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Byte *w_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	
	PDL_Byte *wtmp_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Byte *wtmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));
	
	PDL_Byte *ytmp_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Byte *ytmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));
	
	PDL_Byte *ytmpx_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Byte *ytmpx_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));
	
	PDL_Byte *eta_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Byte *eta_physdatap = ((PDL_Byte *)((__privtrans->pdls[4])->data));
	
	PDL_Byte *data_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Byte *data_physdatap = ((PDL_Byte *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_S: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_S
#define THISIS_S(a) a
	PDL_Short *w_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Short *w_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	
	PDL_Short *wtmp_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Short *wtmp_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));
	
	PDL_Short *ytmp_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Short *ytmp_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));
	
	PDL_Short *ytmpx_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Short *ytmpx_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));
	
	PDL_Short *eta_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Short *eta_physdatap = ((PDL_Short *)((__privtrans->pdls[4])->data));
	
	PDL_Short *data_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Short *data_physdatap = ((PDL_Short *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_US: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_U
#define THISIS_U(a) a
	PDL_Ushort *w_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Ushort *w_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	
	PDL_Ushort *wtmp_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Ushort *wtmp_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));
	
	PDL_Ushort *ytmp_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Ushort *ytmp_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));
	
	PDL_Ushort *ytmpx_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Ushort *ytmpx_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));
	
	PDL_Ushort *eta_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Ushort *eta_physdatap = ((PDL_Ushort *)((__privtrans->pdls[4])->data));
	
	PDL_Ushort *data_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Ushort *data_physdatap = ((PDL_Ushort *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_L: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_L
#define THISIS_L(a) a
	PDL_Long *w_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Long *w_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	
	PDL_Long *wtmp_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Long *wtmp_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	
	PDL_Long *ytmp_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Long *ytmp_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));
	
	PDL_Long *ytmpx_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Long *ytmpx_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	
	PDL_Long *eta_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Long *eta_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));
	
	PDL_Long *data_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Long *data_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *w_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *w_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	PDL_Float *wtmp_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Float *wtmp_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	
	PDL_Float *ytmp_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *ytmp_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	PDL_Float *ytmpx_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Float *ytmpx_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));
	
	PDL_Float *eta_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Float *eta_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));
	
	PDL_Float *data_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Float *data_physdatap = ((PDL_Float *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *w_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *w_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	PDL_Double *wtmp_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Double *wtmp_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	
	PDL_Double *ytmp_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *ytmp_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	PDL_Double *ytmpx_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[3]))));
		PDL_Double *ytmpx_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));
	
	PDL_Double *eta_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[4]))));
		PDL_Double *eta_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));
	
	PDL_Double *data_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[5]))));
		PDL_Double *data_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 w_datap += __privtrans->__thread.offs[0];
wtmp_datap += __privtrans->__thread.offs[1];
ytmp_datap += __privtrans->__thread.offs[2];
ytmpx_datap += __privtrans->__thread.offs[3];
eta_datap += __privtrans->__thread.offs[4];
data_datap += __privtrans->__thread.offs[5];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {{/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ = 0; }} /* Close ndims */}} /* Close nvals */
	 {/* Open nvals */ long nvals; 
			for(nvals=0; nvals<__privtrans->__nvals_size; nvals++) {
		double sum=0;
	 	{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { sum += (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */ * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals] /* ACCESS() */; }} /* Close ndims */
		{/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) { (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals] /* ACCESS() */ += sum * (data_datap)[0+__privtrans->__inc_data_ndims*ndims] /* ACCESS() */; }} /* Close ndims */
		(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals] /* ACCESS() */ = sum;
	 }} /* Close nvals */
	 {/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) {
	 	(ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ = 
			(ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals1] /* ACCESS() */ * (ytmp_datap)[0+__privtrans->__inc_ytmp_nvals*nvals2] /* ACCESS() */;
	 }} /* Close nvals1 */}} /* Close nvals2 */
	 {/* Open ndims */ long ndims; 
			for(ndims=0; ndims<__privtrans->__ndims_size; ndims++) {
	 	
		{/* Open nvals1 */ long nvals1; 
			for(nvals1=0; nvals1<__privtrans->__nvals_size; nvals1++) {{/* Open nvals2 */ long nvals2; 
			for(nvals2=0; nvals2<__privtrans->__nvals_size; nvals2++) { 
		    if(nvals1<nvals2) continue;
		    (wtmp_datap)[0+__privtrans->__inc_wtmp_ndims*ndims+__privtrans->__inc_wtmp_nvals*nvals1] /* ACCESS() */ -= 
		       2 * (ytmpx_datap)[0+__privtrans->__inc_ytmpx_nvals0*nvals1+__privtrans->__inc_ytmpx_nvals1*nvals2] /* ACCESS() */ 
		         * (w_datap)[0+__privtrans->__inc_w_ndims*ndims+__privtrans->__inc_w_nvals*nvals2] /* ACCESS() */; 
		}} /* Close nvals1 */}} /* Close nvals2 */
	 }} /* Close ndims */
	 }	/* THREADLOOPEND */
	 w_datap += __privtrans->__thread.incs[0];
wtmp_datap += __privtrans->__thread.incs[1];
ytmp_datap += __privtrans->__thread.incs[2];
ytmpx_datap += __privtrans->__thread.incs[3];
eta_datap += __privtrans->__thread.incs[4];
data_datap += __privtrans->__thread.incs[5];

	 } w_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
wtmp_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
ytmp_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];
ytmpx_datap += __privtrans->__thread.incs[__tnpdls+3]
	     			     - __privtrans->__thread.incs[3] *
				       __privtrans->__thread.dims[0];
eta_datap += __privtrans->__thread.incs[__tnpdls+4]
	     			     - __privtrans->__thread.incs[4] *
				       __privtrans->__thread.dims[0];
data_datap += __privtrans->__thread.incs[__tnpdls+5]
	     			     - __privtrans->__thread.incs[5] *
				       __privtrans->__thread.dims[0];

	} w_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];wtmp_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];ytmp_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];ytmpx_datap -= __privtrans->__thread.incs[__tnpdls+3] *
     				  __privtrans->__thread.dims[1];eta_datap -= __privtrans->__thread.incs[__tnpdls+4] *
     				  __privtrans->__thread.dims[1];data_datap -= __privtrans->__thread.incs[__tnpdls+5] *
     				  __privtrans->__thread.dims[1];
 w_datap -= __privtrans->__thread.offs[0];
wtmp_datap -= __privtrans->__thread.offs[1];
ytmp_datap -= __privtrans->__thread.offs[2];
ytmpx_datap -= __privtrans->__thread.offs[3];
eta_datap -= __privtrans->__thread.offs[4];
data_datap -= __privtrans->__thread.offs[5];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_pca_sanger_free(pdl_trans *__tr) {
                int __dim;
                pdl_pca_sanger_struct *__privtrans = (pdl_pca_sanger_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_pca_sanger_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pca_sanger_vtable = {
		0,0, 6, 6, pdl_pca_sanger_vtable_flags, 
		pdl_pca_sanger_redodims, pdl_pca_sanger_readdata, NULL,
		pdl_pca_sanger_free,NULL,NULL,pdl_pca_sanger_copy,NULL,
		sizeof(pdl_pca_sanger_struct),"pdl_pca_sanger_vtable"
	 };

typedef struct pdl_transdiacumusum_struct {
		PDL_TRANS_START(3);
		pdl_thread  __thread;PDL_Long  __inc_data_n;PDL_Long  __inc_data_ndata;PDL_Long  __inc_trans_n;PDL_Long  __inc_trans_m;PDL_Long  __inc_cum_m;PDL_Long  __inc_cum_ncum;PDL_Long  __ndata_size;PDL_Long  __ncum_size;PDL_Long  __m_size;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_transdiacumusum_struct;

void pdl_transdiacumusum_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_transdiacumusum_struct *__privtrans = (pdl_transdiacumusum_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[3];__privtrans->__ndata_size = -1;
__privtrans->__ncum_size = -1;
__privtrans->__m_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 0 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in transdiacumusum:" "CANNOT CREATE PARAMETER data");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in transdiacumusum:" "CANNOT CREATE PARAMETER trans");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in transdiacumusum:" "CANNOT CREATE PARAMETER cum");
					 {
 static char *__parnames[] = {"data","trans","cum"};
		static int __realdims[] = {2,2,2};
		static char __funcname[] = "PDL::Lib::PCARout: transdiacumusum";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in transdiacumusum:" "Too few dimensions for data\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in transdiacumusum:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__ndata_size == -1 || __privtrans->__ndata_size == 1) {
			__privtrans->__ndata_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__ndata_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in transdiacumusum:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in transdiacumusum:" "Cannot create non-output argument data!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 2) {
			croak("Error in transdiacumusum:" "Too few dimensions for trans\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in transdiacumusum:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__m_size == -1 || __privtrans->__m_size == 1) {
			__privtrans->__m_size = ((__privtrans->pdls[1]))->dims[1];
		  } else if(__privtrans->__m_size != ((__privtrans->pdls[1]))->dims[1]) {
		  	if(((__privtrans->pdls[1]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in transdiacumusum:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in transdiacumusum:" "Cannot create non-output argument trans!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 2) {
			croak("Error in transdiacumusum:" "Too few dimensions for cum\n");
		}
	
		  if(__privtrans->__m_size == -1 || __privtrans->__m_size == 1) {
			__privtrans->__m_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__m_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in transdiacumusum:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__ncum_size == -1 || __privtrans->__ncum_size == 1) {
			__privtrans->__ncum_size = ((__privtrans->pdls[2]))->dims[1];
		  } else if(__privtrans->__ncum_size != ((__privtrans->pdls[2]))->dims[1]) {
		  	if(((__privtrans->pdls[2]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in transdiacumusum:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in transdiacumusum:" "Cannot create non-output argument cum!\n");}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_ndata = 0; else
		 __privtrans->__inc_data_ndata = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_trans_n = 0; else
		 __privtrans->__inc_trans_n = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_trans_m = 0; else
		 __privtrans->__inc_trans_m = PDL_REPRINC(__privtrans->pdls[1],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_cum_m = 0; else
		 __privtrans->__inc_cum_m = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_cum_ncum = 0; else
		 __privtrans->__inc_cum_ncum = PDL_REPRINC(__privtrans->pdls[2],1); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_transdiacumusum_copy(pdl_trans *__tr) {
                int __dim;
                pdl_transdiacumusum_struct *__privtrans = (pdl_transdiacumusum_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_transdiacumusum_struct *__copy
 			= malloc(sizeof(pdl_transdiacumusum_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_data_ndata=__copy->__inc_data_ndata;__privtrans->__inc_trans_n=__copy->__inc_trans_n;__privtrans->__inc_trans_m=__copy->__inc_trans_m;__privtrans->__inc_cum_m=__copy->__inc_cum_m;__privtrans->__inc_cum_ncum=__copy->__inc_cum_ncum;__copy->__ndata_size=__privtrans->__ndata_size;__copy->__ncum_size=__privtrans->__ncum_size;__copy->__m_size=__privtrans->__m_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_transdiacumusum_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_transdiacumusum_struct *__privtrans = (pdl_transdiacumusum_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_B
#define THISIS_B(a) a
	PDL_Byte *data_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Byte *data_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	
	PDL_Byte *trans_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Byte *trans_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));
	
	PDL_Byte *cum_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Byte *cum_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 data_datap += __privtrans->__thread.offs[0];
trans_datap += __privtrans->__thread.offs[1];
cum_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) { (cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = 0; }} /* Close m */}} /* Close ncum */
		{/* Open ndata */ long ndata; 
			for(ndata=0; ndata<__privtrans->__ndata_size; ndata++) {{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {
			double val=0; double mcum;
			{/* Open n */ long n; 
			for(n=0; n<__privtrans->__n_size; n++) {
				val += (data_datap)[0+__privtrans->__inc_data_n*n+__privtrans->__inc_data_ndata*ndata] /* ACCESS() */ * (trans_datap)[0+__privtrans->__inc_trans_n*n+__privtrans->__inc_trans_m*m] /* ACCESS() */;
			}} /* Close n */
			mcum = val;
			{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) {
				mcum *= val;
				(cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = mcum;
			}} /* Close ncum */
		}} /* Close ndata */}} /* Close m */
	}	/* THREADLOOPEND */
	 data_datap += __privtrans->__thread.incs[0];
trans_datap += __privtrans->__thread.incs[1];
cum_datap += __privtrans->__thread.incs[2];

	 } data_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
trans_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
cum_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} data_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];trans_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];cum_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 data_datap -= __privtrans->__thread.offs[0];
trans_datap -= __privtrans->__thread.offs[1];
cum_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_S: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_S
#define THISIS_S(a) a
	PDL_Short *data_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Short *data_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	
	PDL_Short *trans_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Short *trans_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));
	
	PDL_Short *cum_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Short *cum_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 data_datap += __privtrans->__thread.offs[0];
trans_datap += __privtrans->__thread.offs[1];
cum_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) { (cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = 0; }} /* Close m */}} /* Close ncum */
		{/* Open ndata */ long ndata; 
			for(ndata=0; ndata<__privtrans->__ndata_size; ndata++) {{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {
			double val=0; double mcum;
			{/* Open n */ long n; 
			for(n=0; n<__privtrans->__n_size; n++) {
				val += (data_datap)[0+__privtrans->__inc_data_n*n+__privtrans->__inc_data_ndata*ndata] /* ACCESS() */ * (trans_datap)[0+__privtrans->__inc_trans_n*n+__privtrans->__inc_trans_m*m] /* ACCESS() */;
			}} /* Close n */
			mcum = val;
			{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) {
				mcum *= val;
				(cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = mcum;
			}} /* Close ncum */
		}} /* Close ndata */}} /* Close m */
	}	/* THREADLOOPEND */
	 data_datap += __privtrans->__thread.incs[0];
trans_datap += __privtrans->__thread.incs[1];
cum_datap += __privtrans->__thread.incs[2];

	 } data_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
trans_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
cum_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} data_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];trans_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];cum_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 data_datap -= __privtrans->__thread.offs[0];
trans_datap -= __privtrans->__thread.offs[1];
cum_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_US: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_U
#define THISIS_U(a) a
	PDL_Ushort *data_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Ushort *data_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	
	PDL_Ushort *trans_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Ushort *trans_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));
	
	PDL_Ushort *cum_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Ushort *cum_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 data_datap += __privtrans->__thread.offs[0];
trans_datap += __privtrans->__thread.offs[1];
cum_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) { (cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = 0; }} /* Close m */}} /* Close ncum */
		{/* Open ndata */ long ndata; 
			for(ndata=0; ndata<__privtrans->__ndata_size; ndata++) {{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {
			double val=0; double mcum;
			{/* Open n */ long n; 
			for(n=0; n<__privtrans->__n_size; n++) {
				val += (data_datap)[0+__privtrans->__inc_data_n*n+__privtrans->__inc_data_ndata*ndata] /* ACCESS() */ * (trans_datap)[0+__privtrans->__inc_trans_n*n+__privtrans->__inc_trans_m*m] /* ACCESS() */;
			}} /* Close n */
			mcum = val;
			{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) {
				mcum *= val;
				(cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = mcum;
			}} /* Close ncum */
		}} /* Close ndata */}} /* Close m */
	}	/* THREADLOOPEND */
	 data_datap += __privtrans->__thread.incs[0];
trans_datap += __privtrans->__thread.incs[1];
cum_datap += __privtrans->__thread.incs[2];

	 } data_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
trans_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
cum_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} data_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];trans_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];cum_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 data_datap -= __privtrans->__thread.offs[0];
trans_datap -= __privtrans->__thread.offs[1];
cum_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_L: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_L
#define THISIS_L(a) a
	PDL_Long *data_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Long *data_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	
	PDL_Long *trans_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Long *trans_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	
	PDL_Long *cum_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Long *cum_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 data_datap += __privtrans->__thread.offs[0];
trans_datap += __privtrans->__thread.offs[1];
cum_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) { (cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = 0; }} /* Close m */}} /* Close ncum */
		{/* Open ndata */ long ndata; 
			for(ndata=0; ndata<__privtrans->__ndata_size; ndata++) {{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {
			double val=0; double mcum;
			{/* Open n */ long n; 
			for(n=0; n<__privtrans->__n_size; n++) {
				val += (data_datap)[0+__privtrans->__inc_data_n*n+__privtrans->__inc_data_ndata*ndata] /* ACCESS() */ * (trans_datap)[0+__privtrans->__inc_trans_n*n+__privtrans->__inc_trans_m*m] /* ACCESS() */;
			}} /* Close n */
			mcum = val;
			{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) {
				mcum *= val;
				(cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = mcum;
			}} /* Close ncum */
		}} /* Close ndata */}} /* Close m */
	}	/* THREADLOOPEND */
	 data_datap += __privtrans->__thread.incs[0];
trans_datap += __privtrans->__thread.incs[1];
cum_datap += __privtrans->__thread.incs[2];

	 } data_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
trans_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
cum_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} data_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];trans_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];cum_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 data_datap -= __privtrans->__thread.offs[0];
trans_datap -= __privtrans->__thread.offs[1];
cum_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *data_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *data_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	PDL_Float *trans_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Float *trans_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	
	PDL_Float *cum_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *cum_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 data_datap += __privtrans->__thread.offs[0];
trans_datap += __privtrans->__thread.offs[1];
cum_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) { (cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = 0; }} /* Close m */}} /* Close ncum */
		{/* Open ndata */ long ndata; 
			for(ndata=0; ndata<__privtrans->__ndata_size; ndata++) {{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {
			double val=0; double mcum;
			{/* Open n */ long n; 
			for(n=0; n<__privtrans->__n_size; n++) {
				val += (data_datap)[0+__privtrans->__inc_data_n*n+__privtrans->__inc_data_ndata*ndata] /* ACCESS() */ * (trans_datap)[0+__privtrans->__inc_trans_n*n+__privtrans->__inc_trans_m*m] /* ACCESS() */;
			}} /* Close n */
			mcum = val;
			{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) {
				mcum *= val;
				(cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = mcum;
			}} /* Close ncum */
		}} /* Close ndata */}} /* Close m */
	}	/* THREADLOOPEND */
	 data_datap += __privtrans->__thread.incs[0];
trans_datap += __privtrans->__thread.incs[1];
cum_datap += __privtrans->__thread.incs[2];

	 } data_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
trans_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
cum_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} data_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];trans_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];cum_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 data_datap -= __privtrans->__thread.offs[0];
trans_datap -= __privtrans->__thread.offs[1];
cum_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *data_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	PDL_Double *trans_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Double *trans_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	
	PDL_Double *cum_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *cum_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 data_datap += __privtrans->__thread.offs[0];
trans_datap += __privtrans->__thread.offs[1];
cum_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) { (cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = 0; }} /* Close m */}} /* Close ncum */
		{/* Open ndata */ long ndata; 
			for(ndata=0; ndata<__privtrans->__ndata_size; ndata++) {{/* Open m */ long m; 
			for(m=0; m<__privtrans->__m_size; m++) {
			double val=0; double mcum;
			{/* Open n */ long n; 
			for(n=0; n<__privtrans->__n_size; n++) {
				val += (data_datap)[0+__privtrans->__inc_data_n*n+__privtrans->__inc_data_ndata*ndata] /* ACCESS() */ * (trans_datap)[0+__privtrans->__inc_trans_n*n+__privtrans->__inc_trans_m*m] /* ACCESS() */;
			}} /* Close n */
			mcum = val;
			{/* Open ncum */ long ncum; 
			for(ncum=0; ncum<__privtrans->__ncum_size; ncum++) {
				mcum *= val;
				(cum_datap)[0+__privtrans->__inc_cum_m*m+__privtrans->__inc_cum_ncum*ncum] /* ACCESS() */ = mcum;
			}} /* Close ncum */
		}} /* Close ndata */}} /* Close m */
	}	/* THREADLOOPEND */
	 data_datap += __privtrans->__thread.incs[0];
trans_datap += __privtrans->__thread.incs[1];
cum_datap += __privtrans->__thread.incs[2];

	 } data_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
trans_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
cum_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} data_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];trans_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];cum_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 data_datap -= __privtrans->__thread.offs[0];
trans_datap -= __privtrans->__thread.offs[1];
cum_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_transdiacumusum_free(pdl_trans *__tr) {
                int __dim;
                pdl_transdiacumusum_struct *__privtrans = (pdl_transdiacumusum_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_transdiacumusum_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_transdiacumusum_vtable = {
		0,0, 3, 3, pdl_transdiacumusum_vtable_flags, 
		pdl_transdiacumusum_redodims, pdl_transdiacumusum_readdata, NULL,
		pdl_transdiacumusum_free,NULL,NULL,pdl_transdiacumusum_copy,NULL,
		sizeof(pdl_transdiacumusum_struct),"pdl_transdiacumusum_vtable"
	 };

typedef struct pdl_vec2asym_struct {
		PDL_TRANS_START(2);
		pdl_thread  __thread;PDL_Long  __inc_v_k;PDL_Long  __inc_m_n0;PDL_Long  __inc_m_n1;PDL_Long  __k_size;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_vec2asym_struct;

void pdl_vec2asym_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_vec2asym_struct *__privtrans = (pdl_vec2asym_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[2];__privtrans->__k_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in vec2asym:" "CANNOT CREATE PARAMETER v");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in vec2asym:" "CANNOT CREATE PARAMETER m");
					 {
 static char *__parnames[] = {"v","m"};
		static int __realdims[] = {1,2};
		static char __funcname[] = "PDL::Lib::PCARout: vec2asym";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 1) {
			croak("Error in vec2asym:" "Too few dimensions for v\n");
		}
	
		  if(__privtrans->__k_size == -1 || __privtrans->__k_size == 1) {
			__privtrans->__k_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__k_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in vec2asym:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in vec2asym:" "Cannot create non-output argument v!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 2) {
			croak("Error in vec2asym:" "Too few dimensions for m\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in vec2asym:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
		  	if(((__privtrans->pdls[1]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in vec2asym:" "Wrong dims\n");
			}
		  }
		} else {int dims[3]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,1,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_v_k = 0; else
		 __privtrans->__inc_v_k = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_m_n0 = 0; else
		 __privtrans->__inc_m_n0 = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_m_n1 = 0; else
		 __privtrans->__inc_m_n1 = PDL_REPRINC(__privtrans->pdls[1],1); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_vec2asym_copy(pdl_trans *__tr) {
                int __dim;
                pdl_vec2asym_struct *__privtrans = (pdl_vec2asym_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_vec2asym_struct *__copy
 			= malloc(sizeof(pdl_vec2asym_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_v_k=__copy->__inc_v_k;__privtrans->__inc_m_n0=__copy->__inc_m_n0;__privtrans->__inc_m_n1=__copy->__inc_m_n1;__copy->__k_size=__privtrans->__k_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_vec2asym_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_vec2asym_struct *__privtrans = (pdl_vec2asym_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_B
#define THISIS_B(a) a
	PDL_Byte *v_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Byte *v_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	
	PDL_Byte *m_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Byte *m_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
m_datap += __privtrans->__thread.offs[1];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int a,b; int wk;
		if(__privtrans->__k_size < __privtrans->__n_size*(__privtrans->__n_size-1)/2) {
			croak("Error in vec2asym:" "Vec2asym: too few pars");
		}
		wk=0;
		for(a = 0; a<__privtrans->__n_size; a++) {
			(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*a] /* ACCESS() */ = 0;
			for(b = 0; b < a; b++) {
				(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*b] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				(m_datap)[0+__privtrans->__inc_m_n0*b+__privtrans->__inc_m_n1*a] /* ACCESS() */ = -(v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				wk ++;
			}
		}
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
m_datap += __privtrans->__thread.incs[1];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
m_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];m_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
m_datap -= __privtrans->__thread.offs[1];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_S: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_S
#define THISIS_S(a) a
	PDL_Short *v_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Short *v_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	
	PDL_Short *m_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Short *m_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
m_datap += __privtrans->__thread.offs[1];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int a,b; int wk;
		if(__privtrans->__k_size < __privtrans->__n_size*(__privtrans->__n_size-1)/2) {
			croak("Error in vec2asym:" "Vec2asym: too few pars");
		}
		wk=0;
		for(a = 0; a<__privtrans->__n_size; a++) {
			(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*a] /* ACCESS() */ = 0;
			for(b = 0; b < a; b++) {
				(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*b] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				(m_datap)[0+__privtrans->__inc_m_n0*b+__privtrans->__inc_m_n1*a] /* ACCESS() */ = -(v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				wk ++;
			}
		}
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
m_datap += __privtrans->__thread.incs[1];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
m_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];m_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
m_datap -= __privtrans->__thread.offs[1];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_US: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_U
#define THISIS_U(a) a
	PDL_Ushort *v_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Ushort *v_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	
	PDL_Ushort *m_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Ushort *m_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
m_datap += __privtrans->__thread.offs[1];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int a,b; int wk;
		if(__privtrans->__k_size < __privtrans->__n_size*(__privtrans->__n_size-1)/2) {
			croak("Error in vec2asym:" "Vec2asym: too few pars");
		}
		wk=0;
		for(a = 0; a<__privtrans->__n_size; a++) {
			(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*a] /* ACCESS() */ = 0;
			for(b = 0; b < a; b++) {
				(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*b] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				(m_datap)[0+__privtrans->__inc_m_n0*b+__privtrans->__inc_m_n1*a] /* ACCESS() */ = -(v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				wk ++;
			}
		}
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
m_datap += __privtrans->__thread.incs[1];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
m_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];m_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
m_datap -= __privtrans->__thread.offs[1];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_L: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_L
#define THISIS_L(a) a
	PDL_Long *v_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Long *v_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	
	PDL_Long *m_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Long *m_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
m_datap += __privtrans->__thread.offs[1];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int a,b; int wk;
		if(__privtrans->__k_size < __privtrans->__n_size*(__privtrans->__n_size-1)/2) {
			croak("Error in vec2asym:" "Vec2asym: too few pars");
		}
		wk=0;
		for(a = 0; a<__privtrans->__n_size; a++) {
			(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*a] /* ACCESS() */ = 0;
			for(b = 0; b < a; b++) {
				(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*b] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				(m_datap)[0+__privtrans->__inc_m_n0*b+__privtrans->__inc_m_n1*a] /* ACCESS() */ = -(v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				wk ++;
			}
		}
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
m_datap += __privtrans->__thread.incs[1];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
m_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];m_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
m_datap -= __privtrans->__thread.offs[1];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *v_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *v_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	PDL_Float *m_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Float *m_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
m_datap += __privtrans->__thread.offs[1];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int a,b; int wk;
		if(__privtrans->__k_size < __privtrans->__n_size*(__privtrans->__n_size-1)/2) {
			croak("Error in vec2asym:" "Vec2asym: too few pars");
		}
		wk=0;
		for(a = 0; a<__privtrans->__n_size; a++) {
			(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*a] /* ACCESS() */ = 0;
			for(b = 0; b < a; b++) {
				(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*b] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				(m_datap)[0+__privtrans->__inc_m_n0*b+__privtrans->__inc_m_n1*a] /* ACCESS() */ = -(v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				wk ++;
			}
		}
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
m_datap += __privtrans->__thread.incs[1];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
m_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];m_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
m_datap -= __privtrans->__thread.offs[1];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *v_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *v_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	PDL_Double *m_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Double *m_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
m_datap += __privtrans->__thread.offs[1];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int a,b; int wk;
		if(__privtrans->__k_size < __privtrans->__n_size*(__privtrans->__n_size-1)/2) {
			croak("Error in vec2asym:" "Vec2asym: too few pars");
		}
		wk=0;
		for(a = 0; a<__privtrans->__n_size; a++) {
			(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*a] /* ACCESS() */ = 0;
			for(b = 0; b < a; b++) {
				(m_datap)[0+__privtrans->__inc_m_n0*a+__privtrans->__inc_m_n1*b] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				(m_datap)[0+__privtrans->__inc_m_n0*b+__privtrans->__inc_m_n1*a] /* ACCESS() */ = -(v_datap)[0+__privtrans->__inc_v_k*wk] /* ACCESS() */;
				wk ++;
			}
		}
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
m_datap += __privtrans->__thread.incs[1];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
m_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];m_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
m_datap -= __privtrans->__thread.offs[1];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_vec2asym_free(pdl_trans *__tr) {
                int __dim;
                pdl_vec2asym_struct *__privtrans = (pdl_vec2asym_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_vec2asym_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_vec2asym_vtable = {
		0,0, 1, 2, pdl_vec2asym_vtable_flags, 
		pdl_vec2asym_redodims, pdl_vec2asym_readdata, NULL,
		pdl_vec2asym_free,NULL,NULL,pdl_vec2asym_copy,NULL,
		sizeof(pdl_vec2asym_struct),"pdl_vec2asym_vtable"
	 };

typedef struct pdl_vec2lu_struct {
		PDL_TRANS_START(3);
		pdl_thread  __thread;PDL_Long  __inc_v_k;PDL_Long  __inc_l_n0;PDL_Long  __inc_l_n1;PDL_Long  __inc_u_n0;PDL_Long  __inc_u_n1;PDL_Long  __k_size;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_vec2lu_struct;

void pdl_vec2lu_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_vec2lu_struct *__privtrans = (pdl_vec2lu_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[3];__privtrans->__k_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 1 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in vec2lu:" "CANNOT CREATE PARAMETER v");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in vec2lu:" "CANNOT CREATE PARAMETER l");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in vec2lu:" "CANNOT CREATE PARAMETER u");
					 {
 static char *__parnames[] = {"v","l","u"};
		static int __realdims[] = {1,2,2};
		static char __funcname[] = "PDL::Lib::PCARout: vec2lu";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 1) {
			croak("Error in vec2lu:" "Too few dimensions for v\n");
		}
	
		  if(__privtrans->__k_size == -1 || __privtrans->__k_size == 1) {
			__privtrans->__k_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__k_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in vec2lu:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in vec2lu:" "Cannot create non-output argument v!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 2) {
			croak("Error in vec2lu:" "Too few dimensions for l\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in vec2lu:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
		  	if(((__privtrans->pdls[1]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in vec2lu:" "Wrong dims\n");
			}
		  }
		} else {int dims[3]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,1,dims);
}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 2) {
			croak("Error in vec2lu:" "Too few dimensions for u\n");
		}
	
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in vec2lu:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__n_size == -1 || __privtrans->__n_size == 1) {
			__privtrans->__n_size = ((__privtrans->pdls[2]))->dims[1];
		  } else if(__privtrans->__n_size != ((__privtrans->pdls[2]))->dims[1]) {
		  	if(((__privtrans->pdls[2]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in vec2lu:" "Wrong dims\n");
			}
		  }
		} else {int dims[3]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_v_k = 0; else
		 __privtrans->__inc_v_k = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_l_n0 = 0; else
		 __privtrans->__inc_l_n0 = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_l_n1 = 0; else
		 __privtrans->__inc_l_n1 = PDL_REPRINC(__privtrans->pdls[1],1);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_u_n0 = 0; else
		 __privtrans->__inc_u_n0 = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_u_n1 = 0; else
		 __privtrans->__inc_u_n1 = PDL_REPRINC(__privtrans->pdls[2],1); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_vec2lu_copy(pdl_trans *__tr) {
                int __dim;
                pdl_vec2lu_struct *__privtrans = (pdl_vec2lu_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_vec2lu_struct *__copy
 			= malloc(sizeof(pdl_vec2lu_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_v_k=__copy->__inc_v_k;__privtrans->__inc_l_n0=__copy->__inc_l_n0;__privtrans->__inc_l_n1=__copy->__inc_l_n1;__privtrans->__inc_u_n0=__copy->__inc_u_n0;__privtrans->__inc_u_n1=__copy->__inc_u_n1;__copy->__k_size=__privtrans->__k_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_vec2lu_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_vec2lu_struct *__privtrans = (pdl_vec2lu_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_B
#define THISIS_B(a) a
	PDL_Byte *v_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Byte *v_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	
	PDL_Byte *l_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Byte *l_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));
	
	PDL_Byte *u_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Byte *u_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
l_datap += __privtrans->__thread.offs[1];
u_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int ind=0;
		if(__privtrans->__k_size != __privtrans->__n_size * (__privtrans->__n_size-1)) {
			croak("Error in vec2lu:" "Invalid sizes to vec2lu");
		}
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 > n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 1;
			else {
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 < n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 1;
			else {
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
				
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
l_datap += __privtrans->__thread.incs[1];
u_datap += __privtrans->__thread.incs[2];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
l_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
u_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];l_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];u_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
l_datap -= __privtrans->__thread.offs[1];
u_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_S: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_S
#define THISIS_S(a) a
	PDL_Short *v_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Short *v_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	
	PDL_Short *l_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Short *l_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));
	
	PDL_Short *u_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Short *u_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
l_datap += __privtrans->__thread.offs[1];
u_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int ind=0;
		if(__privtrans->__k_size != __privtrans->__n_size * (__privtrans->__n_size-1)) {
			croak("Error in vec2lu:" "Invalid sizes to vec2lu");
		}
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 > n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 1;
			else {
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 < n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 1;
			else {
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
				
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
l_datap += __privtrans->__thread.incs[1];
u_datap += __privtrans->__thread.incs[2];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
l_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
u_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];l_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];u_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
l_datap -= __privtrans->__thread.offs[1];
u_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_US: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_U
#define THISIS_U(a) a
	PDL_Ushort *v_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Ushort *v_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	
	PDL_Ushort *l_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Ushort *l_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));
	
	PDL_Ushort *u_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Ushort *u_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
l_datap += __privtrans->__thread.offs[1];
u_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int ind=0;
		if(__privtrans->__k_size != __privtrans->__n_size * (__privtrans->__n_size-1)) {
			croak("Error in vec2lu:" "Invalid sizes to vec2lu");
		}
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 > n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 1;
			else {
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 < n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 1;
			else {
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
				
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
l_datap += __privtrans->__thread.incs[1];
u_datap += __privtrans->__thread.incs[2];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
l_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
u_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];l_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];u_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
l_datap -= __privtrans->__thread.offs[1];
u_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_L: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_L
#define THISIS_L(a) a
	PDL_Long *v_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Long *v_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	
	PDL_Long *l_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Long *l_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	
	PDL_Long *u_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Long *u_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
l_datap += __privtrans->__thread.offs[1];
u_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int ind=0;
		if(__privtrans->__k_size != __privtrans->__n_size * (__privtrans->__n_size-1)) {
			croak("Error in vec2lu:" "Invalid sizes to vec2lu");
		}
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 > n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 1;
			else {
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 < n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 1;
			else {
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
				
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
l_datap += __privtrans->__thread.incs[1];
u_datap += __privtrans->__thread.incs[2];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
l_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
u_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];l_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];u_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
l_datap -= __privtrans->__thread.offs[1];
u_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *v_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *v_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	PDL_Float *l_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Float *l_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	
	PDL_Float *u_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *u_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
l_datap += __privtrans->__thread.offs[1];
u_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int ind=0;
		if(__privtrans->__k_size != __privtrans->__n_size * (__privtrans->__n_size-1)) {
			croak("Error in vec2lu:" "Invalid sizes to vec2lu");
		}
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 > n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 1;
			else {
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 < n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 1;
			else {
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
				
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
l_datap += __privtrans->__thread.incs[1];
u_datap += __privtrans->__thread.incs[2];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
l_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
u_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];l_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];u_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
l_datap -= __privtrans->__thread.offs[1];
u_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *v_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *v_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	PDL_Double *l_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[1]))));
		PDL_Double *l_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	
	PDL_Double *u_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *u_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 v_datap += __privtrans->__thread.offs[0];
l_datap += __privtrans->__thread.offs[1];
u_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int ind=0;
		if(__privtrans->__k_size != __privtrans->__n_size * (__privtrans->__n_size-1)) {
			croak("Error in vec2lu:" "Invalid sizes to vec2lu");
		}
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 > n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = 1;
			else {
				(l_datap)[0+__privtrans->__inc_l_n0*n1+__privtrans->__inc_l_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
		{/* Open n1 */ long n1; 
			for(n1=0; n1<__privtrans->__n_size; n1++) {{/* Open n2 */ long n2; 
			for(n2=0; n2<__privtrans->__n_size; n2++) {
			if(n1 < n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 0;
			else if(n1==n2)
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = 1;
			else {
				(u_datap)[0+__privtrans->__inc_u_n0*n1+__privtrans->__inc_u_n1*n2] /* ACCESS() */ = (v_datap)[0+__privtrans->__inc_v_k*ind] /* ACCESS() */;
				ind++;
			}
		}} /* Close n1 */}} /* Close n2 */
				
	}	/* THREADLOOPEND */
	 v_datap += __privtrans->__thread.incs[0];
l_datap += __privtrans->__thread.incs[1];
u_datap += __privtrans->__thread.incs[2];

	 } v_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
l_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
u_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} v_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];l_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];u_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 v_datap -= __privtrans->__thread.offs[0];
l_datap -= __privtrans->__thread.offs[1];
u_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_vec2lu_free(pdl_trans *__tr) {
                int __dim;
                pdl_vec2lu_struct *__privtrans = (pdl_vec2lu_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_vec2lu_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_vec2lu_vtable = {
		0,0, 1, 3, pdl_vec2lu_vtable_flags, 
		pdl_vec2lu_redodims, pdl_vec2lu_readdata, NULL,
		pdl_vec2lu_free,NULL,NULL,pdl_vec2lu_copy,NULL,
		sizeof(pdl_vec2lu_struct),"pdl_vec2lu_vtable"
	 };

typedef struct pdl_nonorm_covar_lags_struct {
		PDL_TRANS_START(3);
		pdl_thread  __thread;PDL_Long  __inc_dat_nchan;PDL_Long  __inc_dat_ndat;PDL_Long  __inc_lags_nlags;PDL_Long  __inc_covar_nchan0;PDL_Long  __inc_covar_nlags0;PDL_Long  __inc_covar_nchan1;PDL_Long  __inc_covar_nlags1;PDL_Long  __nchan_size;PDL_Long  __nlags_size;PDL_Long  __ndat_size;
		
		char __ddone; /* Dims done */
		} pdl_nonorm_covar_lags_struct;

void pdl_nonorm_covar_lags_redodims(pdl_trans *__tr) {
                int __dim;
                pdl_nonorm_covar_lags_struct *__privtrans = (pdl_nonorm_covar_lags_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			int __creating[3];__privtrans->__nchan_size = -1;
__privtrans->__nlags_size = -1;
__privtrans->__ndat_size = -1;
__creating[0] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]))
				&& 0 ;
__creating[1] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]))
				&& 0 ;
__creating[2] = 
			(PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]))
				&& 1 ;
if((!__creating[0]) && __privtrans->pdls[0]->
				  ndims == 1 && __privtrans->pdls[0]->dims[0] == 0)
				   croak("Error in nonorm_covar_lags:" "CANNOT CREATE PARAMETER dat");
					if((!__creating[1]) && __privtrans->pdls[1]->
				  ndims == 1 && __privtrans->pdls[1]->dims[0] == 0)
				   croak("Error in nonorm_covar_lags:" "CANNOT CREATE PARAMETER lags");
					if((!__creating[2]) && __privtrans->pdls[2]->
				  ndims == 1 && __privtrans->pdls[2]->dims[0] == 0)
				   croak("Error in nonorm_covar_lags:" "CANNOT CREATE PARAMETER covar");
					 {
 static char *__parnames[] = {"dat","lags","covar"};
		static int __realdims[] = {2,1,4};
		static char __funcname[] = "PDL::Lib::PCARout: nonorm_covar_lags";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
			&__einfo,&(__privtrans->__thread));
		}
if(!__creating[0]) {
		if(((__privtrans->pdls[0]))->ndims < 2) {
			croak("Error in nonorm_covar_lags:" "Too few dimensions for dat\n");
		}
	
		  if(__privtrans->__nchan_size == -1 || __privtrans->__nchan_size == 1) {
			__privtrans->__nchan_size = ((__privtrans->pdls[0]))->dims[0];
		  } else if(__privtrans->__nchan_size != ((__privtrans->pdls[0]))->dims[0]) {
		  	if(((__privtrans->pdls[0]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in nonorm_covar_lags:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__ndat_size == -1 || __privtrans->__ndat_size == 1) {
			__privtrans->__ndat_size = ((__privtrans->pdls[0]))->dims[1];
		  } else if(__privtrans->__ndat_size != ((__privtrans->pdls[0]))->dims[1]) {
		  	if(((__privtrans->pdls[0]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in nonorm_covar_lags:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in nonorm_covar_lags:" "Cannot create non-output argument dat!\n");}if(!__creating[1]) {
		if(((__privtrans->pdls[1]))->ndims < 1) {
			croak("Error in nonorm_covar_lags:" "Too few dimensions for lags\n");
		}
	
		  if(__privtrans->__nlags_size == -1 || __privtrans->__nlags_size == 1) {
			__privtrans->__nlags_size = ((__privtrans->pdls[1]))->dims[0];
		  } else if(__privtrans->__nlags_size != ((__privtrans->pdls[1]))->dims[0]) {
		  	if(((__privtrans->pdls[1]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in nonorm_covar_lags:" "Wrong dims\n");
			}
		  }
		} else {croak("Error in nonorm_covar_lags:" "Cannot create non-output argument lags!\n");}if(!__creating[2]) {
		if(((__privtrans->pdls[2]))->ndims < 4) {
			croak("Error in nonorm_covar_lags:" "Too few dimensions for covar\n");
		}
	
		  if(__privtrans->__nchan_size == -1 || __privtrans->__nchan_size == 1) {
			__privtrans->__nchan_size = ((__privtrans->pdls[2]))->dims[0];
		  } else if(__privtrans->__nchan_size != ((__privtrans->pdls[2]))->dims[0]) {
		  	if(((__privtrans->pdls[2]))->dims[0] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in nonorm_covar_lags:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nlags_size == -1 || __privtrans->__nlags_size == 1) {
			__privtrans->__nlags_size = ((__privtrans->pdls[2]))->dims[1];
		  } else if(__privtrans->__nlags_size != ((__privtrans->pdls[2]))->dims[1]) {
		  	if(((__privtrans->pdls[2]))->dims[1] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in nonorm_covar_lags:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nchan_size == -1 || __privtrans->__nchan_size == 1) {
			__privtrans->__nchan_size = ((__privtrans->pdls[2]))->dims[2];
		  } else if(__privtrans->__nchan_size != ((__privtrans->pdls[2]))->dims[2]) {
		  	if(((__privtrans->pdls[2]))->dims[2] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in nonorm_covar_lags:" "Wrong dims\n");
			}
		  }
		
		  if(__privtrans->__nlags_size == -1 || __privtrans->__nlags_size == 1) {
			__privtrans->__nlags_size = ((__privtrans->pdls[2]))->dims[3];
		  } else if(__privtrans->__nlags_size != ((__privtrans->pdls[2]))->dims[3]) {
		  	if(((__privtrans->pdls[2]))->dims[3] == 1) {
				/* Do nothing */ /* XXX Careful, increment? */
			} else {
				croak("Error in nonorm_covar_lags:" "Wrong dims\n");
			}
		  }
		} else {int dims[5]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__nchan_size;dims[1] = __privtrans->__nlags_size;dims[2] = __privtrans->__nchan_size;dims[3] = __privtrans->__nlags_size;
 PDL->thread_create_parameter(&__privtrans->__thread,2,dims);
}if(__privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_dat_nchan = 0; else
		 __privtrans->__inc_dat_nchan = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_dat_ndat = 0; else
		 __privtrans->__inc_dat_ndat = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_lags_nlags = 0; else
		 __privtrans->__inc_lags_nlags = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_covar_nchan0 = 0; else
		 __privtrans->__inc_covar_nchan0 = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_covar_nlags0 = 0; else
		 __privtrans->__inc_covar_nlags0 = PDL_REPRINC(__privtrans->pdls[2],1);if(__privtrans->pdls[2]->dims[2] <= 1)
		  __privtrans->__inc_covar_nchan1 = 0; else
		 __privtrans->__inc_covar_nchan1 = PDL_REPRINC(__privtrans->pdls[2],2);if(__privtrans->pdls[2]->dims[3] <= 1)
		  __privtrans->__inc_covar_nlags1 = 0; else
		 __privtrans->__inc_covar_nlags1 = PDL_REPRINC(__privtrans->pdls[2],3); __privtrans->__ddone = 1;
		}
	}
        

pdl_trans * pdl_nonorm_covar_lags_copy(pdl_trans *__tr) {
                int __dim;
                pdl_nonorm_covar_lags_struct *__privtrans = (pdl_nonorm_covar_lags_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			pdl_nonorm_covar_lags_struct *__copy
 			= malloc(sizeof(pdl_nonorm_covar_lags_struct)); 
			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++) 
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__thread),&(__copy->__thread));__privtrans->__inc_dat_nchan=__copy->__inc_dat_nchan;__privtrans->__inc_dat_ndat=__copy->__inc_dat_ndat;__privtrans->__inc_lags_nlags=__copy->__inc_lags_nlags;__privtrans->__inc_covar_nchan0=__copy->__inc_covar_nchan0;__privtrans->__inc_covar_nlags0=__copy->__inc_covar_nlags0;__privtrans->__inc_covar_nchan1=__copy->__inc_covar_nchan1;__privtrans->__inc_covar_nlags1=__copy->__inc_covar_nlags1;__copy->__nchan_size=__privtrans->__nchan_size;__copy->__nlags_size=__privtrans->__nlags_size;__copy->__ndat_size=__privtrans->__ndat_size;
			}
			return (pdl_trans*)__copy;
		}
	}
        

void pdl_nonorm_covar_lags_readdata(pdl_trans *__tr) {
                int __dim;
                pdl_nonorm_covar_lags_struct *__privtrans = (pdl_nonorm_covar_lags_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_B
#define THISIS_B(a) a
	PDL_Byte *dat_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Byte *dat_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	
	long *lags_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *lags_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Byte *covar_datap = ((PDL_Byte *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Byte *covar_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 dat_datap += __privtrans->__thread.offs[0];
lags_datap += __privtrans->__thread.offs[1];
covar_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int lag0,lagn; int nlags,ndat;
		int di1,di2; int nlagsm1;
		ndat = __privtrans->__ndat_size; nlags = __privtrans->__nlags_size;
		lag0 = (lags_datap)[0+__privtrans->__inc_lags_nlags*0] /* ACCESS() */;
		nlagsm1 = nlags-1;
		lagn = (lags_datap)[0+__privtrans->__inc_lags_nlags*nlagsm1] /* ACCESS() */;
		{/* Open ndat */ long ndat; 
			for(ndat=0; ndat<__privtrans->__ndat_size; ndat++) {
			if(ndat < lagn) continue;
			{/* Open nlags1 */ long nlags1; 
			for(nlags1=0; nlags1<__privtrans->__nlags_size; nlags1++) {{/* Open nlags2 */ long nlags2; 
			for(nlags2=0; nlags2<__privtrans->__nlags_size; nlags2++) {
				di1 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags1] /* ACCESS() */;
				di2 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags2] /* ACCESS() */;
				{/* Open nchan1 */ long nchan1; 
			for(nchan1=0; nchan1<__privtrans->__nchan_size; nchan1++) {{/* Open nchan2 */ long nchan2; 
			for(nchan2=0; nchan2<__privtrans->__nchan_size; nchan2++) {
					(covar_datap)[0+__privtrans->__inc_covar_nchan0*nchan1+__privtrans->__inc_covar_nlags0*nlags1+__privtrans->__inc_covar_nchan1*nchan2+__privtrans->__inc_covar_nlags1*nlags2] /* ACCESS() */ +=
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan1+__privtrans->__inc_dat_ndat*di1] /* ACCESS() */ *
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan2+__privtrans->__inc_dat_ndat*di2] /* ACCESS() */;
				}} /* Close nchan1 */}} /* Close nchan2 */
			}} /* Close nlags1 */}} /* Close nlags2 */
		}} /* Close ndat */
	}	/* THREADLOOPEND */
	 dat_datap += __privtrans->__thread.incs[0];
lags_datap += __privtrans->__thread.incs[1];
covar_datap += __privtrans->__thread.incs[2];

	 } dat_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
lags_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
covar_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} dat_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];lags_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];covar_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 dat_datap -= __privtrans->__thread.offs[0];
lags_datap -= __privtrans->__thread.offs[1];
covar_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_S: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_S
#define THISIS_S(a) a
	PDL_Short *dat_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Short *dat_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	
	long *lags_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *lags_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Short *covar_datap = ((PDL_Short *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Short *covar_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 dat_datap += __privtrans->__thread.offs[0];
lags_datap += __privtrans->__thread.offs[1];
covar_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int lag0,lagn; int nlags,ndat;
		int di1,di2; int nlagsm1;
		ndat = __privtrans->__ndat_size; nlags = __privtrans->__nlags_size;
		lag0 = (lags_datap)[0+__privtrans->__inc_lags_nlags*0] /* ACCESS() */;
		nlagsm1 = nlags-1;
		lagn = (lags_datap)[0+__privtrans->__inc_lags_nlags*nlagsm1] /* ACCESS() */;
		{/* Open ndat */ long ndat; 
			for(ndat=0; ndat<__privtrans->__ndat_size; ndat++) {
			if(ndat < lagn) continue;
			{/* Open nlags1 */ long nlags1; 
			for(nlags1=0; nlags1<__privtrans->__nlags_size; nlags1++) {{/* Open nlags2 */ long nlags2; 
			for(nlags2=0; nlags2<__privtrans->__nlags_size; nlags2++) {
				di1 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags1] /* ACCESS() */;
				di2 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags2] /* ACCESS() */;
				{/* Open nchan1 */ long nchan1; 
			for(nchan1=0; nchan1<__privtrans->__nchan_size; nchan1++) {{/* Open nchan2 */ long nchan2; 
			for(nchan2=0; nchan2<__privtrans->__nchan_size; nchan2++) {
					(covar_datap)[0+__privtrans->__inc_covar_nchan0*nchan1+__privtrans->__inc_covar_nlags0*nlags1+__privtrans->__inc_covar_nchan1*nchan2+__privtrans->__inc_covar_nlags1*nlags2] /* ACCESS() */ +=
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan1+__privtrans->__inc_dat_ndat*di1] /* ACCESS() */ *
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan2+__privtrans->__inc_dat_ndat*di2] /* ACCESS() */;
				}} /* Close nchan1 */}} /* Close nchan2 */
			}} /* Close nlags1 */}} /* Close nlags2 */
		}} /* Close ndat */
	}	/* THREADLOOPEND */
	 dat_datap += __privtrans->__thread.incs[0];
lags_datap += __privtrans->__thread.incs[1];
covar_datap += __privtrans->__thread.incs[2];

	 } dat_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
lags_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
covar_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} dat_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];lags_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];covar_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 dat_datap -= __privtrans->__thread.offs[0];
lags_datap -= __privtrans->__thread.offs[1];
covar_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_US: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_U
#define THISIS_U(a) a
	PDL_Ushort *dat_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Ushort *dat_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	
	long *lags_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *lags_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Ushort *covar_datap = ((PDL_Ushort *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Ushort *covar_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 dat_datap += __privtrans->__thread.offs[0];
lags_datap += __privtrans->__thread.offs[1];
covar_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int lag0,lagn; int nlags,ndat;
		int di1,di2; int nlagsm1;
		ndat = __privtrans->__ndat_size; nlags = __privtrans->__nlags_size;
		lag0 = (lags_datap)[0+__privtrans->__inc_lags_nlags*0] /* ACCESS() */;
		nlagsm1 = nlags-1;
		lagn = (lags_datap)[0+__privtrans->__inc_lags_nlags*nlagsm1] /* ACCESS() */;
		{/* Open ndat */ long ndat; 
			for(ndat=0; ndat<__privtrans->__ndat_size; ndat++) {
			if(ndat < lagn) continue;
			{/* Open nlags1 */ long nlags1; 
			for(nlags1=0; nlags1<__privtrans->__nlags_size; nlags1++) {{/* Open nlags2 */ long nlags2; 
			for(nlags2=0; nlags2<__privtrans->__nlags_size; nlags2++) {
				di1 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags1] /* ACCESS() */;
				di2 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags2] /* ACCESS() */;
				{/* Open nchan1 */ long nchan1; 
			for(nchan1=0; nchan1<__privtrans->__nchan_size; nchan1++) {{/* Open nchan2 */ long nchan2; 
			for(nchan2=0; nchan2<__privtrans->__nchan_size; nchan2++) {
					(covar_datap)[0+__privtrans->__inc_covar_nchan0*nchan1+__privtrans->__inc_covar_nlags0*nlags1+__privtrans->__inc_covar_nchan1*nchan2+__privtrans->__inc_covar_nlags1*nlags2] /* ACCESS() */ +=
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan1+__privtrans->__inc_dat_ndat*di1] /* ACCESS() */ *
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan2+__privtrans->__inc_dat_ndat*di2] /* ACCESS() */;
				}} /* Close nchan1 */}} /* Close nchan2 */
			}} /* Close nlags1 */}} /* Close nlags2 */
		}} /* Close ndat */
	}	/* THREADLOOPEND */
	 dat_datap += __privtrans->__thread.incs[0];
lags_datap += __privtrans->__thread.incs[1];
covar_datap += __privtrans->__thread.incs[2];

	 } dat_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
lags_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
covar_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} dat_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];lags_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];covar_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 dat_datap -= __privtrans->__thread.offs[0];
lags_datap -= __privtrans->__thread.offs[1];
covar_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_L: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_L
#define THISIS_L(a) a
	PDL_Long *dat_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Long *dat_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	
	long *lags_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *lags_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Long *covar_datap = ((PDL_Long *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Long *covar_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 dat_datap += __privtrans->__thread.offs[0];
lags_datap += __privtrans->__thread.offs[1];
covar_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int lag0,lagn; int nlags,ndat;
		int di1,di2; int nlagsm1;
		ndat = __privtrans->__ndat_size; nlags = __privtrans->__nlags_size;
		lag0 = (lags_datap)[0+__privtrans->__inc_lags_nlags*0] /* ACCESS() */;
		nlagsm1 = nlags-1;
		lagn = (lags_datap)[0+__privtrans->__inc_lags_nlags*nlagsm1] /* ACCESS() */;
		{/* Open ndat */ long ndat; 
			for(ndat=0; ndat<__privtrans->__ndat_size; ndat++) {
			if(ndat < lagn) continue;
			{/* Open nlags1 */ long nlags1; 
			for(nlags1=0; nlags1<__privtrans->__nlags_size; nlags1++) {{/* Open nlags2 */ long nlags2; 
			for(nlags2=0; nlags2<__privtrans->__nlags_size; nlags2++) {
				di1 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags1] /* ACCESS() */;
				di2 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags2] /* ACCESS() */;
				{/* Open nchan1 */ long nchan1; 
			for(nchan1=0; nchan1<__privtrans->__nchan_size; nchan1++) {{/* Open nchan2 */ long nchan2; 
			for(nchan2=0; nchan2<__privtrans->__nchan_size; nchan2++) {
					(covar_datap)[0+__privtrans->__inc_covar_nchan0*nchan1+__privtrans->__inc_covar_nlags0*nlags1+__privtrans->__inc_covar_nchan1*nchan2+__privtrans->__inc_covar_nlags1*nlags2] /* ACCESS() */ +=
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan1+__privtrans->__inc_dat_ndat*di1] /* ACCESS() */ *
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan2+__privtrans->__inc_dat_ndat*di2] /* ACCESS() */;
				}} /* Close nchan1 */}} /* Close nchan2 */
			}} /* Close nlags1 */}} /* Close nlags2 */
		}} /* Close ndat */
	}	/* THREADLOOPEND */
	 dat_datap += __privtrans->__thread.incs[0];
lags_datap += __privtrans->__thread.incs[1];
covar_datap += __privtrans->__thread.incs[2];

	 } dat_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
lags_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
covar_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} dat_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];lags_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];covar_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 dat_datap -= __privtrans->__thread.offs[0];
lags_datap -= __privtrans->__thread.offs[1];
covar_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float *dat_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Float *dat_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	
	long *lags_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *lags_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Float *covar_datap = ((PDL_Float *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Float *covar_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 dat_datap += __privtrans->__thread.offs[0];
lags_datap += __privtrans->__thread.offs[1];
covar_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int lag0,lagn; int nlags,ndat;
		int di1,di2; int nlagsm1;
		ndat = __privtrans->__ndat_size; nlags = __privtrans->__nlags_size;
		lag0 = (lags_datap)[0+__privtrans->__inc_lags_nlags*0] /* ACCESS() */;
		nlagsm1 = nlags-1;
		lagn = (lags_datap)[0+__privtrans->__inc_lags_nlags*nlagsm1] /* ACCESS() */;
		{/* Open ndat */ long ndat; 
			for(ndat=0; ndat<__privtrans->__ndat_size; ndat++) {
			if(ndat < lagn) continue;
			{/* Open nlags1 */ long nlags1; 
			for(nlags1=0; nlags1<__privtrans->__nlags_size; nlags1++) {{/* Open nlags2 */ long nlags2; 
			for(nlags2=0; nlags2<__privtrans->__nlags_size; nlags2++) {
				di1 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags1] /* ACCESS() */;
				di2 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags2] /* ACCESS() */;
				{/* Open nchan1 */ long nchan1; 
			for(nchan1=0; nchan1<__privtrans->__nchan_size; nchan1++) {{/* Open nchan2 */ long nchan2; 
			for(nchan2=0; nchan2<__privtrans->__nchan_size; nchan2++) {
					(covar_datap)[0+__privtrans->__inc_covar_nchan0*nchan1+__privtrans->__inc_covar_nlags0*nlags1+__privtrans->__inc_covar_nchan1*nchan2+__privtrans->__inc_covar_nlags1*nlags2] /* ACCESS() */ +=
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan1+__privtrans->__inc_dat_ndat*di1] /* ACCESS() */ *
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan2+__privtrans->__inc_dat_ndat*di2] /* ACCESS() */;
				}} /* Close nchan1 */}} /* Close nchan2 */
			}} /* Close nlags1 */}} /* Close nlags2 */
		}} /* Close ndat */
	}	/* THREADLOOPEND */
	 dat_datap += __privtrans->__thread.incs[0];
lags_datap += __privtrans->__thread.incs[1];
covar_datap += __privtrans->__thread.incs[2];

	 } dat_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
lags_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
covar_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} dat_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];lags_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];covar_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 dat_datap -= __privtrans->__thread.offs[0];
lags_datap -= __privtrans->__thread.offs[1];
covar_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double *dat_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[0]))));
		PDL_Double *dat_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	
	long *lags_datap = ((long *)(PDL_REPRP((__privtrans->pdls[1]))));
		long *lags_physdatap = ((long *)((__privtrans->pdls[1])->data));
	
	PDL_Double *covar_datap = ((PDL_Double *)(PDL_REPRP((__privtrans->pdls[2]))));
		PDL_Double *covar_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	
	/* THREADLOOPBEGIN */
 PDL->startthreadloop(&(__privtrans->__thread));
   do { int __tind1=0,__tind2=0;  int __tnpdls = __privtrans->__thread.npdls;
 dat_datap += __privtrans->__thread.offs[0];
lags_datap += __privtrans->__thread.offs[1];
covar_datap += __privtrans->__thread.offs[2];

	for(__tind2=0; __tind2<__privtrans->__thread.dims[1]; __tind2++) {
	 for(__tind1=0; __tind1<__privtrans->__thread.dims[0]; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
		int lag0,lagn; int nlags,ndat;
		int di1,di2; int nlagsm1;
		ndat = __privtrans->__ndat_size; nlags = __privtrans->__nlags_size;
		lag0 = (lags_datap)[0+__privtrans->__inc_lags_nlags*0] /* ACCESS() */;
		nlagsm1 = nlags-1;
		lagn = (lags_datap)[0+__privtrans->__inc_lags_nlags*nlagsm1] /* ACCESS() */;
		{/* Open ndat */ long ndat; 
			for(ndat=0; ndat<__privtrans->__ndat_size; ndat++) {
			if(ndat < lagn) continue;
			{/* Open nlags1 */ long nlags1; 
			for(nlags1=0; nlags1<__privtrans->__nlags_size; nlags1++) {{/* Open nlags2 */ long nlags2; 
			for(nlags2=0; nlags2<__privtrans->__nlags_size; nlags2++) {
				di1 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags1] /* ACCESS() */;
				di2 = ndat - (lags_datap)[0+__privtrans->__inc_lags_nlags*nlags2] /* ACCESS() */;
				{/* Open nchan1 */ long nchan1; 
			for(nchan1=0; nchan1<__privtrans->__nchan_size; nchan1++) {{/* Open nchan2 */ long nchan2; 
			for(nchan2=0; nchan2<__privtrans->__nchan_size; nchan2++) {
					(covar_datap)[0+__privtrans->__inc_covar_nchan0*nchan1+__privtrans->__inc_covar_nlags0*nlags1+__privtrans->__inc_covar_nchan1*nchan2+__privtrans->__inc_covar_nlags1*nlags2] /* ACCESS() */ +=
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan1+__privtrans->__inc_dat_ndat*di1] /* ACCESS() */ *
					  (dat_datap)[0+__privtrans->__inc_dat_nchan*nchan2+__privtrans->__inc_dat_ndat*di2] /* ACCESS() */;
				}} /* Close nchan1 */}} /* Close nchan2 */
			}} /* Close nlags1 */}} /* Close nlags2 */
		}} /* Close ndat */
	}	/* THREADLOOPEND */
	 dat_datap += __privtrans->__thread.incs[0];
lags_datap += __privtrans->__thread.incs[1];
covar_datap += __privtrans->__thread.incs[2];

	 } dat_datap += __privtrans->__thread.incs[__tnpdls+0]
	     			     - __privtrans->__thread.incs[0] *
				       __privtrans->__thread.dims[0];
lags_datap += __privtrans->__thread.incs[__tnpdls+1]
	     			     - __privtrans->__thread.incs[1] *
				       __privtrans->__thread.dims[0];
covar_datap += __privtrans->__thread.incs[__tnpdls+2]
	     			     - __privtrans->__thread.incs[2] *
				       __privtrans->__thread.dims[0];

	} dat_datap -= __privtrans->__thread.incs[__tnpdls+0] *
     				  __privtrans->__thread.dims[1];lags_datap -= __privtrans->__thread.incs[__tnpdls+1] *
     				  __privtrans->__thread.dims[1];covar_datap -= __privtrans->__thread.incs[__tnpdls+2] *
     				  __privtrans->__thread.dims[1];
 dat_datap -= __privtrans->__thread.offs[0];
lags_datap -= __privtrans->__thread.offs[1];
covar_datap -= __privtrans->__thread.offs[2];

	} while(PDL->iterthreadloop(&__privtrans->__thread,2));
 	break;}
	default:croak("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}

		}
	}
        



void pdl_nonorm_covar_lags_free(pdl_trans *__tr) {
                int __dim;
                pdl_nonorm_covar_lags_struct *__privtrans = (pdl_nonorm_covar_lags_struct *) __tr;
                pdl *__it = __tr->pdls[1];
                pdl *__parent = __tr->pdls[0];
                {
			
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__thread));
			}
			
		}
	}
        

static char pdl_nonorm_covar_lags_vtable_flags[] = 
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_nonorm_covar_lags_vtable = {
		0,0, 2, 3, pdl_nonorm_covar_lags_vtable_flags, 
		pdl_nonorm_covar_lags_redodims, pdl_nonorm_covar_lags_readdata, NULL,
		pdl_nonorm_covar_lags_free,NULL,NULL,pdl_nonorm_covar_lags_copy,NULL,
		sizeof(pdl_nonorm_covar_lags_struct),"pdl_nonorm_covar_lags_vtable"
	 };



MODULE = PDL::Lib::PCARout PACKAGE = PDL::Lib::PCARout

int
set_debugging(i)
	int i;
	CODE:
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
	OUTPUT:
	RETVAL
 

void
pca_oja(w,eta,data)
	pdl  *w
	pdl  *eta
	pdl  *data
 CODE:
 { pdl_pca_oja_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_pca_oja_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;eta = PDL->make_now(eta);
data = PDL->make_now(data);
w = PDL->make_now(w);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < eta->datatype) {
		 	__privtrans->__datatype = eta->datatype;
		  }
		  if(
		 	__privtrans->__datatype < data->datatype) {
		 	__privtrans->__datatype = data->datatype;
		  }
		  if(
		 	__privtrans->__datatype < w->datatype) {
		 	__privtrans->__datatype = w->datatype;
		  }
		  if(__privtrans->__datatype == PDL_B) {
		 } else if(__privtrans->__datatype == PDL_S) {
		 } else if(__privtrans->__datatype == PDL_U) {
		 } else if(__privtrans->__datatype == PDL_L) {
		 } else if(__privtrans->__datatype == PDL_F) {
		 } else if(__privtrans->__datatype == PDL_D) {
		 } else __privtrans->__datatype = PDL_D;if(((eta->state & PDL_NOMYDIMS) &&
		         eta->trans == NULL) &&
		       0) {
			  eta->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != eta->datatype) {
			eta = PDL->get_convertedpdl(eta,__privtrans->__datatype);
		    }if(((data->state & PDL_NOMYDIMS) &&
		         data->trans == NULL) &&
		       0) {
			  data->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != data->datatype) {
			data = PDL->get_convertedpdl(data,__privtrans->__datatype);
		    }if(((w->state & PDL_NOMYDIMS) &&
		         w->trans == NULL) &&
		       0) {
			  w->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != w->datatype) {
			w = PDL->get_convertedpdl(w,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = eta;
__privtrans->pdls[1] = data;
__privtrans->pdls[2] = w;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}

void
pca_ojakarhunen(w,wtmp,ytmp,ytmpx,eta,data)
	pdl  *w
	pdl  *wtmp
	pdl  *ytmp
	pdl  *ytmpx
	pdl  *eta
	pdl  *data
 CODE:
 { pdl_pca_ojakarhunen_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_pca_ojakarhunen_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;w = PDL->make_now(w);
wtmp = PDL->make_now(wtmp);
ytmp = PDL->make_now(ytmp);
ytmpx = PDL->make_now(ytmpx);
eta = PDL->make_now(eta);
data = PDL->make_now(data);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < w->datatype) {
		 	__privtrans->__datatype = w->datatype;
		  }
		  if(
		 	__privtrans->__datatype < wtmp->datatype) {
		 	__privtrans->__datatype = wtmp->datatype;
		  }
		  if(
		 	__privtrans->__datatype < ytmp->datatype) {
		 	__privtrans->__datatype = ytmp->datatype;
		  }
		  if(
		 	__privtrans->__datatype < ytmpx->datatype) {
		 	__privtrans->__datatype = ytmpx->datatype;
		  }
		  if(
		 	__privtrans->__datatype < eta->datatype) {
		 	__privtrans->__datatype = eta->datatype;
		  }
		  if(
		 	__privtrans->__datatype < data->datatype) {
		 	__privtrans->__datatype = data->datatype;
		  }
		  if(__privtrans->__datatype == PDL_B) {
		 } else if(__privtrans->__datatype == PDL_S) {
		 } else if(__privtrans->__datatype == PDL_U) {
		 } else if(__privtrans->__datatype == PDL_L) {
		 } else if(__privtrans->__datatype == PDL_F) {
		 } else if(__privtrans->__datatype == PDL_D) {
		 } else __privtrans->__datatype = PDL_D;if(((w->state & PDL_NOMYDIMS) &&
		         w->trans == NULL) &&
		       0) {
			  w->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != w->datatype) {
			w = PDL->get_convertedpdl(w,__privtrans->__datatype);
		    }if(((wtmp->state & PDL_NOMYDIMS) &&
		         wtmp->trans == NULL) &&
		       0) {
			  wtmp->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != wtmp->datatype) {
			wtmp = PDL->get_convertedpdl(wtmp,__privtrans->__datatype);
		    }if(((ytmp->state & PDL_NOMYDIMS) &&
		         ytmp->trans == NULL) &&
		       0) {
			  ytmp->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != ytmp->datatype) {
			ytmp = PDL->get_convertedpdl(ytmp,__privtrans->__datatype);
		    }if(((ytmpx->state & PDL_NOMYDIMS) &&
		         ytmpx->trans == NULL) &&
		       0) {
			  ytmpx->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != ytmpx->datatype) {
			ytmpx = PDL->get_convertedpdl(ytmpx,__privtrans->__datatype);
		    }if(((eta->state & PDL_NOMYDIMS) &&
		         eta->trans == NULL) &&
		       0) {
			  eta->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != eta->datatype) {
			eta = PDL->get_convertedpdl(eta,__privtrans->__datatype);
		    }if(((data->state & PDL_NOMYDIMS) &&
		         data->trans == NULL) &&
		       0) {
			  data->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != data->datatype) {
			data = PDL->get_convertedpdl(data,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = w;
__privtrans->pdls[1] = wtmp;
__privtrans->pdls[2] = ytmp;
__privtrans->pdls[3] = ytmpx;
__privtrans->pdls[4] = eta;
__privtrans->pdls[5] = data;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}

void
pca_sanger(w,wtmp,ytmp,ytmpx,eta,data)
	pdl  *w
	pdl  *wtmp
	pdl  *ytmp
	pdl  *ytmpx
	pdl  *eta
	pdl  *data
 CODE:
 { pdl_pca_sanger_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_pca_sanger_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;w = PDL->make_now(w);
wtmp = PDL->make_now(wtmp);
ytmp = PDL->make_now(ytmp);
ytmpx = PDL->make_now(ytmpx);
eta = PDL->make_now(eta);
data = PDL->make_now(data);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < w->datatype) {
		 	__privtrans->__datatype = w->datatype;
		  }
		  if(
		 	__privtrans->__datatype < wtmp->datatype) {
		 	__privtrans->__datatype = wtmp->datatype;
		  }
		  if(
		 	__privtrans->__datatype < ytmp->datatype) {
		 	__privtrans->__datatype = ytmp->datatype;
		  }
		  if(
		 	__privtrans->__datatype < ytmpx->datatype) {
		 	__privtrans->__datatype = ytmpx->datatype;
		  }
		  if(
		 	__privtrans->__datatype < eta->datatype) {
		 	__privtrans->__datatype = eta->datatype;
		  }
		  if(
		 	__privtrans->__datatype < data->datatype) {
		 	__privtrans->__datatype = data->datatype;
		  }
		  if(__privtrans->__datatype == PDL_B) {
		 } else if(__privtrans->__datatype == PDL_S) {
		 } else if(__privtrans->__datatype == PDL_U) {
		 } else if(__privtrans->__datatype == PDL_L) {
		 } else if(__privtrans->__datatype == PDL_F) {
		 } else if(__privtrans->__datatype == PDL_D) {
		 } else __privtrans->__datatype = PDL_D;if(((w->state & PDL_NOMYDIMS) &&
		         w->trans == NULL) &&
		       0) {
			  w->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != w->datatype) {
			w = PDL->get_convertedpdl(w,__privtrans->__datatype);
		    }if(((wtmp->state & PDL_NOMYDIMS) &&
		         wtmp->trans == NULL) &&
		       0) {
			  wtmp->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != wtmp->datatype) {
			wtmp = PDL->get_convertedpdl(wtmp,__privtrans->__datatype);
		    }if(((ytmp->state & PDL_NOMYDIMS) &&
		         ytmp->trans == NULL) &&
		       0) {
			  ytmp->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != ytmp->datatype) {
			ytmp = PDL->get_convertedpdl(ytmp,__privtrans->__datatype);
		    }if(((ytmpx->state & PDL_NOMYDIMS) &&
		         ytmpx->trans == NULL) &&
		       0) {
			  ytmpx->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != ytmpx->datatype) {
			ytmpx = PDL->get_convertedpdl(ytmpx,__privtrans->__datatype);
		    }if(((eta->state & PDL_NOMYDIMS) &&
		         eta->trans == NULL) &&
		       0) {
			  eta->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != eta->datatype) {
			eta = PDL->get_convertedpdl(eta,__privtrans->__datatype);
		    }if(((data->state & PDL_NOMYDIMS) &&
		         data->trans == NULL) &&
		       0) {
			  data->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != data->datatype) {
			data = PDL->get_convertedpdl(data,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = w;
__privtrans->pdls[1] = wtmp;
__privtrans->pdls[2] = ytmp;
__privtrans->pdls[3] = ytmpx;
__privtrans->pdls[4] = eta;
__privtrans->pdls[5] = data;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}

void
transdiacumusum(data,trans,cum)
	pdl  *data
	pdl  *trans
	pdl  *cum
 CODE:
 { pdl_transdiacumusum_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_transdiacumusum_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;data = PDL->make_now(data);
trans = PDL->make_now(trans);
cum = PDL->make_now(cum);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < data->datatype) {
		 	__privtrans->__datatype = data->datatype;
		  }
		  if(
		 	__privtrans->__datatype < trans->datatype) {
		 	__privtrans->__datatype = trans->datatype;
		  }
		  if(
		 	__privtrans->__datatype < cum->datatype) {
		 	__privtrans->__datatype = cum->datatype;
		  }
		  if(__privtrans->__datatype == PDL_B) {
		 } else if(__privtrans->__datatype == PDL_S) {
		 } else if(__privtrans->__datatype == PDL_U) {
		 } else if(__privtrans->__datatype == PDL_L) {
		 } else if(__privtrans->__datatype == PDL_F) {
		 } else if(__privtrans->__datatype == PDL_D) {
		 } else __privtrans->__datatype = PDL_D;if(((data->state & PDL_NOMYDIMS) &&
		         data->trans == NULL) &&
		       0) {
			  data->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != data->datatype) {
			data = PDL->get_convertedpdl(data,__privtrans->__datatype);
		    }if(((trans->state & PDL_NOMYDIMS) &&
		         trans->trans == NULL) &&
		       0) {
			  trans->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != trans->datatype) {
			trans = PDL->get_convertedpdl(trans,__privtrans->__datatype);
		    }if(((cum->state & PDL_NOMYDIMS) &&
		         cum->trans == NULL) &&
		       0) {
			  cum->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != cum->datatype) {
			cum = PDL->get_convertedpdl(cum,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = data;
__privtrans->pdls[1] = trans;
__privtrans->pdls[2] = cum;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}

void
vec2asym(v,m)
	pdl  *v
	pdl  *m
 CODE:
 { pdl_vec2asym_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_vec2asym_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;v = PDL->make_now(v);
m = PDL->make_now(m);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < v->datatype) {
		 	__privtrans->__datatype = v->datatype;
		  }
		  if(!((m->state & PDL_NOMYDIMS) &&
		       m->trans == NULL) &&
		 	__privtrans->__datatype < m->datatype) {
		 	__privtrans->__datatype = m->datatype;
		  }
		  if(__privtrans->__datatype == PDL_B) {
		 } else if(__privtrans->__datatype == PDL_S) {
		 } else if(__privtrans->__datatype == PDL_U) {
		 } else if(__privtrans->__datatype == PDL_L) {
		 } else if(__privtrans->__datatype == PDL_F) {
		 } else if(__privtrans->__datatype == PDL_D) {
		 } else __privtrans->__datatype = PDL_D;if(((v->state & PDL_NOMYDIMS) &&
		         v->trans == NULL) &&
		       0) {
			  v->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != v->datatype) {
			v = PDL->get_convertedpdl(v,__privtrans->__datatype);
		    }if(((m->state & PDL_NOMYDIMS) &&
		         m->trans == NULL) &&
		       01) {
			  m->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != m->datatype) {
			m = PDL->get_convertedpdl(m,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = v;
__privtrans->pdls[1] = m;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}

void
vec2lu(v,l,u)
	pdl  *v
	pdl  *l
	pdl  *u
 CODE:
 { pdl_vec2lu_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_vec2lu_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;v = PDL->make_now(v);
l = PDL->make_now(l);
u = PDL->make_now(u);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < v->datatype) {
		 	__privtrans->__datatype = v->datatype;
		  }
		  if(!((l->state & PDL_NOMYDIMS) &&
		       l->trans == NULL) &&
		 	__privtrans->__datatype < l->datatype) {
		 	__privtrans->__datatype = l->datatype;
		  }
		  if(!((u->state & PDL_NOMYDIMS) &&
		       u->trans == NULL) &&
		 	__privtrans->__datatype < u->datatype) {
		 	__privtrans->__datatype = u->datatype;
		  }
		  if(__privtrans->__datatype == PDL_B) {
		 } else if(__privtrans->__datatype == PDL_S) {
		 } else if(__privtrans->__datatype == PDL_U) {
		 } else if(__privtrans->__datatype == PDL_L) {
		 } else if(__privtrans->__datatype == PDL_F) {
		 } else if(__privtrans->__datatype == PDL_D) {
		 } else __privtrans->__datatype = PDL_D;if(((v->state & PDL_NOMYDIMS) &&
		         v->trans == NULL) &&
		       0) {
			  v->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != v->datatype) {
			v = PDL->get_convertedpdl(v,__privtrans->__datatype);
		    }if(((l->state & PDL_NOMYDIMS) &&
		         l->trans == NULL) &&
		       01) {
			  l->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != l->datatype) {
			l = PDL->get_convertedpdl(l,__privtrans->__datatype);
		    }if(((u->state & PDL_NOMYDIMS) &&
		         u->trans == NULL) &&
		       01) {
			  u->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != u->datatype) {
			u = PDL->get_convertedpdl(u,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = v;
__privtrans->pdls[1] = l;
__privtrans->pdls[2] = u;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}

void
nonorm_covar_lags(dat,lags,covar)
	pdl  *dat
	pdl  *lags
	pdl  *covar
 CODE:
 { pdl_nonorm_covar_lags_struct  *__privtrans;__privtrans = malloc(sizeof(*__privtrans));
		PDL_TR_SETMAGIC(__privtrans);
		__privtrans->flags = 0;
		__privtrans->__ddone = 0;
		__privtrans->vtable = &pdl_nonorm_covar_lags_vtable;
		__privtrans->freeproc = PDL->trans_mallocfreeproc;dat = PDL->make_now(dat);
lags = PDL->make_now(lags);
covar = PDL->make_now(covar);
__privtrans->__datatype = 0;if(
		 	__privtrans->__datatype < dat->datatype) {
		 	__privtrans->__datatype = dat->datatype;
		  }
		  if(!((covar->state & PDL_NOMYDIMS) &&
		       covar->trans == NULL) &&
		 	__privtrans->__datatype < covar->datatype) {
		 	__privtrans->__datatype = covar->datatype;
		  }
		  if(__privtrans->__datatype == PDL_B) {
		 } else if(__privtrans->__datatype == PDL_S) {
		 } else if(__privtrans->__datatype == PDL_U) {
		 } else if(__privtrans->__datatype == PDL_L) {
		 } else if(__privtrans->__datatype == PDL_F) {
		 } else if(__privtrans->__datatype == PDL_D) {
		 } else __privtrans->__datatype = PDL_D;if(((dat->state & PDL_NOMYDIMS) &&
		         dat->trans == NULL) &&
		       0) {
			  dat->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != dat->datatype) {
			dat = PDL->get_convertedpdl(dat,__privtrans->__datatype);
		    }if(((lags->state & PDL_NOMYDIMS) &&
		         lags->trans == NULL) &&
		       0) {
			  lags->datatype =  PDL_L ;
		    } else if( PDL_L  != lags->datatype) {
			lags = PDL->get_convertedpdl(lags, PDL_L );
		    }if(((covar->state & PDL_NOMYDIMS) &&
		         covar->trans == NULL) &&
		       01) {
			  covar->datatype = __privtrans->__datatype;
		    } else if(__privtrans->__datatype != covar->datatype) {
			covar = PDL->get_convertedpdl(covar,__privtrans->__datatype);
		    }{}__privtrans->pdls[0] = dat;
__privtrans->pdls[1] = lags;
__privtrans->pdls[2] = covar;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
 XSRETURN(0);
}


BOOT:
   /* Get pointer to structure of core shared C routines */
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
   if (CoreSV==NULL)
     croak("This module requires use of PDL::Core first");
   PDL = (Core*) (void*) SvIV( CoreSV );  /* Core* value */
          
